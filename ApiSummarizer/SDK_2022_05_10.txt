--------------

accelerators/crypto_custom_api.h: 

void fun_crypto_aes_multi_xts(struct channel *channel, struct flow *flow, struct fun_crypto_ctx *ctx, uint8_t num_bufs, uint8_t *tweaks, struct fun_ptr_and_size *in_vectors, struct fun_ptr_and_size *out_vectors, uint32_t tweak_len, uint16_t *status);
void fun_crypto_aes_xts_multi_buf(struct channel *channel, struct flow *flow, struct fun_crypto_ctx *ctx, uint8_t num_bufs, uint8_t *tweaks, uint32_t tweak_len, uint8_t *in_md_bufs, uint8_t *out_md_bufs, uint32_t md_len, struct fun_ptr_and_size *in_vectors, struct fun_ptr_and_size *out_vectors, uint16_t *status);

--------------

accelerators/crypto_kpp.h: 

void *crypto_dh_alloc_key_blob(uint32_t key_size, bool create_key);
void *crypto_ec_alloc_key_blob(uint32_t keytype, bool create_key);
void *crypto_eddsa_alloc_key_blob(uint32_t keytype, bool create_key);

--------------

accelerators/crypto_pke.h: 

typedef struct crypto_rsa_info {uint64_t result; void *key_blob; uint8_t *auth_data; uint16_t mod_len; uint16_t e_len; bool isCRT; uint8_t *n; uint8_t *d; uint8_t *e; uint8_t *p; uint8_t *q; uint8_t *dp; uint8_t *dq; uint8_t *qinv;}CRYPTO_RSA_INFO;
typedef struct crypto_rsa_sign_req {uint64_t result; void *key_blob; uint8_t *auth_data; uint16_t mod_len; uint16_t hash_len; uint16_t sig_len; uint16_t e_len; uint16_t pss_salt_len; uint8_t hash_type; uint8_t pad_type; uint32_t e_word; uint8_t *n; uint8_t *e; uint8_t *hash; uint8_t *sig;}CRYPTO_RSA_SIGN_REQ;
typedef struct crypto_rsa_enc_req {uint64_t result; void *key_blob; uint8_t *auth_data; uint16_t mod_len; uint16_t hash_type; uint16_t pad_type; uint16_t e_len; uint32_t e_word; uint32_t pt_len; uint32_t *ptlen_ptr; uint8_t *n; uint8_t *e; uint8_t *pt; uint8_t *ct;}CRYPTO_RSA_ENC_REQ;
typedef struct crypto_ecdsa_req {uint64_t result; void *key_blob; uint8_t *auth_data; int key_type; uint32_t hash_len; uint8_t *hash; uint8_t *key_x; uint8_t *key_y; uint8_t *sig_r; uint8_t *sig_s;}CRYPTO_ECDSA_REQ;
typedef struct crypto_eddsa_req {uint64_t result; void *key_blob; uint8_t *auth_data; uint8_t *pk; uint8_t *digest; int digest_len; uint8_t *sig;}CRYPTO_EDDSA_REQ;
typedef struct crypto_dsa_info {uint64_t result; void *key_blob; uint8_t *auth_data; uint8_t *key;}CRYPTO_DSA_INFO;
typedef struct crypto_dsa_req {uint64_t result; void *key_blob; uint8_t *auth_data; int digest_type; int pglen; int qlen; uint8_t *p; uint8_t *q; uint8_t *g; uint8_t *r; uint8_t *s; uint8_t *y; uint8_t *digest;}CRYPTO_DSA_REQ;
int pke_hash_alg_to_esec_hash_type(uint16_t hash_alg);
int pke_pad_type_to_esec_pad_type(uint16_t pad_type);
int fun_crypto_ec_curve_type(int curve_id);
void *crypto_rsa_alloc_key_blob(uint32_t key_size, bool is_crt);
void crypto_rsa_import_key_push(struct channel *channel, struct crypto_rsa_info *rsa_info, void *key_blob, uint8_t *auth_data, uint16_t mod_len, uint8_t *n, uint8_t *p, uint8_t *q, uint8_t *dp, uint8_t *dq, uint8_t *qinv);
void crypto_rsa_sign_push(struct channel *channel, struct crypto_rsa_sign_req *sign_req, void *key_blob, uint8_t *auth_data, uint16_t pad_type, uint32_t hash_type, uint8_t *hash, uint16_t salt_len, uint8_t *sig_out);
void crypto_rsa_verify_push(struct channel *channel, struct crypto_rsa_sign_req *verify_req, uint16_t pad_type, uint32_t hash_type, uint8_t *hash, uint16_t salt_len, uint16_t mod_len, uint8_t *n, uint16_t e_len, uint8_t *e, uint8_t *sig);
void crypto_rsa_encrypt_push(struct channel *channel, struct crypto_rsa_enc_req *enc_req, uint16_t hash_type, uint16_t pad_type, uint16_t mod_len, uint8_t *n, uint16_t e_len, uint8_t *e, uint8_t *in_pt, uint32_t in_pt_len, uint8_t *out_ct);
void crypto_rsa_decrypt_push(struct channel *channel, struct crypto_rsa_enc_req *dec_req, void *key_blob, uint8_t *auth_data, uint16_t hash_type, uint16_t pad_type, uint16_t mod_len, uint8_t *n, uint8_t *ct, uint8_t *pt, uint32_t *pt_len);
void *crypto_dsa_alloc_key_blob(int pg_len, int q_len);
void crypto_dsa_import_key_push(struct channel *channel, struct crypto_dsa_info *dsa_info, void *key_blob, uint8_t *auth_data, uint8_t *key);
void crypto_dsa_sign_push(struct channel *channel, struct crypto_dsa_req *sign_req, void *key_blob, uint8_t *auth_data, int digest_type, uint8_t *digest, int pglen, int qlen, uint8_t *p, uint8_t *q, uint8_t *g, uint8_t *sig_r, uint8_t *sig_s);
void crypto_dsa_verify_push(struct channel *channel, struct crypto_dsa_req *verify_req, int digest_type, uint8_t *digest, int pglen, int qlen, uint8_t *p, uint8_t *q, uint8_t *g, uint8_t *y, uint8_t *sig_r, uint8_t *sig_s);
void crypto_ecdsa_sign_push(struct channel *channel, struct crypto_ecdsa_req *sign_req, void *key_blob, uint8_t *auth_data, uint8_t *digest, uint32_t digest_len, uint8_t *sig_r, uint8_t *sig_s);
void crypto_ecdsa_verify_push(struct channel *channel, struct crypto_ecdsa_req *verify_req, int key_type, uint8_t *key_x, uint8_t *key_y, uint8_t *digest, uint32_t digest_len, uint8_t *sig_r, uint8_t *sig_s);
void crypto_eddsa_verify_push(struct channel *channel, uint8_t *pk, uint8_t *msg, int msg_len, uint8_t *sig, uint64_t *result);
void crypto_eddsa_sign_push(struct channel *channel, struct crypto_eddsa_req *sign_req, void *key_blob, uint8_t *auth_data, uint8_t *pk, uint8_t *msg, int msg_len, uint8_t *sig);
void crypto_free_pke_key(void *pke_key);

--------------

accelerators/erasure.h: 

enum ec_opmode {EC_GFM, EC_XOR, EC_MAXM};
enum ec_configs {EC_CFG_GFM, EC_CFG_XOR, EC_MAXFG};
enum ec_coeff_cache_policy {EC_COEFF_CACHE_ENCODE_ONCE, EC_COEFF_CACHE_ENCODE_ALWAYS, EC_COEFF_CACHE_ALWAYS, EC_COEFF_CACHE_MANUAL, EC_COEFF_CACHE_NEVER};
struct ec_parameters {uint8_t ndata; uint8_t nparity; uint8_t encode_type; uint8_t alpha; uint8_t beta; uint16_t poly; enum ec_coeff_cache_policy policy;};
struct ec_ll_parameters {enum ec_opmode mode; uint8_t ndata; uint8_t nparity; uint16_t coeffidx; uint8_t *coeff; uint8_t *data; uint8_t *parity; uint64_t coeffmap; uint16_t coefflen; uint16_t stridelen; bool track_issued_time; fun_time_t engine_issued_time;};
struct ec_matrix {bool coeff_loaded; bool cache_allocated; uint16_t coeffidx; uint64_t availmap; void *coeffs;};
struct ec_handle {struct ec_parameters params; enum fun_ret retcode; struct ec_matrix encode_m; struct fun_map *matrices; uint8_t *scratch;};
struct ec_operate {void *handle; uint8_t *data; uint8_t *parity; uint16_t stridelen; uint16_t coeffidx; bool keepinsram; bool track_issued_time; uint64_t availmap; struct ec_matrix *mat; enum fun_ret retcode; fun_time_t engine_issued_time; uint32_t nbytes; uint8_t **dptrs; uint8_t **pptrs;};
struct ec_operate_sw {uint32_t nbytes; bool partial; void *handle; void *rsvdptr; uint64_t availmap; uint8_t *dptrs[EC_MAXNDATA];uint8_t *pptrs[EC_MAXNPARITY];};
void ec_coeff_cache_free(uint16_t index, uint8_t count);
enum fun_ret ec_coeff_cache_alloc(uint8_t count, uint8_t align, uint16_t *indexp);
void ec_coeff_cache_init(void);
void ec_operate_push(struct channel *,struct ec_operate *);
void ec_operate_push_noflow(struct channel *,struct ec_operate *);
void ec_alloc_handle_push(struct channel *,void **handlep);
void ec_cfg_init_push(struct channel *,struct ec_parameters *,struct ec_handle *);
void ec_cfg_init_push_noflow(struct channel *,struct ec_parameters *,struct ec_handle *);
void ec_cfg_deinit_push(struct channel *,void *handlep);
struct ec_matrix *ec_get_matrix(struct ec_handle *,uint64_t match);
void ec_self_test_push(struct channel *);
void ec_bootstrap(cluster_t);
void erasure_operate_sw(struct ec_operate *);

--------------

accelerators/lookup_table.h: 

struct lookup_table;
typedef void *lookup_table_context_t;
typedef bool(*lookup_table_each_f)(lookup_table_context_t, uint8_t *key, uint64_t *value);
struct lookup_table_param {uint8_t table_size_log2; uint8_t key_size; uint8_t *mask; wuid_t fwd_miss_response; const char *name; bool per_cluster_table; uint8_t log_num_mgmt_vp; struct hw_le_tbl_def *parent;};
struct lookup_table_add_args {uint8_t *key; uint64_t value; bool replace_ok; int status; wuid_t fwd_response; faddr_t dest;};
struct lookup_table_delete_args {uint8_t *key; int status;};
struct lookup_table_enumerate_args {lookup_table_each_f each; lookup_table_context_t context; int status;};
struct lookup_table_lookup_args {uint8_t *key; uint64_t value; int status; faddr_t preferred_cluster; uint8_t n_tables; struct lookup_table *order[LOOKUP_TABLE_MULTI_MAX];wuid_t response_wu; uint64_t value_carry_fwd;};
void lookup_table_create_push(struct channel *,const struct lookup_table_param *,OUT struct lookup_table **);
struct hw_le_tbl_def *lookup_table_tbl_def_get(const struct lookup_table *);
uint8_t lookup_table_index(const struct lookup_table *);
size_t lookup_table_count(const struct lookup_table *);
size_t lookup_table_key_size(const struct lookup_table *);
size_t lookup_table_value_size(const struct lookup_table *);
void lookup_table_add_push(struct channel *,struct lookup_table *,INOUT struct lookup_table_add_args *);
void lookup_table_delete_push(struct channel *,struct lookup_table *,INOUT struct lookup_table_delete_args *);
void lookup_table_enumerate_push(struct channel *,struct lookup_table *,INOUT struct lookup_table_enumerate_args *);
void lookup_table_lookup_push(struct channel *,struct lookup_table *,INOUT struct lookup_table_lookup_args *);
void lookup_table_destroy_push(struct channel *,struct lookup_table **,OUT int *status);
void lookup_table_entry_clear_push(struct channel *,struct lookup_table **,OUT int *status);
void lookup_table_fwd_lookup_push(struct channel *,struct lookup_table *,INOUT struct lookup_table_lookup_args *);
void lookup_table_direct_lookup_push(struct channel *,struct lookup_table *,struct lookup_table_lookup_args *);
void lookup_table_direct_fwd_lookup_push(struct channel *,struct lookup_table *,struct lookup_table_lookup_args *);

--------------

accelerators/xform.h: 

struct xform {ALIGNED(FLOW_ALIGN_SIZE)struct flow xform_flow_connector; ALIGNED(FLOW_ALIGN_SIZE)struct flow xform_control_flow;};
struct xform_flow {ALIGNED(FLOW_ALIGN_SIZE)struct flow xform_flow; uint64_t xform_hu_pcie_cookie; uint16_t xform_type; union{struct fun_crypto_ctx crypto_ctx; struct hw_zip_ctx zip_ctx; struct hw_erasure_ctx erasure_ctx; struct hw_regex_ctx regex_ctx; };
};
static inline struct flow *xform_flow_connector(struct xform *xform)
 {return &xform->xform_flow_connector;}
static inline struct flow *xform_flow_to_flow(struct xform_flow *xform_f)
 {return &xform_f->xform_flow;}
static inline struct xform_flow *xform_flow_from_flow(struct flow *flow)
 {return(void *)flow;}
static inline struct flow *xform_control_flow(struct xform *xform)
 {return &xform->xform_control_flow;}
struct hu_fn_flow;
int xform_fini(struct xform *);
int xform_reset(void);
struct flow *xform_get_ctrl_flow(void);
void fun_xform_flow_alloc_push(struct channel *channel, uint8_t type, uint8_t alg, uint8_t mode, struct xform_flow **xform_f);
void fun_xform_flow_free_push(struct channel *channel, struct flow *);
int fun_xform_setkey(struct xform_flow *xform_f, uint8_t *key, uint16_t keylen);
struct fun_admin_xform_req *metaflow_admin_xform_alloca_req(struct channel *channel, struct metaflow *mf, unsigned int common_flags);
void metaflow_admin_xform_init_req_push(struct channel *channel, struct metaflow *mf, struct fun_admin_xform_req *xform_req, struct fun_xform_create_req *create_req);

--------------

accelerators/zip.h: 

typedef enum {ZIP_STATUS_SUCCESS =0, ZIP_STATUS_MEMORY_ERROR =1, ZIP_STATUS_COMMAND_ERROR =2, ZIP_STATUS_UNDERFLOW =3, ZIP_STATUS_OVERFLOW =4, ZIP_STATUS_ADDRESS_ERROR =5, ZIP_STATUS_INVALID_INPUT_ERROR =6, ZIP_STATUS_INTERNAL_ERROR =255, ZIP_STATUS_NOT_IMPLEMENTED_ERROR =256, ZIP_STATUS_INVALID_EFFORT_ERROR =257, ZIP_STATUS_INVALID_INPUT_LENGTH_ERROR =258, ZIP_STATUS_INVALID_OUTPUT_LENGTH_ERROR =259, ZIP_STATUS_INVALID_WRITE_POINTER_ERROR =260, ZIP_STATUS_WRITE_POINTER_IS_NOT_ALIGNED =261,}zip_status_t;
typedef enum {ZIP_EFFORT_64Gbps =0, ZIP_EFFORT_56Gbps =3, ZIP_EFFORT_30Gbps =4, ZIP_EFFORT_15Gbps =5, ZIP_EFFORT_7Gbps =8, ZIP_EFFORT_3Gbps =9, ZIP_EFFORT_2Gbps =15, ZIP_EFFORT_AUTO =16,}zip_effort_t;
typedef enum fun_zip_alg {ZIP_ALG_NONE =0, LZMA =1, LZMA_MULTI =2, DEFLATE =3, JPEG =4, FUN_NUM_ZIP_ALG}zip_alg_t;
typedef enum fun_zip_queue {ZIP_QUEUE_TEXT0 =0, ZIP_QUEUE_TEXT1 =1, ZIP_QUEUE_TEXT2 =2, ZIP_QUEUE_TEXT3 =3, ZIP_QUEUE_TEXT4 =4, ZIP_QUEUE_TEXT5 =5, ZIP_QUEUE_RSVD1 =6, ZIP_QUEUE_RSVD2 =7,}zip_queue_t;
typedef union {uint64_t u[8];struct{uint32_t checksum; uint32_t checksum_covered; uint32_t output_bits_written; uint32_t input_bits_read; uint32_t error; union{uint64_t context; struct{uint64_t rsvd0:22; uint64_t last_byte:7; uint64_t n_copy:16; uint64_t rsvd1:19;}__attribute__((__packed__))deflate; struct {uint64_t header_length:13; uint64_t header_offset:32; uint64_t rsvd:19;}__attribute__((__packed__))inflate; struct {uint64_t rsvd0:36; uint64_t n_64Blines:9; uint64_t rsvd1:19;}__attribute__((__packed__))lzma;};uint32_t unused[9];}__attribute__((__packed__));
}zip_result_t;
typedef struct {struct fun_ptr_and_size data; uint8_t n_3Bwords; uint8_t n_4Bwords; uint8_t n_5Bwords; uint8_t n_6Bwords; uint8_t n_7Bwords; uint8_t n_8Bwords; uint8_t n_9Bwords; uint8_t n_10Bwords;}zip_static_dictionary_config_t;
void zip_deflate_push(struct channel *,faddr_t where, zip_effort_t effort, void *in, uint32_t inlen, OUT void *out, uint32_t outlen, OUT zip_result_t *result
);
void zip_inflate_push(struct channel *,faddr_t where, void *in, uint32_t inlen, OUT void *out, uint32_t outlen, OUT zip_result_t *result
);
void zip_lzma_compress_push(struct channel *,faddr_t where, zip_effort_t effort, void *in, uint32_t inlen, OUT void *out, uint32_t outlen, INOUT void *context, OUT zip_result_t *result
);
void zip_lzma_compress_multiphase_push(struct channel *,faddr_t where, zip_effort_t effort, void *in, uint32_t inlen, OUT void *out, uint32_t outlen, INOUT void *context, OUT zip_result_t *result, OUT void *inter
);
void zip_lzma_decompress_push(struct channel *,faddr_t where, void *in, uint32_t inlen, OUT void *out, uint32_t outlen, INOUT void *context, OUT zip_result_t *result
);
void zip_lzma_compress_with_staticdict_push(struct channel *,faddr_t where, zip_effort_t effort, void *in, uint32_t inlen, OUT void *out, uint32_t outlen, zip_static_dictionary_config_t *sdcfg, INOUT void *context, OUT zip_result_t *result
);
void zip_lzma_decompress_with_staticdict_push(struct channel *,faddr_t where, void *in, uint32_t inlen, OUT void *out, uint32_t outlen, zip_static_dictionary_config_t *sdcfg, INOUT void *context, OUT zip_result_t *result
);
typedef struct fun_ptr_and_size zip_stream_buffer_t;
void zip_deflate_stream_push(struct channel *,faddr_t where, zip_effort_t effort, zip_stream_buffer_t *in, uint32_t inlen, OUT zip_stream_buffer_t *out, uint32_t outlen, NULLABLE zip_stream_buffer_t *preamble, uint32_t preamble_len, OUT zip_result_t *result, uint32_t flags, NULLABLE void *context, fun_time_t *ts
);
void zip_inflate_stream_push(struct channel *,faddr_t where, zip_stream_buffer_t *in, uint32_t inlen, OUT zip_stream_buffer_t *out, uint32_t outlen, NULLABLE zip_stream_buffer_t *preamble, uint32_t preamble_len, OUT zip_result_t *result, uint32_t flags, INOUT void *context, fun_time_t *ts
);
void zip_lzma_compress_stream_push(struct channel *,faddr_t where, zip_effort_t effort, zip_stream_buffer_t *in, uint32_t inlen, OUT zip_stream_buffer_t *out, uint32_t outlen, NULLABLE zip_stream_buffer_t *preamble, uint32_t preamble_len, OUT zip_result_t *result, uint32_t flags, INOUT void *context, fun_time_t *ts
);
void zip_lzma_compress_stream_multiphase_push(struct channel *,faddr_t where, zip_effort_t effort, zip_stream_buffer_t *in, uint32_t inlen, OUT zip_stream_buffer_t *out, uint32_t outlen, NULLABLE zip_stream_buffer_t *preamble, uint32_t preamble_len, OUT zip_result_t *result, uint32_t flags, INOUT void *context, fun_time_t *ts, void *inter, uint32_t interlen
);
void zip_lzma_decompress_stream_push(struct channel *,faddr_t where, zip_stream_buffer_t *in, uint32_t inlen, OUT zip_stream_buffer_t *out, uint32_t outlen, NULLABLE zip_stream_buffer_t *preamble, uint32_t preamble_len, OUT zip_result_t *result, uint32_t flags, INOUT void *context, fun_time_t *ts
);
zip_status_t zip_decode_deflate_status(zip_result_t *result);
zip_status_t zip_decode_inflate_status(zip_result_t *result);
zip_status_t zip_decode_lzma_compress_status(zip_result_t *result);
zip_status_t zip_decode_lzma_decompress_status(zip_result_t *result);
int zip_get_alg(const char *str);
void zip_install_props_bridge(void);

--------------

accelerators/zip_multi_buf.h: 

void
zip_multi_deflate_push(struct channel *channel, struct flow *flow, struct fun_ptr_and_size *in_arr, struct fun_ptr_and_size *out_arr, size_t *out_buf_capacity_arr, zip_result_t *zip_result_arr, uint16_t arr_size, zip_effort_t effort, uint16_t *status);
void zip_multi_inflate_push(struct channel *channel, struct flow *flow, struct fun_ptr_and_size *in_arr, struct fun_ptr_and_size *out_arr, size_t *out_buf_capacity_arr, zip_result_t *zip_result_arr, uint16_t arr_size, uint16_t *status);

--------------

flows/flow.h: 

typedef uint16_t flow_block_status_t;
struct channel;
void flow_init(OUT struct flow *flow, struct module *module, NULLABLE struct metaflow *metaflow, uint32_t identifier, faddr_t dest);
void flow_clone(OUT struct flow *flow, const struct flow *original);
void flow_init_for_all_vps(struct aligned_flow *flows, struct module *module, const char *name);
void flow_fini(struct flow *);
void flow_fini_wuh_fpush(struct flow *flow, struct frame **frame_ptr);
struct metaflow *flow_metaflow(const struct flow *);
bool flow_is_metaflow_default(const struct flow *);
struct module *flow_module(const struct flow *);
module_index_t flow_module_index(const struct flow *);
uint32_t flow_id(const struct flow *);
faddr_t flow_dest(const struct flow *);
faddr_t flow_dest_with_default(NULLABLE const struct flow *,faddr_t);
void flow_set_dest(struct flow *,faddr_t);
void flow_set_id(struct flow *,uint32_t);
enum flow_state flow_state(const struct flow *);
void flow_set_state(struct flow *,enum flow_state state);
void flow_set_debug_label(struct flow *,const char *label);
flow_block_status_t flow_block_status(const struct flow *);
bool flow_is_sw_blocked(const struct flow *);
bool flow_is_hw_blocked(const struct flow *);
uint32_t flow_blockedcnt(const struct flow *);
uint32_t flow_blockedcnt_sw(const struct flow *);
uint32_t flow_blockedcnt_hw(const struct flow *);
NULLABLE void *flow_user_context(const struct flow *);
void flow_set_user_context(struct flow *,NULLABLE void *);
void flow_set_dispatch_func(struct flow *,flow_dispatch_f);
void flow_set_bound_wuid_func(struct flow *,flow_bound_wuid_f);
uint64_t flow_pcie_cookie(const struct flow *);
void flow_yield_stats(const struct flow *,OUT uint64_t *average, OUT uint64_t *max, OUT uint64_t *count);
void flow_sw_block(struct flow *);
void flow_sw_unblock(struct flow *);
void flow_barrier_fpush(struct flow *,struct frame **);
bool flow_is_migrating(const struct flow *);
void flow_set_migrating(struct flow *);
void flow_clr_migrating(struct flow *);
void _flow_push_continuation(struct flow *caller_f, wuid_t wuid, struct frame **frame, struct flow *callee_f, uint64_t arg2);
void _flow_push_continuation64(struct flow *caller_f, wuid_t wuid, struct frame **frame, struct flow *callee_f, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6);
void _flow_send_continuation(struct flow *caller_f, struct frame *frame);
void _flow_send(struct flow *caller_f, wuid_t wuid, struct frame *,struct flow *callee_f, uint64_t arg2, bool gated);
bool flow_is_send_to_dest(struct flow *caller_f, struct flow *callee_f);
bool flow_callee_dest_fpush(struct flow *caller_f, struct frame **frame, struct flow *callee_f);
bool flow_callee_dest_available(struct flow *caller_f, struct flow *callee_f);
void flow_resched_req(struct flow *,rindex_t, unsigned int weight);
void flow_resched_req_via_wu(struct flow *);
void flow_callee_resched_restart_caller(struct flow *caller_f);
typedef void flow_process_push_f(struct channel *channel, struct flow *flow, void *arg2);
bool flow_process_if_not_blocked(struct frame *,struct flow *,void *arg2, uint64_t action, flow_process_push_f);
bool _flow_is_process_wu(const struct flow *);
void _flow_block_caller_wu(struct flow *,uint64_t action, struct frame *frame, uint64_t arg1, uint64_t arg2);
bool flow_is_replayed_wu(struct flow *);
void _flow_push_resume_wu(struct flow *,wuid_t wuid, faddr_t dest, struct frame *frame, uint64_t arg1, uint64_t arg2);
struct frame *flow_wustack_alloc(struct flow *f);
struct frame *flow_wustack_alloc_for_new_work(struct flow *f);
void flow_flush_fpush(struct flow *caller_f, struct frame **frame, struct flow *f);
void flow_flush_push(struct channel *,struct flow *);
void flow_flush_for_fini_fpush(struct flow *caller_f, struct frame **frame, struct flow *f);
void flow_flush_for_fini_push(struct channel *,struct flow *);
void flow_flush_all_push(struct channel *,struct flow *);
void flow_flush_all_fpush(struct flow *caller_f, struct frame **frame, struct flow *f);
void flow_flush_all_fini_fpush(struct flow *caller_f, struct frame **frame, struct flow *f);
void flow_restart_wu_set(struct flow *,wuid_t);
bool flow_should_restart_flow(struct flow **_f, uint64_t);
void flow_restart_flow_done(struct flow *);
void flow_restart_q_set(struct flow *,uint8_t queue);
bool flow_is_proper(const struct flow *);
enum syslog_severity;
void flow_syslog_log(const struct flow *,const char *message, enum syslog_severity);
FUN_DEPRECATED struct flow *flow_allocate_forever(struct module *module, const char *name, faddr_t dest)RETURN_ALIGNED(FLOW_ALIGN_SIZE);

--------------

flows/flow_binding.h: 

struct flow;
struct channel;
bool flow_is_bound(struct flow *f);
struct flow *flow_callee_flow(const struct flow *f);
faddr_t flow_callee_dest(const struct flow *f);
struct flow *flow_callee(struct flow *f, INOUT faddr_t *dest);
struct flow *flow_callee_dispatch(struct flow *f, void *request, faddr_t *dest, wuid_t *wuid);
int flow_bind(struct flow *f0, struct flow *f1);
void flow_bind_push(struct channel *,struct flow *f0, struct flow *f1);
void flow_bind_nflows(unsigned int nflows, struct flow *flows[]);
void flow_bind_nflows_push(struct channel *,unsigned int nflows, struct flow *flows[]);
void _flow_binding_bind(struct flow_binding *f_binding, struct flow *callee_f);
void _flow_binding_unbind(struct flow_binding *f_binding);
void flow_unbind(struct flow *f);
void flow_unbind_push(struct channel *,struct flow *f);
void flow_unbind_all_push(struct channel *,struct flow *f);
void flow_callee_push(struct flow *caller_f, struct frame **frame, void *op);
void flow_callee_send(struct flow *caller_f, struct frame *frame, void *op);
int _flow_bind(struct flow *f0, struct flow *f1);

--------------

flows/flow_internal.h: 

struct metaflow;
typedef struct flow *(*flow_dispatch_f)(struct flow *,void *request, OUT faddr_t *,OUT wuid_t *);
typedef wuid_t(*flow_bound_wuid_f)(const struct flow *caller, const struct flow *callee);
enum flow_state {FLOW_STATE_INIT =0, FLOW_STATE_CLOSED, FLOW_STATE_ESTABLISHED, FLOW_STATE_DESTROYED, FLOW_STATE_DESTROYING, FLOW_STATE_FLUSHING, FLOW_STATE_DROP, FLOW_STATE_ERROR, FLOW_STATE_LAST};
struct flow_binding {struct flow *fb_callee_flow; struct{flow_dispatch_f fb_callee_dispatch_func; faddr_t fb_callee_dest; wuid_t fb_callee_wuid;}fb_callee_cache;
};
enum flow_restart_q {FLOW_RESTART_LOW_PRIO =0, FLOW_RESTART_HI_PRIO =1};
struct flow_yield_stats {uint64_t yield_sum; uint64_t yield_max; uint64_t yield_cnt; fun_time_t yield_start;};
struct flow {uint32_t f_magic; uint32_t f_bindcnt; uint32_t f_blockedcnt; uint32_t f_id; faddr_t f_dest; module_index_t f_module_index; uint16_t f_dest_ridx; NULLABLE flow_dispatch_f f_dispatch_func; const char *f_debug_label; struct metaflow *f_metaflow; struct flow_monitor f_fm; void *f_context; union{struct{uint16_t f_state:4; uint16_t f_sw_block_opcnt:12;};uint16_t state_blob;};uint16_t f_flags; uint16_t f_callee_yieldcnt; rindex_t f_restart_rid_last; wuid_t f_restart_wu; uint16_t f_wsq_from_caller_wucnt; uint16_t f_wsq_to_callee_wucnt; uint32_t f_blockedcnt_sw; uint32_t f_blockedcnt_hw; TAILQ_HEAD(f_wsq_from_caller_head, frame_q)f_wsq_from_caller_head; TAILQ_HEAD(f_wsq_to_callee_head, frame_q)f_wsq_to_callee_head; struct flow_binding f_binding; NULLABLE flow_bound_wuid_f f_bound_wuid_func;
 struct flow_yield_stats f_yield_stats;
}ALIGNED(16);
static_assert_offset(struct flow, f_context, 64);
static_assert((sizeof(struct flow)&(16-1))==0,"flow structure must be a multiple of 16-bytes in size");
enum flow_op_flags {FLOW_OP_FLAG_BIND =1<<0, FLOW_OP_FLAG_FLUSH =1<<1, FLOW_OP_FLAG_UNBIND =1<<2, FLOW_OP_FLAG_FINI =1<<3, FLOW_OP_FLAG_PIPELINE =1<<31};
struct aligned_flow {ALIGNED(FLOW_ALIGN_SIZE)struct flow flow;};
struct frame_q *flow_wsq_from_caller_insert(struct flow *f, struct wu *wu);
struct frame *flow_from_caller_first(struct flow *f);
struct frame *flow_to_callee_first(struct flow *f);
void flow_dp_checks(struct flow *f, const char *file, int line, const char *function, struct module *,struct frame *frame);
void flow_dp_module_and_dest_checks(struct flow *f, const char *file, int line, const char *function, struct module *,struct frame *frame);
static inline unsigned int flow_wsq_from_caller_wucnt(struct flow *f)
 {return f->f_wsq_from_caller_wucnt;}
static inline unsigned int flow_wsq_to_callee_wucnt(struct flow *f)
 {return f->f_wsq_to_callee_wucnt;}
resource_level_t flow_restart_level_thresh(struct flow *f, bool new_work);
const char *flow_state_to_string(enum flow_state);
void flow_resched_via_timer_fini(struct flow *);
void flow_flag_timer_set(struct flow *);
void flow_flag_timer_clr(struct flow *);
unsigned int flow_flag_timer_chk(struct flow *);

--------------

flows/flow_monitor_internal.h: 

struct frame;
struct flow_monitor {uintptr_t opaque; struct frame *fm_to_callee_first;};

--------------

flows/res.h: 

struct flow;
enum res_consts {RES_NRES_MAX =5, RES_VP_WEIGHT_DEFAULT =4,};
typedef uint8_t res_weight_t;
void res_init(struct res *);
void res_check_wu_global(struct res *fr, uint8_t nwu);
void res_check_wu_hu(struct res *fr, unsigned int tile, uint8_t nwu);
void res_check_wu_nu(struct res *fr, uint8_t nwu);
void res_check_global_hu(struct res *fr, uint8_t nwu);
void res_check_wustack(struct res *fr, uint8_t nwustack);
void res_check_vp(struct res *fr, const faddr_t dest_vp, NULLABLE const wuid_t wuid);
void res_check_dma(struct res *fr, const faddr_t dest_dma, const size_t bytes);
void res_check_bam(struct res *fr, bam_pool_t, size_t bytes);
void res_check_bam_funos(struct res *fr, const size_t bytes);
void res_check_refbuf_16k(struct res *fr, uint8_t nrefbuf);
void res_check_refbuf_64k(struct res *fr, uint8_t nrefbuf);
void res_check_ocm_refbuf_big(struct res *fr, const unsigned int nrefbuf);
void res_check_ocm_refbuf(struct res *fr, ocm_pool_t ocm_pool, uint8_t nrefbuf);
void res_check_ridx(struct res *fr, rindex_t ridx, res_weight_t weight);
void res_weight_update(struct res *fr, uint32_t ridx, res_weight_t weight);
void res_initiate(struct res *fr);
void res_tmpl_prepare(struct res *fr);
void res_tmpl_update_ridx(struct res *fr, unsigned int idx, unsigned int ridx);
void res_tmpl_initiate(struct res *fr);
bool MUST_CHECK
flow_res_available_with_color(struct res *fr, struct flow *f, resource_level_t level, NULLABLE uint32_t res_stats[]);
bool MUST_CHECK
flow_res_available(struct res *fr, struct flow *f, bool new_work, NULLABLE uint32_t res_stats[]);
void flow_res_resched_req(struct res *fr, struct flow *f, uint32_t res_stats[],unsigned int res_idx);
struct frame *flow_res_ws_alloc(struct res *fr, struct flow *f);
void *flow_res_bam_alloc(struct res *fr, struct flow *f, bam_pool_t, const size_t bytes);
void *flow_res_bam_alloc_etp_cmdlist(struct res *fr, struct flow *f);
void *flow_res_bam_alloc_funos(struct res *,struct flow *,size_t);
void *flow_res_refbuf_16k_alloc(struct res *fr, struct flow *f);
void *flow_res_ocm_refbuf_alloc(struct res *fr, struct flow *f, ocm_pool_t pool);
void res_send_continuation(const struct res *fr, struct frame *frame);
bool res_can_send_N_wus(uint32_t nwus);

--------------

flows/res_internal.h: 

enum res_state {RES_STATE_IDLE, RES_STATE_INITIATE, RES_STATE_AVAILABLE, RES_STATE_NOTAVAILABLE,};
typedef struct res {uint16_t fr_ridx[RES_NRES_MAX];uint8_t fr_weight[RES_NRES_MAX];uint8_t fr_nres; uint64_t fr_req[2];uint64_t fr_mask; uint8_t fr_fsm; uint8_t rsvd0[7]; }res_t;
static_assert_sizeof(struct res, 48);
static_assert_sizeof(struct res, 40);
static inline void
res_entry_add(struct res *fr, unsigned int ridx, res_weight_t weight)
 {unsigned int idx =fr->fr_nres++;assert(idx <RES_NRES_MAX);fr->fr_ridx[idx]=ridx; fr->fr_weight[idx]=weight;}
static inline void
_res_entry_weight_update(struct res *fr, uint32_t ridx, res_weight_t weight)
 {assert(ridx <RES_NRES_MAX);fr->fr_weight[ridx]=weight;}
struct ridx_weight {unsigned int ridx; unsigned int weight;};
static inline struct ridx_weight
res_entry_get(const struct res *fr, unsigned int idx)
 {assert(idx <RES_NRES_MAX);return(struct ridx_weight){.ridx =fr->fr_ridx[idx],.weight =fr->fr_weight[idx],};
}

--------------

hw/common/platform_config.h: 

extern struct hwcap_cfg *hwcap_p;
const char *platform_get_sku_name(void);
const char *platform_get_sku_name_safe(void);
bool platform_config_setup(void);
bool platform_is_f1_dev_board(void);
int platform_get_chip_instance(void);
bool platform_has_i2c_dimm(void);
bool platform_has_dimm(void);
bool platform_has_retimer(void);
bool platform_has_atleast_2hus(void);
bool platform_has_12_drives(void);
bool platform_has_8_drives(void);
bool platform_emu_sn2(void);
bool platform_emu_stor2(void);
bool platform_emu_stor2full(void);
bool platform_emu_hu_lite(void);
bool platform_emu_stor_only(void);
bool platform_hu_full(void);
bool platform_sku_s1_switch(void);
bool platform_sku_unknown(void);
bool platform_sku_f1_posix(void);
bool platform_has_swup_fn(void);
bool platform_has_nvme_fn(void);
bool platform_has_pcie_vswitch_ports(void);
bool platform_cc_exists(void);
bool platform_has_sbp(void);
bool platform_has_nu_fpg(unsigned int num);
bool platform_dam_exists(void);
bool platform_nu_exists(void);
bool platform_rnic_exists(void);
bool platform_muh_exists(void);
bool platform_muh_has_128b_shards(void);
bool platform_mud_exists(void);
bool platform_mio_exists(void);
bool platform_cdu_exists(void);
bool platform_bnm_exists(void);
bool platform_emu_mem_exists(void);
uint64_t platform_emu_mem_size_mb(void);
bool platform_mmc_host_exists(void);
bool platform_pll_exists(void);
bool platform_nwqm_exists(void);
bool platform_has_hw_ocm(void);
bool platform_hnu_exists(void);
bool platform_cluster_is_pc(cluster_t);
bool platform_cluster_is_cc(cluster_t);
bool platform_hnu_slice_exists(unsigned int slice);
unsigned int platform_hnu_slice_count(void);
bool platform_hsu_exists(void);
bool platform_hsu_slice_exists(int slice);
unsigned int platform_hsu_tile_count(void);
unsigned int platform_hsu_slice_count(void);
unsigned int platform_hnu_slice_count(void);
bool platform_hsu_wants_128b_hbm_hash(unsigned int ring);
bool platform_hsu_tile_exists(unsigned int tile);
bool platform_nu_fpg_exists(uint8_t fpg_num);
static inline bool platform_hnu_enable(void)
 {return false;}
static inline bool platform_hbm_exists(void)
{if(!platform_muh_exists()){
 return true;
 return false;
 }return true;
}
static inline bool platform_has_serdes(void)
{
 return true;
 return false;
}
bool platform_cluster_exists(cluster_t);
bool platform_pc_exists(cluster_t);
bool platform_pc_core_exists(cluster_t, core_t);
bool platform_any_pc_exists(void);
uint32_t platform_pc_core_available_mask(cluster_t);
uint32_t platform_cluster_available_mask(void);
cluster_t platform_pc_count(void);
cluster_t platform_cluster_count(void);
void platform_init_is_qemu(void);
static inline bool platform_is_qemu(void)
{
 return true;
 return false;
}
static inline bool platform_is_posix(void)
{
 return true;
 return false;
}
static inline bool platform_has_hw_bm(void)
{
 return true;
 return false;
}
static inline bool platform_has_hw_cmh(void)
{
 return true;
 return false;
}
static inline bool platform_has_hw_dam(void)
{
 return !platform_is_qemu();
 return false;
}
static inline bool platform_has_hw_hbm_dam(void)
{
 return true;
 return false;
}
static inline bool platform_has_hw_dma(void)
{
 return true;
 return false;
}
static inline bool platform_has_hw_rid(void)
{
 return !platform_is_qemu();
 return false;
}
static inline bool platform_has_pcie_vswitch(void)
{
 return true;
 return false;
}
static inline bool platform_has_hw_timers(void)
{
 return !platform_is_qemu();
 return false;
}
static inline bool platform_has_crypto_chacha(void)
{
 return true;
 return false;
}
static inline bool platform_has_vpd_emu(void)
{
 return true;
 return false;
}
static inline bool platform_has_kscratch6_tracing(void)
{
 return true;
 return false;
}
struct board_info;
struct board_info *platform_get_board_info(void);
struct board_info_ext;
struct board_info_ext *platform_get_board_info_ext(void);
int platform_get_active_fw_part(void);
bool platform_full_hsu_exists(void);
bool platform_is_storage_workload(void);
bool platform_is_storage_and_networking_workload(void);
bool platform_is_storage_and_sdn_workload(void);
bool platform_is_networking_workload(void);
bool platform_is_vrouter_workload(void);
bool platform_is_si_bmv_split_workload(void);
bool platform_is_sdn_appliance_workload(void);
uint32_t platform_read_sku_id(void);
uint32_t platform_read_hw_rev(void);
bool platform_pri_mem_is_ddr(void);
bool platform_pri_mem_is_hbm(void);
uint64_t platform_read_hw_info_flags(void);
uint64_t platform_read_prng_seed(void);
const uint8_t*platform_read_serial_nr(void);
void platform_print_boot_blobs(void);
void *platform_get_chip_config(OUT size_t *size);
void *platform_find_boot_blob(uint32_t four_cc, size_t *size);
void *platform_last_blob_from_base(void *base, size_t max_gap);
void platform_print_version_info(const char *platform_str);
void platform_print_start_message(const char *platform_str);
const char *platform_get_chip_name(void);
const char *platform_get_serial_number(void);
void platform_set_serial_number(const uint8_t *sn);
uint8_t platform_pri_mem_region_count(void);
bool platform_pri_mem_region(uint8_t region_idx, uint64_t *start, uint64_t *size);
uint64_t platform_pri_mem_size_gb(void);
const char*platform_pri_mem_type(void);
uint64_t platform_hbm_size_gb(void);
uint64_t platform_ddr_size(void);
bool platform_hbm_or_ddr_exists(void);
uint64_t platform_pri_mem_boot_region_size(void);
uint64_t platform_pri_mem_boot_region_start(void);
void platform_print_pri_mem_info(void);
bool platform_wiq_exists(struct csr2wiq_access *wiq);
bool platform_has_hw_pfm(void);
bool platform_has_hw_acu(void);
uint32_t platform_uart_clk_div(uint32_t id);

--------------

hw/dam/dam.h: 

ENUM_DEF(dam_pool_t);
ENUM_DEF(dam_pool_t);
static_assert(DAM_POOL_STRESS_LAST >=DAM_POOL_STRESS_FIRST,"Invalid staress test pool order!");
static_assert(DAM_POOL_STRESS_LAST <DAM_POOL_WUSTACK,"Invalid staress test pools!");
ENUM_DEF(dam_pool_t);
int dam_alloc_sync(dam_pool_t pool, uint8_t initval);
void dam_alloc_multiple_sync(uint8_t poolvec, uint8_t req_count, uint8_t initval, OUT uint8_t *rsp_count, OUT uint8_t *pool, OUT uint16_t index_array[11]);
void dam_dec_ref_async(dam_pool_t pool, uint32_t index, uint8_t amount);
void dam_wustack_free(uint32_t index);
void dam_inc_ref_async(dam_pool_t pool, uint32_t index, uint8_t amount);
void dam_prepare_dec_ref(dam_pool_t pool, uint32_t index, uint8_t amount, uint64_t msg[2]);
void dam_prepare_inc_ref(dam_pool_t pool, uint32_t index, uint8_t amount, uint64_t msg[2]);
void dam_init(void);
void dam_per_cluster_init(void);
void dam_pool_prefetcher_init(dam_pool_t pool, uint8_t refcnt);
void dam_print_usage(void);
void dam_pool_usage(dam_pool_t pool, OUT uint64_t *in_use, OUT uint64_t *in_pfm, OUT uint64_t *pool_size);
void dam_init_pool(dam_pool_t pool, size_t page_size, size_t pool_size_indices, NULLABLE void *mem_start);
void dam_pool_range_fiu_config(void);
size_t dam_pool_size_get(dam_pool_t pool);
void *dam_pool_mem_start(dam_pool_t pool);
uint32_t dam_query_free_count(dam_pool_t pool);
uint8_t dam_query_pool_color(dam_pool_t pool);
uint8_t dam_get_ref_count(dam_pool_t pool, uint32_t index);
size_t dam_ncv_thr_for_level(dam_pool_t pool, uint8_t level);
size_t dam_ncv_usage_thr_for_level(dam_pool_t pool, uint8_t level);
size_t dam_ncv_thr_read(dam_pool_t pool, uint8_t level);
size_t dam_ncv_margin_get(dam_pool_t pool);
void dam_ncv_config(void);
size_t dam_pool_green_alloc_limit(dam_pool_t pool);
size_t dam_pool_prefetched_indices_count(dam_pool_t pool);
size_t dam_pool_indices_used(dam_pool_t pool);
void dam_stats_dump_all(void);
bool dam_init_done_check(void);
bool dam_has_shared_ncv_profiles(void);
uint8_t dam_res_color_to_ncv(resource_level_t color);

--------------

hw/dmae/dma_crc.h: 

struct fun_dma_handle;
struct dma_operate_crc_info {uint16_t len; uint16_t stop_off; uint16_t start_off; uint16_t stride; uint64_t seed; uint64_t poly; enum crc_flags_type type; bool use_seed; bool pi; bool chk_cpy;};
enum crc_flags {CRC_FLAGS_CHECK =0,};
FIELD_PUT_GET(DMA_O_CRC_FLAG_TYPE_S, DMA_O_CRC_FLAG_TYPE_M, DMA_O_CRC_FLAG_TYPE_G, DMA_O_CRC_FLAG_TYPE_P);
FIELD_PUT_GET(DMA_O_CRC_FLAG_CHK_CPY_S, DMA_O_CRC_FLAG_CHK_CPY_M, DMA_O_CRC_FLAG_CHK_CPY_G, DMA_O_CRC_FLAG_CHK_CPY_P);
FIELD_PUT_GET(DMA_O_CRC_FLAG_SEED_S, DMA_O_CRC_FLAG_SEED_M, DMA_O_CRC_FLAG_SEED_G, DMA_O_CRC_FLAG_SEED_P);
FIELD_PUT_GET(DMA_O_CRC_FLAG_PI_S, DMA_O_CRC_FLAG_PI_M, DMA_O_CRC_FLAG_PI_G, DMA_O_CRC_FLAG_PI_P);
FIELD_PUT_GET(DMA_O_CRC_START_OFF_S, DMA_O_CRC_START_OFF_M, DMA_O_CRC_START_OFF_G, DMA_O_CRC_START_OFF_P);
FIELD_PUT_GET(DMA_O_CRC_STOP_OFF_S, DMA_O_CRC_STOP_OFF_M, DMA_O_CRC_STOP_OFF_G, DMA_O_CRC_STOP_OFF_P);
FIELD_PUT_GET(DMA_O_CRC_T10_STRIDE_S, DMA_O_CRC_T10_STRIDE_M, DMA_O_CRC_T10_STRIDE_G, DMA_O_CRC_T10_STRIDE_P);
FIELD_PUT_GET(DMA_O_CRC_T10_SEED_S, DMA_O_CRC_T10_SEED_M, DMA_O_CRC_T10_SEED_G, DMA_O_CRC_T10_SEED_P);
void dma_crc_print_info(const char *str, struct dma_operate_crc_info *crc_info);
const char *dma_crc_get_type_str(enum crc_flags_type type);
uint8_t dma_crc_get_crc_size(enum crc_flags_type);
uint8_t dma_crc_get_size(enum crc_flags_type type);
uint64_t dma_crc_get_crc64_poly(void);
void dma_crc_set_crc64_poly(uint64_t poly);
void _fun_dma_set_op_crc(struct fun_dma_handle *handle, uint16_t len, enum crc_flags_type type, bool check, int pipe, bool use_seed, uint64_t seed);
void _fun_dma_set_op_crc16(struct fun_dma_handle *handle, uint16_t len, uint16_t stride, bool check, bool pi, int pipe, bool use_seed, uint64_t seed);
void _fun_dma_set_operate_crc(struct fun_dma_handle *handle, struct dma_operate_crc_info *crc_info, int pipe);
void fun_dma_set_operate_crc(struct fun_dma_handle *handle, struct dma_operate_crc_info *crc_info);
void fun_dma_set_op_crc(struct fun_dma_handle *handle, uint16_t len, enum crc_flags_type type, bool check, bool use_seed, uint64_t seed);
void fun_dma_set_op_crc16(struct fun_dma_handle *handle, uint16_t len, uint16_t stride, bool check, bool pi, bool use_seed, uint64_t seed);
void fun_dma_set_operate_crc_unordered(struct fun_dma_handle *handle, struct dma_operate_crc_info *crc_info);
void fun_dma_set_operate_crc_prio(struct fun_dma_handle *handle, struct dma_operate_crc_info *crc_info);
void dma_crc_set_info(struct dma_operate_crc_info *crc_info, uint16_t start, uint16_t len, enum crc_flags_type type, bool check);
enum crc_flags_type dma_crc_str_to_val(const char *opt_str);

--------------

hw/dmae/dma_crc_types.h: 

enum crc_flags_type {crc_flags_type_copy =0, crc_flags_type_tcp_ip_csum =1, crc_flags_type_udp_ip_csum =2, crc_flags_type_rsvd1 =3, crc_flags_type_crc32 =4, crc_flags_type_crc32c =5, crc_flags_type_crc16_t10 =6, crc_flags_type_crc64 =7, crc_flags_type_max =8};

--------------

hw/dmae/hw_dmae_op.h: 

enum hw_dmae_operators {HW_DMAE_OPERATOR_AES, HW_DMAE_OPERATOR_SHA, HW_DMAE_OPERATOR_EC, HW_DMAE_OPERATOR_CRC, HW_DMAE_OPERATOR_MAX};
static inline uint8_t
hw_dmae_pipe_to_operator(uint8_t pipe)
{static const uint8_t pipe_operator_map[]={[0]=HW_DMAE_OPERATOR_AES,[1]=HW_DMAE_OPERATOR_AES,[2]=HW_DMAE_OPERATOR_AES,[3]=HW_DMAE_OPERATOR_AES,[4]=HW_DMAE_OPERATOR_SHA,[5]=HW_DMAE_OPERATOR_SHA,[6]=HW_DMAE_OPERATOR_SHA,[7]=HW_DMAE_OPERATOR_SHA,[8]=HW_DMAE_OPERATOR_SHA,[9]=HW_DMAE_OPERATOR_SHA,[10]=HW_DMAE_OPERATOR_EC,[11]=HW_DMAE_OPERATOR_CRC,[12]=HW_DMAE_OPERATOR_CRC,[13]=HW_DMAE_OPERATOR_CRC,};if(pipe >=ARRAY_SIZE(pipe_operator_map)){fprintf(stderr,"%s:%d invalid pipe number %d\n",__func__, __LINE__, pipe);BUG();}return pipe_operator_map[pipe];
}
static inline uint8_t
hw_dmae_operator_pipe_offset(uint8_t oper_type)
{static const uint8_t pipe_start_map[]={[HW_DMAE_OPERATOR_AES]=0,[HW_DMAE_OPERATOR_SHA]=4,[HW_DMAE_OPERATOR_EC]=10,[HW_DMAE_OPERATOR_CRC]=11,};if(oper_type >=HW_DMAE_OPERATOR_MAX){BUG();}return pipe_start_map[oper_type];
}
struct dmae_oper_sim_obj {enum hw_dmae_operators type; int oper_pipe; uint64_t handle; int(*operator_exec)(uint64_t handle, void *in, uint32_t data_len, uint32_t md_len, void *out, uint32_t *out_len);};
void hw_dmae_oper_setup_fn_handler(enum hw_dmae_operators type, int instance);
int hw_dmae_oper_exec_fn_handler(enum hw_dmae_operators type, int instance, void *in, uint32_t data_len, uint32_t md_len, void *out, uint32_t *out_len);
int crypto_hw_aes_engine_run(uint8_t *ififo, uint16_t ififo_len, uint8_t *ofifo, uint16_t *ofifo_len, void *crypto_args, uint16_t crypto_len);
int crypto_hw_sha_engine_run(uint8_t *ififo, uint16_t ififo_len, uint8_t *ofifo, uint16_t *ofifo_len, void *crypto_args, uint16_t crypto_len);

--------------

hw/dmae/hw_dmae_sim.h: 

enum hw_dmae_sim_type {HW_DMAE_SIM_TYPE_HU_IOCMD, HW_DMAE_SIM_TYPE_HU_MEM, HW_DMAE_SIM_TYPE_NU_SINGLE_BUF, HW_DMAE_SIM_TYPE_NU_CMDLIST,};
void hw_dmae_sim_bam_free(struct frame **frame);
bool hw_dmae_sim_free_bm_after_use(uint8_t flag);

--------------

hw/hsu/hu_dma_type.h: 

enum hw_dmae_hdma_type {HW_DMAE_HDMA_RD =0, HW_DMAE_HDMA_WR, HW_DMAE_HDMA_HIGH_PRIO, HW_DMAE_HDMA_IOP, HW_DMAE_HDMA_TYPE_MAX,};

--------------

hw/le/hw_le.h: 

struct lut;
struct lu_tbls {uint8_t n_tbls; struct lut *lut[HW_LE_MAX_TBL_PER_LKUP];};
typedef bool(*hw_le_enum_f)(void *context, uint8_t *key, uint64_t *value);
struct hw_le_args {uint8_t *key; uint32_t rsp_opcode; uint8_t rsp_q; uint8_t flags; union hw_le_frame *key_frm; faddr_t dest; uint64_t opaque0; uint64_t opaque1; uint64_t scratch_pad; uint64_t *result; int *status; struct frame *frame; struct lut *lut;};
struct hw_le_enum_args {void *context; hw_le_enum_f func; int *ret_status;};
struct hw_le_key_data;
typedef void(hw_le_test_f)(void);
typedef uint64_t(hw_le_test_measure_f)(void);
typedef void(hw_le_cb_f)(struct lut *,struct hw_le_key_data *);
struct hw_le_key_data {uint8_t tmp[HW_LE_FULL_KEY_SZ];uint8_t mask[HW_LE_FULL_KEY_SZ];uint8_t rsv[HW_LE_REQ_HDR_SZ];uint8_t key[HW_LE_REQ_IND_KEY_SZ];uint64_t data[HW_LE_RSP_VALUE_SZ];bool replace_ok; bool free_after_used; bool trace_enabled; bool flush_on_replace; faddr_t fwd_dest; wuid_t fwd_wuid; struct{bool limit_flush; uint8_t ref_cluster_mask; uint16_t ref_q_mask;}flush_data ;hw_le_cb_f *callback; void *ctx; uint8_t cluster_idx; int ret_status; int *ext_ret; uint32_t hash; uint32_t bkt; uint16_t fp;
}__attribute__((aligned(16)));
struct hw_le_tbl_def {const char *name; bool per_cluster_tbl; uint8_t num_clusters; uint8_t clusters[HW_LE_NUM_CLUSTERS];uint8_t tbl_sz; size_t key_size; size_t data_size; uint8_t ht_dram; uint8_t fp_dram; uint8_t ht_coherent; uint8_t fp_coherent; uint64_t nibble_enb[HW_LE_NIBBLE_ENB_SZ];uint16_t bitmask[HW_LE_BITMASK_OFS_SZ];uint8_t offset[HW_LE_BITMASK_OFS_SZ];uint8_t tcam; faddr_t fwd_miss_vp; uint8_t ext_miss_lid[HW_LE_X_LID_SZ];uint32_t default_opcode; void *ht_ptr; void *fp_ptr; struct hw_le_tbl_def *parent; uint32_t ref_count; struct workerpool *parent_mgmt_vp; uint8_t log_num_mgmt_vp; struct workerpool *wp_src; wuid_t miss_n_add_wuid; uint64_t miss_n_add_tbl_sz; uint64_t miss_n_add_nibble_enb[HW_LE_NIBBLE_ENB_SZ];uint16_t miss_n_add_bitmask[HW_LE_BITMASK_OFS_SZ];uint8_t miss_n_add_offset[HW_LE_BITMASK_OFS_SZ];faddr_t(*miss_n_add_wp_get)(uint32_t);struct lut *my_lut;};
enum hw_le_lku_type {HW_LE_DIR_LAS, HW_LE_IND_LAS, HW_LE_DIR_FWD, HW_LE_DIR_FWD_MISS, HW_LE_IND_FWD, HW_LE_IND_FWD_MISS, HW_LE_NUL_LKU, HW_LE_LKUP_MAX,};
ENUM_DEF(le_mgmt_cnts_t);
ENUM_DEF(le_table_cnts_t);
void lookup_engine_module_init(void);
void hw_le_enable(cluster_t, bool enable);
faddr_t hw_le_global_mgmt_vp(void);
bool hw_le_enumerate(struct lut *,void *context, hw_le_enum_f);
bool hw_le_cluster_has_le(cluster_t);
bool hw_le_chip_has_le(void);
uint8_t hw_le_key_size(struct lut *lut);
uint8_t hw_le_data_size(struct lut *lut);
int8_t hw_le_phy_tbl_id(struct lut *lut);
uint16_t hw_le_lgl_tbl_id(struct lut *lut);
bool hw_le_lut_valid(struct lut *lut);
bool hw_le_lut_is_tcam(struct lut *lut);
bool hw_le_lut_is_per_cluster_tbl(struct lut *lut);
uint8_t hw_le_lut_num_clusters(struct lut *lut);
uint64_t hw_le_lut_entry_used(struct lut *lut);
uint64_t hw_le_lut_null_rsp_cnt(struct lut *lut);
uint32_t hw_le_lut_bucket_sz(struct lut *lut);
uint32_t hw_le_lut_entry_max(struct lut *lut);
uint64_t hw_le_lut_hit_cnt(struct lut *lut);
uint64_t hw_le_lut_miss_cnt(struct lut *lut);
uint64_t hw_le_lut_clear_cnt(struct lut *lut);
uint64_t hw_le_lut_err_cnt_del(struct lut *lut);
uint64_t hw_le_lut_entry_used(struct lut *lut);
uint8_t hw_le_lut_utilization(struct lut *lut);
uint8_t hw_le_rsp_hit(void *wu);
uint64_t hw_le_logical_tbl_cnt(void);
struct lut *hw_le_get_lut(uint8_t idx);
struct lut *hw_le_get_mna_lut(struct lut *lut);
uint64_t hw_le_las_rsp_cnt(void);
uint64_t hw_le_hit_cnt(void);
uint64_t hw_le_miss_cnt(void);
uint64_t hw_le_null_cnt(void);
uint64_t hw_le_flush_rsp_cnt(void);
uint64_t hw_le_err_tbl_alloc_cnt(void);
uint64_t hw_le_err_tbl_dealloc_cnt(void);
uint64_t hw_le_err_tbl_dealloc_cluster(void);
uint64_t hw_le_entry_add_cnt(struct lut *);
uint64_t hw_le_entry_del_cnt(struct lut *);
uint64_t hw_le_err_add_space_cnt(struct lut *);
uint64_t hw_le_err_add_dup_cnt(struct lut *);
uint64_t hw_le_err_add_cnt(struct lut *);
uint64_t hw_le_err_del_cnt(struct lut *);
uint64_t hw_le_cmh_egress_cnt(cluster_t);
void hw_le_cmh_egress_cnt_clear(cluster_t);
uint64_t hw_le_wu_cnt(cluster_t);
void hw_le_wu_cnt_clear(cluster_t);
size_t hw_le_mgmt_vp_cnt(struct lut *lut);
faddr_t hw_le_mgmt_vp(struct lut *lut);
faddr_t hw_le_mgmt_vp_get(struct lut *lut, uint32_t pick);
faddr_t hw_le_mgmt_vp_pick(struct lut *lut, struct hw_le_key_data *kd);
faddr_t hw_le_mgmt_vp_get_any(struct lut *lut);
void hw_le_mgmt_perf_measure_set_idx(uint32_t idx);
uint32_t hw_le_perf_idx(struct hw_le_tbl_def *td);
struct workerpool *hw_le_workerpool(struct lut *lut);
uint32_t hw_le_wp_count(struct lut *lut);
faddr_t hw_le_wp_get(struct lut *lut, uint32_t i);
faddr_t hw_le_wp_get_any(struct lut *lut);
void hw_le_req_wu_create_dir_las(uint8_t num_lkups, uint8_t *order, struct lut *lut[],uint8_t flags, uint8_t *key, uint8_t rspq, uint32_t rsp_opcode, faddr_t dest, struct wu *wu);
void hw_le_req_wu_create_ind_las(uint8_t num_lkups, uint8_t *order, struct lut *lut[],uint8_t flags, uint8_t *key, uint32_t rsp_opcode, void *key_frm, void *key_frm_arg0, faddr_t dest, struct wu *wu);
void hw_le_req_wu_create_dir_fwd(uint8_t num_lkups, uint8_t *order, struct lut *lut[],uint8_t flags, uint8_t *key, faddr_t dest, struct wu *wu);
void hw_le_req_wu_create_ind_fwd(uint8_t num_lkups, uint8_t *order, struct lut *lut[],uint8_t flags, uint8_t *key, void *key_frm, uint64_t opaque0, uint64_t opaque1, faddr_t dest, struct wu *wu);
void hw_le_req_wu_create_null(uint8_t rspq, uint32_t rsp_opcode, uint64_t opaque0, uint64_t opaque1, faddr_t dest, struct wu *wu);
void hw_le_perf_measure(enum hw_le_lku_type ty);
int hw_le_ht_entry_soft_lookup(struct lut *lut, struct hw_le_key_data *kd, uint32_t bucket, uint16_t fp, int *index, uint32_t *empty_bitmap);
int hw_le_ht_entry_soft_lookup_data_fn(struct lut *lut, struct hw_le_key_data *kd, OUT uint64_t *data0, OUT uint64_t *data1);
void hw_le_print_lut(struct lut *lut);
void hw_le_print_lut_summary(struct lut *lut);
void hw_le_print_all_lut(void);
void hw_le_print_all_lut_summary(void);
void hw_le_print_config_table(cluster_t, uint32_t tid, struct lut *lut);
void hw_le_print_fingerprint(cluster_t, uint32_t tid);
void hw_le_print_all_fingerprint(void);
void hw_le_print_hashtable(cluster_t, uint32_t tid);
void hw_le_print_all_hashtable(void);
void hw_le_print_wu(void *wu);
void hw_le_print_frame_las(union hw_le_frame *fr);
void hw_le_print_frame_fwd(union hw_le_frame *fr);
void hw_le_print_req(void *wu);
void hw_le_print_rsp(uint8_t type, void *wu);
void hw_le_print_key(void *key, size_t sz);
void hw_le_print_used_mask(void);
int hw_le_print_performance(char *);
int hw_le_print_mgmt(char *);
void hw_le_print_teramark(void);
void hw_le_print_tbl_def(struct hw_le_tbl_def *td);
void hw_le_print_wu_struct(struct wu *wu);
int hw_le_print_hw_status(cluster_t, const char *buf);
int hw_le_print_cntr(cluster_t, const char *buf);
int hw_le_print_all_reg(cluster_t, const char *buf);
void hw_le_print_args(struct hw_le_args *);
void hw_le_print_key_data(struct hw_le_key_data *);
void hw_le_print_tcam(cluster_t);
void hw_le_print_u64(const char *,uint64_t *,size_t);
void hw_le_print_all_cntr(char *dst);
void hw_le_print_debug(struct lut *lut, struct hw_le_key_data *kd);
uint32_t hw_le_get_hash(uint64_t seed, uint8_t *buf, uint16_t *fp);
void hw_le_msk_n_hash(struct lut *lut, uint8_t *key, uint8_t *key_buf, uint32_t *hash, uint32_t *bkt, uint16_t *fp);
void hw_le_msk_n_hash_pure(struct lut *lut, uint8_t *key, uint8_t *key_buf, uint32_t *hash, uint32_t *bkt, uint16_t *fp);
struct channel;
struct flow;
void hw_le_tbl_alloc_push(struct channel *channel, struct hw_le_tbl_def *td, struct lut **lut);
void hw_le_tbl_dealloc_push(struct channel *channel, struct lut *lut, int *status);
void hw_le_flw_entry_add_push(struct channel *channel, struct flow *f, struct lut *lut, struct hw_le_key_data *kd);
void hw_le_entry_del_push(struct channel *channel, struct lut *lut, struct hw_le_key_data *kd);
void hw_le_lookaside_push(struct channel *channel, struct lu_tbls *lt, struct hw_le_args *args);
void hw_le_dir_lookaside_push(struct channel *channel, struct lu_tbls *lt, struct hw_le_args *args);
void hw_le_forwarding_push(struct channel *channel, struct lu_tbls *lt, struct hw_le_args *args);
void hw_le_dir_forwarding_push(struct channel *channel, struct lu_tbls *lt, struct hw_le_args *args);
void hw_le_enumerate_push(struct channel *channel, struct lut *lut, struct hw_le_enum_args *args);
void hw_le_enumerate_del_push(struct channel *channel, struct lut *lut, struct hw_le_enum_args *args);
void hw_le_inline_entry_add(struct lut *lut, struct hw_le_key_data *kd);
void hw_le_inline_entry_del(struct lut *lut, struct hw_le_key_data *kd);
void hw_le_send_inline_entry_add(struct lut *lut, struct hw_le_key_data *kd);
void hw_le_send_inline_entry_del(struct lut *lut, struct hw_le_key_data *kd);
void hw_le_vplocal_mgmt_stats(void);
void hw_le_vplocal_table_stats(uint8_t ltid);
void hw_le_hit_inc(struct lut *);
void hw_le_miss_inc(struct lut *);
CALLER_TO_RELEASE struct fun_json *hw_le_json_mgmt(void *);
CALLER_TO_RELEASE struct fun_json *hw_le_json_all_lut(void *);
CALLER_TO_RELEASE struct fun_json *hw_le_json_all_counters(void *);
struct hw_le_tbl_def *hw_le_tbl_def_get(struct lut *lut);
void hw_le_set_tcam_test_mode(int mode);
uint8_t hw_le_get_table_used_mask(int index);
void hw_le_set_table_used_mask(int index, uint8_t mask);
hw_le_fingerprint_t *hw_le_ft_get(struct lut *lut);
void *hw_le_sdn_get_key_by_index(struct lut *lut, uint32_t le_index);

--------------

hw/le/hw_le_def.h: 

union hw_le_frame {struct{struct wu wu; uint8_t key[HW_LE_FRAME_KEY_SZ];}las; struct {uint8_t n2p[HW_LE_N2P_HDR_SZ];uint8_t key[HW_LE_N2P_KEY_SZ];}fwd; struct {uint64_t args[HW_LE_FRAME_SZ];}u64;
}__attribute__((aligned(64)));
_Static_assert((HW_LE_FULL_KEY_SZ %sizeof(v16u8))==0,"HW_LE_FULL_KEY_SZ is not an integral number of v16u8's");
_Static_assert((HW_LE_FULL_KEY_SZ %sizeof(uint64_t))==0,"HW_LE_FULL_KEY_SZ is not an integral number of uint64_t's");
typedef uint16_t hw_le_fingerprint_t;
union hw_le_key_buf {uint8_t bytes[HW_LE_FULL_KEY_SZ];uint64_t dwords[HW_LE_FULL_KEY_SZ /sizeof(uint64_t)]; v16u8 qwords[HW_LE_FULL_KEY_SZ /sizeof(v16u8)]; };

--------------

hw/le/hw_le_threaded.h: 

WU_THREADED void hw_le_tbl_alloc_threaded(struct hw_le_tbl_def *td, struct lut **lut);
WU_THREADED int hw_le_tbl_clear_threaded(struct lut *lut);
WU_THREADED int hw_le_tbl_dealloc_threaded(struct lut *lut);
WU_THREADED int hw_le_entry_add_threaded(struct lut *lut, struct hw_le_key_data *kd);
WU_THREADED int hw_le_entry_add_special_threaded(struct lut *lut, struct hw_le_key_data *kd);
WU_THREADED int hw_le_entry_del_threaded(struct lut *lut, struct hw_le_key_data *kd);
WU_THREADED int hw_le_entry_del_special_threaded(struct lut *lut, struct hw_le_key_data *kd);
WU_THREADED int hw_le_lookaside_threaded(struct lu_tbls *lt, uint8_t *key, union hw_le_frame *key_frame, bool key_frame_in_mem, uint8_t wu_queue, uint64_t *ret_value);
WU_THREADED void hw_le_dir_lookaside_threaded(struct lu_tbls *lt, uint8_t *key, uint8_t wu_queue, wuid_t rsp_base_wu, uint64_t *ret_value);
WU_THREADED void hw_le_null_threaded(struct lu_tbls *lt, uint8_t wu_queue, uint64_t opaque0, uint64_t opaque1);
WU_THREADED int hw_le_forwarding_threaded(struct lu_tbls *lt, uint8_t *key, union hw_le_frame *key_frame, bool key_frame_in_mem, uint8_t wu_queue, uint64_t *ret_value);
WU_THREADED void hw_le_dir_forwarding_threaded(struct lu_tbls *lt, uint8_t *key, uint8_t wu_queue, uint64_t *ret_value);

--------------

hw/ocm/ocm.h: 

ENUM_DEF(ocm_pool_t);
void ocm_init(void);
void *ocm_refbuf_alloc_4k(void);
void *ocm_refbuf_alloc_8k(void);
void *ocm_refbuf_alloc_big(void);
static inline void *ocm_refbuf_alloc(ocm_pool_t pool)
{if(pool ==OCM_POOL_REFBUF_4K){return ocm_refbuf_alloc_4k();}else if(pool ==OCM_POOL_REFBUF_8K){return ocm_refbuf_alloc_8k();}else if(pool ==OCM_POOL_REFBUF_BIG){return ocm_refbuf_alloc_big();}else{BUG();}
}
void ocm_refbuf_dec(void *refbuf, uint8_t amount);
void ocm_refbuf_inc(void *refbuf, uint8_t amount);
void ocm_refbuf_4k_dec(void *refbuf, uint8_t amount);
void ocm_refbuf_8k_dec(void *refbuf, uint8_t amount);
void ocm_refbuf_big_dec(void *refbuf, uint8_t amount);
void ocm_buf_dec_by_one(ocm_pool_t pool, uint16_t index);
void ocm_refbuf_free(void *refbuf);
size_t ocm_pool_free_page_count(ocm_pool_t pool);
size_t ocm_pool_free_refbuf_count(ocm_pool_t pool);
ocm_pool_t ocm_refbuf_to_pool(void *refbuf);
vaddr_t ocm_pool_start_virtual_address(ocm_pool_t pool);
paddr_t ocm_pool_start_phy_address(ocm_pool_t pool);
size_t ocm_pool_size(ocm_pool_t pool);
size_t ocm_pool_page_size(ocm_pool_t pool);
size_t ocm_refbuf_big_page_size(void);
size_t ocm_pool_num_pages(ocm_pool_t pool);
bool ocm_pool_dam_enabled(ocm_pool_t pool);
bool ocm_pool_pfm_enabled(ocm_pool_t pool);
unsigned int ocm_pool_pfm_id(ocm_pool_t pool);
uint8_t ocm_pool_to_dam_pool_id(ocm_pool_t pool);
uint16_t ocm_pool_buf_to_index(ocm_pool_t pool, void *refbuf);
bool ocm_refbuf_addr_valid(ocm_pool_t pool, void *ptr);
void ocm_refbuf_free(void *refbuf);
void ocm_pool_refbuf_free(ocm_pool_t pool, void *refbuf);
bool ocm_refbuf_cachable(ocm_pool_t pool);
size_t ocm_refbuf_max_cachable_size(ocm_pool_t pool);
void ocm_stats_dump_all(void);
void ocm_install_props_bridge(void);

--------------

hw/rindex/rindex.h: 

typedef uint16_t rindex_t;
CONST rindex_t rid_base_nu(void);
CONST rindex_t rid_base_fcp_nu(void);
CONST rindex_t rid_base_ll_fcp_nu(void);
CONST rindex_t rid_base_rg_fcp_nu(void);
CONST rindex_t rid_nu_count(void);
CONST bool rid_in_nu_range(rindex_t rid);
CONST rindex_t rid_base_hu(void);
CONST rindex_t rid_base_hu_left(void);
CONST rindex_t rid_base_hu_right(void);
CONST rindex_t rid_hu_count(void);
CONST rindex_t rid_global_hu(void);
CONST bool rid_in_hu_range(rindex_t rid);
CONST bool rid_in_hu_left_range(rindex_t rid);
CONST bool rid_in_hu_right_range(rindex_t rid);
CONST rindex_t rid_hsu_qid_range_low(void);
CONST rindex_t rid_hsu_qid_range_high(void);
CONST rindex_t rid_hsu_lo_prio_q_start(void);
CONST rindex_t rid_base_pc(void);
CONST rindex_t rid_pc_count(void);
CONST rindex_t rid_base_pc_n(uint8_t pc);
CONST rindex_t rid_base_cluster_n(uint8_t cluster);
CONST rindex_t rid_base_cc(void);
CONST rindex_t rid_offset_pc_start(void);
CONST rindex_t rid_offset_pc_anycast(void);
CONST rindex_t rid_offset_pc_vp_lo(void);
CONST rindex_t rid_pc_vp_lo_count(void);
CONST rindex_t rid_offset_pc_vp_hi(void);
CONST rindex_t rid_pc_vp_hi_count(void);
CONST rindex_t rid_offset_pc_le(void);
CONST rindex_t rid_pc_le_count(void);
CONST rindex_t rid_offset_pc_dma(void);
CONST rindex_t rid_pc_dma_count(void);
CONST rindex_t rid_offset_pc_zip(void);
CONST rindex_t rid_pc_zip_count(void);
CONST rindex_t rid_offset_pc_rgx(void);
CONST rindex_t rid_pc_rgx_count(void);
CONST bool rid_in_pc_range(rindex_t rid);
CONST bool rid_in_cc_range(rindex_t rid);
CONST rindex_t rid_base_hnu(void);
CONST rindex_t rid_hnu_count(void);
CONST bool rid_in_hnu_range(rindex_t rid);
CONST rindex_t rid_base_bam(void);
CONST rindex_t rid_bam_count(void);
CONST rindex_t rid_bam_pool(uint8_t bam_pool);
CONST bool rid_in_bam_range(rindex_t rid);
CONST uint8_t bam_pool_from_rindex(rindex_t ridx);
CONST rindex_t rid_base_dam(void);
CONST rindex_t rid_dam_count(void);
CONST rindex_t rid_dam_pool(uint8_t dam_pool);
CONST bool rid_in_dam_range(rindex_t rid);
CONST uint8_t dam_pool_from_rindex(rindex_t ridx);
CONST rindex_t rid_base_ocm_dam(void);
CONST rindex_t rid_ocm_dam_count(void);
CONST rindex_t rid_ocm_dam_pool(uint8_t pool);
CONST bool rid_in_ocm_dam_range(rindex_t rid);
CONST rindex_t rindex_from_ocm_dam_pool(uint8_t pool);
CONST uint8_t ocm_pool_from_rindex(rindex_t ridx);
CONST bool rid_in_hbm_dam_range(rindex_t rid);
CONST rindex_t rindex_from_hbm_dam_pool(uint8_t pool);
CONST uint8_t hbm_dam_pool_from_rindex(rindex_t ridx);
CONST rindex_t rid_base_sw(void);
CONST rindex_t rid_sw_count(void);
CONST bool rid_in_sw_range(rindex_t rid);
CONST rindex_t rid_gbl_wqm(void);
CONST rindex_t rid_base_bnm(void);
CONST rindex_t rid_bnm_count(void);
CONST rindex_t rid_base_eqm(void);
CONST rindex_t rid_eqm_count(void);
CONST rindex_t rid_hnu_total_wu(void);
CONST rindex_t rid_bm_gbl_pool(void);
CONST rindex_t rid_nu_total_wu(void);
CONST rindex_t rid_hu0_total_wu(void);
CONST rindex_t rid_hu1_total_wu(void);
CONST rindex_t rid_hue0_total_wu(void);
CONST rindex_t rid_hue1_total_wu(void);
CONST rindex_t rid_eqm_total_wu(void);
CONST rindex_t rid_gbl_wu(void);
CONST bool rid_is_hnu_total_wu(rindex_t rid);
CONST bool rid_is_hue0_total_wu(rindex_t rid);
CONST bool rid_is_hue1_total_wu(rindex_t rid);
rindex_t rindex_from_faddr(faddr_t);
CONST faddr_t rindex_to_faddr(rindex_t);
bool rindex_to_faddr_checked(rindex_t, faddr_t *faddr);

--------------

hw/sbp/hw_sbp.h: 

struct channel;
struct fun_crypto_ctx;
struct DHDomain {int pglen; int qlen; const char *p; const char *q; const char *g;};
struct DSADomain {int pglen; int qlen; const char *p; const char *q; const char *g;};
struct SBPKeyBlob {uint32_t metadata; uint32_t priv_key_size; uint32_t pub_key_size; uint8_t *data;};
struct SBPFwVersion {uint32_t status; uint32_t version;};
void sbp_store_read_ptr(void *input_area, const void *ptr);
void sbp_store_write_ptr(void *input_area, const void *ptr);
int sbp_hash_size(int hash_type);
void sbp_booted_push(struct channel *);
void sbp_booted_push(struct channel *);
void sbp_boot_progress_push(struct channel *);
bool sbp_host_booted(void);
void sbp_set_max_attempt_push(struct channel *channel);
void sbp_get_boot_key_push(struct channel *channel, uint32_t boot_key_option, void*result, uint32_t res_size);
void sbp_get_utility_key_push(struct channel *channel, uint32_t key_index, void *data, uint32_t data_size);
void sbp_get_random_push(struct channel *,void *output, size_t nbytes);
void sbp_prbs15_push(struct channel *,uint32_t seed, uint32_t length, void *output);
void sbp_get_rtc_push(struct channel *channel, uint64_t *value);
uint64_t sbp_rtc_to_us(const uint64_t value);
void sbp_special_wu_push(struct channel *channel);
void sbp_test_wu_push(struct channel *,faddr_t cdest, wuid_t chandler, uintptr_t carg0, uintptr_t carg1);
void sbp_async_test_dma_push(struct channel *,uint64_t buf[2]);
void *sbp_mul_push(struct channel *,uint32_t op_size, void*output);
void *sbp_write_emmc_push(struct channel *channel, int direct, uint32_t input_length);
void sbp_read_emmc_push(struct channel *channel, void*output, uint32_t output_length);
void sbp_save_range_push(struct channel *channel, void*src, uint32_t length, uint64_t emmc_addr);
void sbp_set_emmc_read_pointers_push(struct channel *channel, uint32_t value);
void sbp_set_emmc_write_pointers_push(struct channel *channel, uint32_t value);
void sbp_trigger_save_range_push(struct channel *channel);
void sbp_write_host_data_push(struct channel *channel, void *input, uint32_t input_length);
void sbp_read_host_data_push(struct channel *channel, void*output, uint32_t output_length);
void sbp_read_nor_flash_push(struct channel *channel, void*output, uint32_t output_length, uint32_t offset);
uint32_t sbp_rsa_metadata(uint32_t bytesize, int crt);
uint32_t sbp_ecc_p_metadata(uint32_t bytesize, int domain);
uint32_t sbp_ecc_b_metadata(uint32_t bytesize, int domain);
uint32_t sbp_ecc_monty_metadata(uint32_t bytesize, int domain);
uint32_t sbp_ecc_ed25519_metadata(void);
uint32_t sbp_dsa_metadata(uint32_t psize, uint32_t qsize, int short_g);
uint32_t sbp_dh_metadata(uint32_t psize, int short_g);
struct SBPKeyBlob *alloc_key_blob(uint32_t metadata, uint32_t priv_key_size, uint32_t pub_key_size);
struct SBPKeyBlob *copy_key_blob(const struct SBPKeyBlob *src);
void free_key_blob(NULLABLE struct SBPKeyBlob *b);
static inline uint8_t *key_blob_public_key(const struct SBPKeyBlob*key_blob)
 {return key_blob->data +key_blob->priv_key_size;}
static inline uint8_t *key_blob_private_key(const struct SBPKeyBlob*key_blob)
 {return key_blob->data;}
void sbp_free_key_blob_array_push(struct channel *channel, struct SBPKeyBlob**key_blobs, size_t num_key_blobs);
void sbp_free_key_blob_push(struct channel *channel, struct SBPKeyBlob*key_blob);
void *sbp_wrap_key_push(struct channel *channel, uint32_t metadata, int input_size, void *outputv);
void *sbp_unwrap_key_push(struct channel *channel, uint32_t metadata, void *outputv, size_t outputc);
void sbp_push_convert_exception(struct channel *channel, uint64_t *ret);
void *sbp_import_key_push(struct channel *channel, int kdf_sp800_56c, struct SBPKeyBlob *key_blob);
void sbp_import_pkcs8_push(struct channel *channel, const char *pw, int pw_length, const char *pkcs8_der, int pkcs8_der_len, const uint8_t*auth, void *outputv, size_t outputc);
void *sbp_create_key_push(struct channel *channel, uint32_t metadata, const uint8_t *dh_q, uint32_t dh_q_size, void *outputv, size_t outputc);
void *sbp_create_keyblob_push(struct channel *channel, struct SBPKeyBlob *keyblob, const uint8_t *q, uint32_t dh_priv_key_size);
void sbp_read_pub_ek_push(struct channel *channel, void *outbuf);
void *sbp_ek_pt_mult_push(struct channel *channel, void *outbuf);
void *sbp_ek_sign_push(struct channel *channel, int hash_type, void *outbuf);
void *sbp_dh_pub_key_full_check_push(struct channel *channel, int keysize);
void sbp_dh_push_ex(struct channel *channel, const uint8_t *auth_data, const struct SBPKeyBlob *key_blob, const uint8_t *p, const uint8_t *peer_pub, void *outbuf);
void *sbp_ecdh_push_ex(struct channel *channel, const uint8_t *auth_data, const struct SBPKeyBlob *key_blob, void *outbuf);
void *sbp_eddsa_ver_push(struct channel *channel, const uint8_t *msg, size_t msglen);
void sbp_eddsa_sign_push_ex(struct channel *channel, const uint8_t *auth_data, const struct SBPKeyBlob *key_blob, const uint8_t *pub_key, const uint8_t *msg, size_t msglen, void*outbuf);
NULLABLE void *sbp_ecdsa_verify_hash_push_ex(struct channel *channel, uint32_t key_metadata, uint32_t dgst_len);
NULLABLE void *sbp_ecdsa_sign_hash_push_ex(struct channel *channel, uint32_t dgst_len, const uint8_t *auth_data, const struct SBPKeyBlob *key_blob, void*outbuf);
void *sbp_dsa_verify_hash_push(struct channel *channel, int plen, int qlen, int glen, int hash_type);
void *sbp_dsa_sign_hash_push_ex(struct channel *channel, const uint8_t *auth_data, const struct SBPKeyBlob *key, const struct DSADomain *domain, int hash_type, void*outbuf);
void *sbp_rsa_verify_hash_push(struct channel *channel, int keysize, int short_e, int hash_type, int padding_type, int salt_len);
void *sbp_rsa_kbag_verify_hash_push(struct channel *channel, int key_index, int hash_type, int padding_type, int salt_len);
void *sbp_rsa_sign_hash_push_ex(struct channel *channel, const uint8_t *auth_data, const struct SBPKeyBlob *key_blob, int hash_type, int padding_type, int salt_len, void*outbuf);
void *sbp_rsa_encrypt_push(struct channel *channel, int keysize, int short_e, int message_length, int hash_type, int padding_type, void *outbuf);
void *sbp_rsa_decrypt_push_ex(struct channel *channel, const uint8_t *auth_data, const struct SBPKeyBlob *key_blob, int hash_type, int padding_type, void*outbuf);
void sbp_get_dice_cert_push(struct channel *channel, uint32_t type, void *outbuf, uint32_t outbuf_size);
void sbp_dice_ecdh_push(struct channel *channel, uint32_t type, const uint8_t *peer_key_x, const uint8_t *peer_key_y, void *outbuf);
void sbp_dice_ecdsa_push(struct channel *channel, uint32_t type, const uint8_t *digest, uint32_t digest_length, void *outbuf);
void sbp_self_test_push(struct channel *channel, uint32_t error);
void sbp_get_keygen_random_push(struct channel *channel, void *output, size_t nbytes);
void *sbp_hash_push(struct channel *channel, int hash_type, size_t msglen, void*outbuf);
void *sbp_rsa_sign_push(struct channel *channel, int keysize, int crt, int hash_type, int padding_type, int salt_len, int msg_len, void*outbuf);
void *sbp_rsa_decrypt_push(struct channel *channel, int keysize, int crt, int hash_type, int padding_type, void*outbuf);
void *sbp_dsa_sign_push(struct channel *channel, int pglen, int qlen, size_t msglen, uint8_t hash_type, void *outbuf);
void *sbp_aes_push(struct channel *channel, int key_len, int aes_mode, int decrypt, int in_len, void *output);
void *sbp_aes_gcm_push_encrypt(struct channel *channel, int key_len,int aad_len, int pt_len, void *out_ct_tag);
void *sbp_aes_gcm_push_decrypt(struct channel *channel, int key_len, int aad_len, int ct_len, void *out_pt);
void *sbp_aes_cmac_push(struct channel *channel, int key_len, int msg_len, void *out_cmac);
void *sbp_hmac_push(struct channel *channel, int hash_type, int key_len, int msg_len, void *out_hmac);
void *sbp_hash_drbg_init_push(struct channel *channel, uint32_t entropyLen, uint32_t nonceLen, uint32_t persoLen, int hashType);
void *sbp_hash_drbg_step_push(struct channel *channel, uint32_t entropyLen, uint32_t outputLen, void*outbuf);
void *sbp_full_dh_key_check_push(struct channel *channel, uint32_t p_size, uint32_t q_size, int short_g);
void *sbp_pbkdf_push(struct channel *channel, int hash_algo, uint32_t iteration_count, uint32_t password_len, const uint8_t *password, uint32_t salt_len, void *outputv, uint32_t outputc);
void *sbp_x963kdf_push(struct channel *channel, int hash_algo, const uint8_t *z, uint32_t zlen, uint32_t sharedInfoLen, void *output, uint32_t output_len);
void sbp_hkdf_push(struct channel *channel, int hash_algo, const uint8_t *ikm, uint32_t km_len, const uint8_t *salt, uint32_t salt_len, const uint8_t *info, uint32_t info_len, void *output, uint32_t output_len);
void sbp_kdf_push(struct channel *channel, const uint8_t *key, uint32_t key_len, const uint8_t *fixed_info, uint32_t fixed_info_len, void *outputv);
uint8_t *sbp_trng_conditioning_func_test_push(struct channel *channel, uint32_t key_len, uint32_t input_len, uint8_t *output);
uint8_t *sbp_trng_conditioning_func_ecb_test_push(struct channel *channel, uint32_t key_len, uint32_t input_len, uint8_t *output);
void sbp_trng_ring_data_test_push(struct channel *channel, uint32_t clockDivider, uint32_t disabled_rings_hi, uint32_t disabled_rings_lo, uint8_t *output, uint32_t output_len);
void sbp_trng_ring_restart_data_test_push(struct channel *channel, uint8_t *output);
int hw_crypto_kpp_ctx_init(struct fun_crypto_ctx *ctx, uint8_t alg, uint8_t ecc_curve_id);
int hw_crypto_pke_ctx_init(struct fun_crypto_ctx *ctx, uint8_t alg, uint8_t ecc_curve_id);
uint16_t hw_crypto_ecc_keylen(uint16_t curve_id);
void *sbp_upgrade_push(struct channel *channel, uint32_t image_type, void *image, uint32_t image_size, uint32_t *status, bool active_image, bool downgrade);
void sbp_get_version_push(struct channel *channel, uint32_t image_type, struct SBPFwVersion *result);
size_t sbp_get_all_versions_alloc_size(uint32_t numitems);
uint32_t sbp_get_all_versions_numitems_from_size(size_t size);
void sbp_get_all_versions_push(struct channel *channel, uint32_t res_size, void *result);
struct sbp_fwdesc {uint32_t fourcc; uint32_t version; enum{ACTIVE_STATE_UNKNOWN, ACTIVE_STATE_INACTIVE, ACTIVE_STATE_ACTIVE,}active_state; const char *fourcc_s; const char *description;
};
void sbp_get_all_versions_response(void *response, uint32_t maxitems, void *ctx, void(callback)(void *ctx, const struct sbp_fwdesc *,unsigned int));
struct esec_serial_number;
void sbp_get_serial_nr_push(struct channel *channel, struct esec_serial_number *serial_nr);
void sbp_get_serial_nr_safe_push(struct channel *channel, struct esec_serial_number *serial_nr);
void sbp_get_otp_push(struct channel *channel, bool system, void *data, uint32_t data_size);
enum sbp_dbg_grant {sbp_dbg_grant_ccu_hua_mstr_enable =12, sbp_dbg_grant_ccu_hub_mstr_enable =13, sbp_dbg_grant_flash_read =16, sbp_dbg_grant_flash_modify =17,};
bool sbp_is_dbg_access_granted(enum sbp_dbg_grant bit);
bool is_sbp_wu(struct wu *wu);
struct frame *sbp_wu_to_colder_frame(struct wu *wu);

--------------

hw/sbp/hw_sbp_dpc.h: 

enum ImportType_t {PKCS8_IMPORT, ECDH_IMPORT, RAW_IMPORT};

--------------

networking/clbp.h: 

uint32_t clbp_create_le_opcode(struct lut *tbl1, struct lut *tbl2, struct lut *tbl3, struct lut *tbl4);
WU_THREADED enum fun_ret
clbp_update_profile_opcode(int profile_index, uint32_t opcode, NULLABLE uint32_t *old_opcode);

--------------

networking/forwarding/forwarding.h: 

struct forward_tx_handle;
enum nu_prv_teml {NU_PRV_TEML_L1_NONE =0, NU_PRV_TEML_L1_FAE =1, NU_PRV_TEML_L1_C2T =2, NU_PRV_TEML_L1_P2N =3, NU_PRV_TEML_L2_NONE =0, NU_PRV_TEML_L2_ETH =1, NU_PRV_TEML_L3_NONE =0, NU_PRV_TEML_L3_RSVD =1, NU_PRV_TEML_L3_IPV4 =2, NU_PRV_TEML_L3_IPV6 =3, NU_PRV_TEML_L4_NONE =0, NU_PRV_TEML_L4_RSVD =1, NU_PRV_TEML_L4_TCP =2, NU_PRV_TEML_L4_UDP =3, NU_PRV_TEML_L5_NONE =0, NU_PRV_TEML_L5_FCP =1, NU_PRV_TEML_L5_PTP =2, NU_PRV_TEML_L5_RSVD =3, NU_PRV_TEML_ERR_NONE =0, NU_PRV_TEML_ERR_SW =1};
enum erp_prv_teml {ERP_PRV_TEML_L1_T2N =0, ERP_PRV_TEML_L1_T2C =1, ERP_PRV_TEML_L1_FCP =2, ERP_PRV_TEML_L1_P2N =3, ERP_PRV_TEML_L2_NONE =0, ERP_PRV_TEML_L2_ETH =1, ERP_PRV_TEML_L3_NONE =0, ERP_PRV_TEML_L3_RSVD =1, ERP_PRV_TEML_L3_IPV4 =2, ERP_PRV_TEML_L3_IPV6 =3, ERP_PRV_TEML_L4_NONE =0, ERP_PRV_TEML_L4_PCIE =1, ERP_PRV_TEML_L4_TCP =2, ERP_PRV_TEML_L4_UDP =3, ERP_PRV_TEML_L4_ROCEV2_UD =4, ERP_PRV_TEML_L4_ROCEV2_RC =5, ERP_PRV_TEML_OTYPE_NONE =0, ERP_PRV_TEML_OTYPE_NVGRE =1, ERP_PRV_TEML_OTYPE_VXLAN =2, ERP_PRV_TEML_OTYPE_MPLS =3, ERP_PRV_TEML_OL3_NONE =0, ERP_PRV_TEML_OL3_RSVD =1, ERP_PRV_TEML_OL3_IPV4 =2, ERP_PRV_TEML_OL3_IPV6 =3, ERP_PRV_TEML_OL4_NONE =0, ERP_PRV_TEML_OL4_RSVD =1, ERP_PRV_TEML_OL4_TCP =2, ERP_PRV_TEML_OL4_UDP =3, ERP_PRV_TEML_ERR_NONE =0, ERP_PRV_TEML_ERR_SW =1};
static inline uint8_t erp_prv_template_get_l1(uint16_t prv_tmpl)
{return(prv_tmpl &0x0003);
}
static inline uint8_t erp_prv_template_get_l2(uint16_t prv_tmpl)
{return((prv_tmpl >>2)&0x0001);
}
static inline uint8_t erp_prv_template_get_vlan(uint16_t prv_tmpl)
{return((prv_tmpl >>3)&0x0001);
}
static inline uint8_t erp_prv_template_get_l3(uint16_t prv_tmpl)
{return((prv_tmpl >>4)&0x0003);
}
static inline uint16_t erp_prv_template_set_l3(uint16_t prv_tmpl, uint8_t value)
{prv_tmpl &= ~(0x3<<4);return prv_tmpl |((value &0x3)<<4);
}
static inline uint8_t erp_prv_template_get_l4(uint16_t prv_tmpl)
{return((prv_tmpl >>8)&0x0007);
}
static inline uint16_t erp_prv_template_set_l4(uint16_t prv_tmpl, uint8_t value)
{prv_tmpl &= ~(0x7<<8);return prv_tmpl |((value &0x7)<<8);
}
static inline uint8_t erp_prv_template_get_otype(uint16_t prv_tmpl)
{return((prv_tmpl >>6)&0x0003);
}
static inline uint8_t erp_prv_template_get_ol3(uint16_t prv_tmpl)
{return((prv_tmpl >>11)&0x0003);
}
static inline uint16_t erp_prv_template_set_ol3(uint16_t prv_tmpl, uint8_t value)
{prv_tmpl &= ~(0x3<<11);return prv_tmpl |((value &0x3)<<11);
}
static inline uint8_t erp_prv_template_get_ol4(uint16_t prv_tmpl)
{return((prv_tmpl >>13)&0x0003);
}
static inline uint16_t erp_prv_template_set_ol4(uint16_t prv_tmpl, uint8_t value)
{prv_tmpl &= ~(0x3<<13);return prv_tmpl |((value &0x3)<<13);
}
static inline uint8_t erp_prv_template_get_err(uint16_t prv_tmpl)
{return((prv_tmpl >>15)&0x0001);
}
static inline uint8_t nu_prv_template_get_l1(uint16_t prv_tmpl)
{return(prv_tmpl &0x0003);
}
static inline uint8_t nu_prv_template_get_l2(uint16_t prv_tmpl)
{return((prv_tmpl >>2)&0x0001);
}
static inline uint16_t nu_prv_template_set_l2(uint16_t prv_tmpl, uint8_t value)
{prv_tmpl &= ~(0x1<<2);return prv_tmpl |((value &0x1)<<2);
}
static inline uint8_t nu_prv_template_get_vlan(uint16_t prv_tmpl)
{return((prv_tmpl >>3)&0x0001);
}
static inline uint8_t nu_prv_template_get_l3(uint16_t prv_tmpl)
{return((prv_tmpl >>4)&0x0003);
}
static inline uint16_t nu_prv_template_set_l3(uint16_t prv_tmpl, uint8_t value)
{prv_tmpl &= ~(0x3<<4);return prv_tmpl |((value &0x3)<<4);
}
static inline uint8_t nu_prv_template_get_l4(uint16_t prv_tmpl)
{return((prv_tmpl >>6)&0x0007);
}
static inline uint16_t nu_prv_template_set_l4(uint16_t prv_tmpl, uint8_t value)
{prv_tmpl &= ~(0x7<<6);return prv_tmpl |((value &0x7)<<6);
}
size_t forward_rx_headroom_size(void);
size_t forward_rx_tailroom_size(void);
size_t forward_tx_headroom_size(void);
void forward_to_host(struct fun_nu_n2p_hdr *n2p, int l2_hdr_off);
void forward_drop(struct fun_nu_n2p_hdr *n2p);
bool forward_rx_should_process(struct fun_nu_n2p_hdr *n2p);
size_t forward_tx_handle_size(void);
struct forward_tx_handle *forward_tx_handle_init(void *p, size_t headroom, size_t pktlen, void **payload);
void forward_tx_handle_send(struct forward_tx_handle *handle, NULLABLE struct frame *frame);
struct workerpool *forward_get_default_workerpool(void);

--------------

networking/inet_addr.h: 

uint32_t inet_addr(const char *);

--------------

networking/network_headers.h: 

struct ethhdr {uint8_t dmac[ETH_ALEN];uint8_t smac[ETH_ALEN];uint16_t eth_p;};
struct iphdr { uint8_t ip_hl:4, ip_v:4; uint8_t ip_v:4, ip_hl:4; uint8_t ip_tos; uint16_t ip_len; uint16_t ip_id; uint16_t ip_off;    uint8_t ip_ttl; uint8_t ip_p; uint16_t ip_csum; uint32_t ip_src; uint32_t ip_dst;};
struct ipv6hdr { uint8_t tc:4, ip_v:4; uint8_t ip_v:4, tc:4; uint8_t flow_label[3];uint16_t payload_len; uint8_t next_hdr; uint8_t hop_limit; uint8_t ip_src[16];uint8_t ip_dst[16];};
typedef uint32_t tcp_seq;
struct tcphdr {uint16_t th_sport; uint16_t th_dport; tcp_seq th_seq; tcp_seq th_ack; uint8_t th_x2:4, th_off:4; uint8_t th_off:4, th_x2:4; uint8_t th_flags; uint16_t th_win; uint16_t th_sum; uint16_t th_urp;};

--------------

networking/rdma/rdma.h: 

struct fun_rdma_msg {union{uint8_t num_wrs; uint64_t _;};
};
struct fun_rdma_completion {union{uint8_t num_completions; uint64_t _;};
};
struct fun_admin_rdma_req *rdma_admin_req_init(struct channel *channel, size_t extra);
void rdma_alloc_pd_push(struct channel *channel, struct fun_admin_rdma_req *req);
void rdma_dealloc_pd_push(struct channel *channel, struct fun_admin_rdma_req *req, uint16_t pd);
void rdma_create_req_push(struct channel *channel, struct fun_admin_rdma_req *req, uint16_t pd, enum fun_rdma_llp_type llp, enum fun_rdma_qp_type qp_type, enum fun_rdma_qp_caps qp_caps, uint16_t max_send_wr, uint16_t max_recv_wr, uint8_t affinity);
void rdma_destroy_req_push(struct channel *channel, struct fun_admin_rdma_req *req, enum fun_rdma_llp_type llp, uint32_t flow_id);
bool rdma_flow_bind(uint32_t flow_id, struct flow *hton_f, struct flow *ntoh_f);
void rdma_flow_unbind(uint32_t flow_id, struct flow *hton_f, struct flow *ntoh_f);
void rdma_get_attr_push(struct channel *channel, struct fun_admin_rdma_req *req, enum fun_rdma_llp_type llp, struct fun_roce_dev_attr *attr);
void rdma_query_qp_push(struct channel *channel, struct fun_admin_rdma_req *req, enum fun_rdma_llp_type llp, uint32_t flow_id, struct fun_roce_qp_attr *attr);
void rdma_modify_qp_push(struct channel *channel, struct fun_admin_rdma_req *req, uint32_t flow_id);
void rdma_modify_init_for_init(struct fun_admin_rdma_req *req);
void rdma_modify_init_for_rtr_rc(struct fun_admin_rdma_req *req, uint32_t src_ip, uint32_t dst_ip, uint32_t rem_qpn, uint16_t pmtu, uint32_t rq_psn, uint8_t min_rnr_timer, uint8_t max_dest_rd_atomic);
void rdma_modify_init_for_rtr_ud(struct fun_admin_rdma_req *req, uint32_t src_ip, uint16_t pmtu);
void rdma_modify_init_for_rts_rc(struct fun_admin_rdma_req *req, uint32_t sq_psn, uint8_t timeout, uint8_t retry_cnt, uint8_t rnr_retry, uint8_t max_rd_atomic);
void rdma_modify_init_for_rts_ud(struct fun_admin_rdma_req *req, uint32_t sq_psn);
void rdma_modify_init_for_reset(struct fun_admin_rdma_req *req);
void rdma_reg_mr_push(struct channel *channel, struct fun_admin_rdma_req *req, uint32_t first_byte_offset, uint16_t page_shift, uint16_t pd, uint64_t addr, uint64_t len, uint16_t flags);
void rdma_dereg_mr_push(struct channel *channel, struct fun_admin_rdma_req *req, uint32_t id);
void rdma_alloc_mr_push(struct channel *channel, struct fun_admin_rdma_req *req, uint16_t max_num_pages, uint16_t pd, uint16_t pgtab_shift, uint16_t pg_sz_nbits);
uint32_t rdma_update_fast_reg_key(uint32_t stag, uint8_t key);
void rdma_post_send(struct frame *frame, struct flow *caller_f, struct fun_rdma_msg *msg);
void rdma_post_send_push(struct frame **frame, struct flow *caller_f, struct fun_rdma_msg *msg);
void rdma_post_recv(struct frame *frame, struct flow *caller_f, struct fun_rdma_msg *msg);

--------------

networking/rdsock.h: 

struct rdsock;
typedef enum {RDSOCK_CLIENT, RDSOCK_SERVER, RDSOCK_LISTENER}rdsock_role_t;
typedef enum {RDSOCK_RESP_NONE, RDSOCK_RESP_OK, RDSOCK_RESP_FAIL}rdsock_resp_t;
typedef enum rdsock_hdrtype {RDSOCK_HDRTYPE_NONE, RDSOCK_HDRTYPE_RDS, RDSOCK_HDRTYPE_CHECK}rdsock_hdrtype_t;
struct rdsock_fp_msg {union{void *context; void *fp_ctxt;};uint32_t *used_p; union {void *payload; struct fun_mbuf *buf; struct fun_ptr_and_size *vectors;};uint32_t plen; uint32_t datalen; uint16_t hdrlen; uint8_t buf_type; uint8_t num_vectors;
};
struct rdsock_msg;
struct rdsock_msg {uint64_t msgno; char *msg; uint16_t msglen; uint8_t buf_type; uint8_t num_vectors; uint8_t num_blocks; uint32_t datalen; struct{struct fun_mbuf *buf; struct fun_ptr_and_size *meta;};struct fun_ptr_and_size *vectors; void *context; struct rdsock_msg *next; union {struct fun_ptr_and_size dataptr; uint8_t sgl_count;};rdsock_resp_t resp;
};
typedef void(*rdsock_recv_buffer_check_t)(struct rdsock *sock, struct rdsock_msg *msg);
enum rdsock_fp_rsp {RDSOCK_FP_CONTINUE_SP =1, RDSOCK_FP_SKIP, RDSOCK_FP_DMA,};
struct rdsock_open_rsp;
struct rdsock_params {uint32_t remoteip; uint16_t port; uint8_t dmac[6];bool dmac_override; uint8_t ip_tos; bool ip_tos_override; rdsock_role_t role; rdsock_hdrtype_t hdrtype; int(*recv_check)(struct rdsock *sock, struct rdsock_msg *msg, uint16_t *msglen, uint32_t *datalen, uint32_t *resplen);rdsock_recv_buffer_check_t recv_buffer_check; void *recv_context; void(*recv_send)(struct channel *channel, struct rdsock *sock, struct rdsock_msg *msg);enum rdsock_fp_rsp(*process_fastpath)(struct rdsock_fp_msg *msg);void(*recv_send_inline_no_frame)(void *rdsock_ctxt, void *fp_ctxt);void(*close_notify)(struct rdsock *sock, void *context);void(*open_push)(struct channel *channel, struct rdsock_open_rsp *response);void(*tls_psk_find_push)(struct channel *channel, struct rdsock *sock, void *recv_context, void *tls_psk);void(*tls_psk_use_push)(struct channel *channel, struct rdsock *sock, void *recv_context, void *tls_psk);uint16_t hdrlen; uint8_t recv_buffer_po2_bits; uint32_t maxrecv_data; uint32_t maxrecv_resp; uint16_t q_id; uint16_t q_depth; bool direct_send; bool enable_qos; vol_qos_handle_t vol_qos_handle; struct vol_qos *qos; secure_channel_type_t tls_mode;};
struct rdsock_open_req {struct rdsock_params params; bool use_specified_vp; faddr_t vp; faddr_t affinity_vp; bool non_data; struct rdsock **rdsock;};
struct rdsock_open_rsp {void *listen_context; int socketid; uint32_t srcip; uint16_t srcport; struct rdsock **rdsock;};
struct rdsock_update_req {uint32_t maxrecv_data; uint32_t maxrecv_resp; uint16_t q_depth; bool enable_qos; vol_qos_handle_t vol_qos_handle; uint32_t qosl_guar_cdt; uint32_t qosl_max_cdt_per_io; struct vol_qos *qos; int status;};
struct rdsock_stats {uint16_t recvs; uint32_t data_bytes; uint32_t resp_bytes; uint64_t recvs_total; uint64_t recv_bytes; uint64_t recv_msg_free; uint64_t recv_data_free; uint64_t recvs_samples; uint64_t recv_credits_returned; uint64_t recv_blocked; uint64_t sends_blocked; uint64_t adm_control_data; uint64_t adm_control_resp; uint64_t adm_control_glob_reads; uint64_t adm_control_glob_writes; uint64_t ws_fail; uint64_t total_rqe_count; uint64_t total_sends; uint32_t qos_min_read_iops; uint32_t qos_min_write_iops; uint32_t qos_max_read_iops; uint32_t qos_max_write_iops;};
struct rdsock_stat_per_vp
 {faddr_t vp; uint16_t num_servers; uint16_t num_clients; uint16_t num_listeners; struct rdsock_stats client_stats; struct rdsock_stats server_stats;};
struct rdsock_vp_stats
 {struct rdsock_stat_per_vp *stats; uint8_t num_stats;};
void rdsock_open_push(struct channel *channel, struct rdsock_open_req *req);
void rdsock_sendmsg_push(struct channel *channel, struct rdsock *sock, struct rdsock_msg *msg);
void rdsock_sendmsg_fsend(struct frame**frame, struct flow *flow, struct rdsock *sock, struct rdsock_msg *msg);
void rdsock_sendmsg_vec_fsend(struct frame **frame, struct flow *flow, struct rdsock *sock, struct rdsock_msg *msg);
void rdsock_disconnect_push(struct channel *channel, struct rdsock *rdsock, bool abort);
void rdsock_close_push(struct channel *channel, struct rdsock *rdsock);
void rdsock_update_push(struct channel *channel, struct rdsock *rdsock, struct rdsock_update_req *req);
void rdsock_start_migration_push(struct channel *channel, struct rdsock *rdsock, faddr_t new_vp);
void rdsock_init_push(struct channel *channel, uint32_t localip);
void rdsock_init(uint32_t localip);
void rdsock_shutdown(void);
void rdsock_enable_qos_ac_push(struct channel *channel, bool enable);
void rdsock_configure_vp_ac_push(struct channel *channel, uint64_t data_bytes_per_vp, uint64_t resp_bytes_per_vp);
void rdsock_get_vp_stats_push(struct channel *channel, struct rdsock_vp_stats *vp_stats);
void rdsock_get_flow_stats_push(struct channel *channel, OUT struct fun_json **ret_json);
void rdsock_qosl_dequeue_callback(uint64_t *ctxt, uint32_t num_read, uint32_t num_write);
faddr_t rdsock_vp_get(uint32_t id, faddr_t affinity, struct vol_qos *qos, uint32_t cost_idx);
void rdsock_vp_put(faddr_t vp, struct vol_qos *qos, uint32_t cost_idx);
bool rdsock_vp_update_load(faddr_t vp, struct vol_qos *cur_qos, struct vol_qos *new_qos);
bool rdsock_supports_qos_ratelimting();
bool rdsock_is_provider_funtcp();
struct rdsock_port_id {uint16_t port; int socketid;};
void rdsock_get_port_id(struct rdsock *sock, struct rdsock_port_id *port_id);

--------------

networking/sdn/sdn_flow_mgr.h: 

ENUM_DEF(sdn_flow_mgr_state_t);
typedef bool(*sdn_flow_mgr_pre_cb)(void *flow, bool ready);
typedef enum fun_ret(*sdn_flow_mgr_del_cb)(void *flow);
typedef void(*sdn_flow_mgr_post_cb)(void *flow);
size_t sdn_flow_mgr_flow_state_size_for_config(struct workerpool *wp, uint32_t num_flows_per_vp, size_t flow_size);
WU_THREADED NULLABLE struct sdn_flow_mgr *
sdn_flow_mgr_alloc(struct workerpool *wp, uint8_t *flow_state, uint32_t num_flows_per_vp, size_t flow_size, sdn_flow_mgr_pre_cb pre_cb, sdn_flow_mgr_post_cb post_cb, sdn_flow_mgr_del_cb del_cb, size_t ts_offset, size_t ttl_offset, size_t state_offset);
WU_THREADED void sdn_flow_mgr_free(struct sdn_flow_mgr *mgr);
NULLABLE struct sdn_flow_mgr_vp *
sdn_flow_mgr_get_per_vp(struct sdn_flow_mgr *mgr, faddr_t vp);
NULLABLE struct sdn_flow_mgr_vp *
sdn_flow_mgr_get_per_vp_local(struct sdn_flow_mgr *mgr);
void sdn_flow_mgr_flow_update_ts(struct sdn_flow_mgr_vp *vp_mgr, void *flow);
NULLABLE void *sdn_flow_mgr_flow_alloc(struct sdn_flow_mgr_vp *vp_mgr);
void sdn_flow_mgr_flow_free(struct sdn_flow_mgr_vp *vp_mgr, void *flow);
NULLABLE void *sdn_flow_mgr_flow_get(struct sdn_flow_mgr_vp *vp_mgr, uint32_t id);
uint32_t sdn_flow_mgr_flowid_get(struct sdn_flow_mgr_vp *vp_mgr, void *flow);
NULLABLE void *sdn_flow_mgr_iterate(struct sdn_flow_mgr_vp *vp_mgr, uint32_t *flow_index);
void sdn_flow_mgr_scavenge_resume(struct sdn_flow_mgr_vp *vp_mgr, void *flow);

--------------

networking/sgl_fifo.h: 

enum sgl_fifo_consts {SGL_FIFO_SIZE_SHIFT =10, SGL_FIFO_SIZE =(1<<SGL_FIFO_SIZE_SHIFT),SGL_FIFO_SIZE16 =(SGL_FIFO_SIZE >>4),};
static_assert(SGL_FIFO_SIZE_SHIFT <=11,"max SGL_FIFO_SHIFT_SIZE is 11(2KB)");
void sgl_fifo_init(struct sgl_fifo *sf, void *start);
void *sgl_fifo_in(struct sgl_fifo *sf, void *src, unsigned int len16);
void *sgl_fifo_out_plen_for_dma_pcie(struct sgl_fifo *sf, void *dst, unsigned int *plen, unsigned int *nsgl_out);
void *sgl_fifo_out_plen_for_dma(struct sgl_fifo *sf, void *dst, unsigned int *plen, unsigned int *nsgl_out, uint64_t direction, uint64_t eop);

--------------

networking/sgl_fifo_internal.h: 

struct sgl_fifo {uint8_t sf_tail16; uint8_t sf_head16; uint8_t sf_occupancy16; uint8_t pad[5];void *sf_start;};
unsigned int sgl_fifo_tail16(struct sgl_fifo *sf);
unsigned int sgl_fifo_head16(struct sgl_fifo *sf);
unsigned int sgl_fifo_occupancy16(struct sgl_fifo *sf);
void sgl_fifo_dump(struct sgl_fifo *sf);

--------------

networking/tcpip/in.h: 

typedef uint32_t in_addr_t;
typedef uint16_t in_port_t;
typedef uint8_t __sa_family_t;
typedef uint8_t sa_family_t;
struct in_addr {in_addr_t s_addr;};
typedef uint32_t __socklen_t;
typedef uint32_t socklen_t;
struct sockaddr_in {uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero[8];};
struct sockaddr_storage {unsigned char ss_len; sa_family_t ss_family; char __ss_pad1[_SS_PAD1SIZE];int64_t __ss_align; char __ss_pad2[_SS_PAD2SIZE];};
struct ip_mreq {struct in_addr imr_multiaddr; struct in_addr imr_interface;};
struct ip_mreqn {struct in_addr imr_multiaddr; struct in_addr imr_address; int imr_ifindex;};
struct ip_mreq_source {struct in_addr imr_multiaddr; struct in_addr imr_sourceaddr; struct in_addr imr_interface;};
struct group_req {uint32_t gr_interface; struct sockaddr_storage gr_group;};
struct group_source_req {uint32_t gsr_interface; struct sockaddr_storage gsr_group; struct sockaddr_storage gsr_source;};
struct __msfilterreq {uint32_t msfr_ifindex; uint32_t msfr_fmode; uint32_t msfr_nsrcs; struct sockaddr_storage msfr_group; struct sockaddr_storage *msfr_srcs;};

--------------

networking/tcpip/network_macros.h: 


--------------

networking/tcpip/tcp.h: 

struct channel;
struct metaflow;
struct fun_admin_tcp_req;
struct fun_admin_tcp_req *tcp_host_create_tcp_req_init(struct channel *channel);
void tcp_host_create_req_push(struct channel *channel, struct fun_admin_tcp_req *req);
void tcp_host_destroy_req_push(struct channel *channel, unsigned int tcpid);
void tcp_host_flow_bind(uint32_t tcpid, struct flow *hton_f, struct flow *ntoh_f);
void tcp_host_flow_unbind(uint32_t tcpid, struct flow *hton_f, struct flow *ntoh_f);
void tcp_host_listen_start_req_push(struct channel *channel, uint32_t backlog, uint16_t sport, uint32_t saddr);
void tcp_host_listen_stop_req_push(struct channel *channel, uint16_t sport, uint32_t saddr);
void tcp_host_accept_rsp_push(struct channel *channel, uint32_t listen_id);
void tcp_host_accept_rsp_with_reject_push(struct channel *channel, uint32_t tcpid, uint8_t ret);
void tcp_host_connect_req_push(struct channel *channel, uint16_t sport, uint16_t dport, uint32_t saddr, uint32_t daddr);
void tcp_host_disconnect_req_push(struct channel *channel);
void tcp_host_abort_req_push(struct channel *channel);
void tcp_host_sockopt_req_push(struct channel *channel, struct fun_socket_sockopt_req *req);
struct fun_admin_tcp_req *
tcp_host_migrate_tcp_req_init(struct channel *channel);
void tcp_host_migrate_req_push(struct channel *channel, struct fun_admin_tcp_req *req, unsigned int tcpid, faddr_t dest);
void tcp_host_recvupdmsg_send(struct flow *caller_hton_f, struct frame *frame, uint32_t rcvcredits);
void tcp_host_recvupdmsg_send_no_frame(struct flow *caller_hton_f, uint32_t rcvcredits);
void tcp_host_sendmsg_req_send(struct flow *caller_hton_f, struct frame *frame, struct fun_socket_sendmsg *sendmsg);
void tcp_host_packet_free(void *payload);
void tcp_host_packet_free_unsafe(void *payload);
void *tcp_host_packet_start(void *payload);

--------------

nucleus/bam.h: 

struct module;
ENUM_DEF(bam_pool_t);
NULLABLE void *bam_alloc(size_t, struct module *);
void bam_alloc_req(size_t, struct module *);
NULLABLE void *bam_alloc_resp(size_t, bam_pool_t, struct module *);
NULLABLE void *bam_alloc_epcq_cmdlist(struct module *);
void bam_alloc_epcq_cmdlist_req(void);
NULLABLE void *bam_alloc_epcq_cmdlist_resp(struct module *);
NULLABLE void *bam_alloc_epsq_cmdlist(struct module *);
void bam_alloc_epsq_cmdlist_req(void);
NULLABLE void *bam_alloc_epsq_cmdlist_resp(struct module *);
NULLABLE void *bam_alloc_etp_cmdlist(struct module *module);
void bam_alloc_etp_cmdlist_req(void);
NULLABLE void *bam_alloc_etp_cmdlist_resp(struct module *module);
NULLABLE void *bam_alloc_from_pool(bam_pool_t, size_t, struct module *);
NULLABLE void *bam_alloc_in_cluster(size_t, struct module *,bam_pool_t, uint8_t);
void bam_free_gated(void *);
void bam_free_unsafe(void *);
void bam_free(void *);
size_t bam_allocation_size(size_t);
bool bam_is_ptr_bm(void *ptr);
void bam_alloc_tracker_init(void);
void bam_alloc_tracker_dump(void);
NULLABLE CALLER_TO_RELEASE struct fun_json *bam_alloc_tracker_json(void);
bool bam_is_ptr_bam_allocated(void *);

--------------

nucleus/channel.h: 

struct frame;
struct flow;
struct ws_exception;
struct workerpool;
struct module;
struct channel {NULLABLE struct flow *caller_flow; struct frame *frame; uint8_t boxing_state;};
struct channel channel_init(struct frame *);
NULLABLE struct flow *channel_caller_flow(struct channel *);
void channel_set_caller_flow(struct channel *,NULLABLE struct flow *caller_flow);
void *channel_alloca(struct channel *channel, size_t num_bytes_to_reserve)RETURN_ALIGNED(8);
void *channel_zalloca(struct channel *channel, size_t num_bytes_to_reserve)RETURN_ALIGNED(8);
void *channel_alloca_align(struct channel *,size_t size, size_t align, bool clear)RETURN_ALIGNED(8);
void channel_pop_and_send(struct channel *);
void channel_pop_and_send_for_extra_WUs(struct channel *);
void channel_exception_by_wuid_push(struct channel *,wuid_t, faddr_t, uintptr_t arg1);
void channel_raise_exception(struct channel *,struct ws_exception);
void channel_raise_exception_with_errno(struct channel *,enum fun_ret error_code);
struct channel_parall_params;
typedef void *channel_parall_context_t;
typedef bool(*channel_parall_pusher_f)(struct channel *,struct channel_parall_params *,faddr_t, uint32_t index);
struct channel_parall_params {channel_parall_pusher_f sub_push; NULLABLE channel_parall_context_t context; NULLABLE struct workerpool *wp; uint32_t end; uint32_t flags; fun_time_t child_duration_hint; struct stack_frame caller;};
void channel_parall_push(struct channel *,struct channel_parall_params params);
void channel_parallelize_push(struct channel *,uint32_t N, channel_parall_context_t, uint32_t flags, channel_parall_pusher_f sub_push);void channel_parallelize_with_wp_push(struct channel *,uint32_t N, struct workerpool *wp, channel_parall_context_t, uint32_t flags, channel_parall_pusher_f sub_push);
void channel_parall_debug_record_all_rstates(size_t capacity);
void channel_parall_debug_dump_all_rstates(void);
struct channel_serial_params;
typedef void *channel_serial_context_t;
typedef bool(*channel_serial_pusher_f)(struct channel *,struct channel_serial_params *,faddr_t, uint32_t index);
struct channel_serial_params {faddr_t dest; NULLABLE channel_serial_context_t context; uint32_t end; channel_serial_pusher_f sub_push;};
void channel_serial_push(struct channel *,struct channel_serial_params params);
void channel_prepare_for_direct_calls(struct channel *);
struct frame *channel_suspend_frame(struct channel *);
void channel_flow_controlled_ws_alloc_push(struct channel *,enum allocation_policy, OUT struct frame **);
struct flow *channel_allocate_flow_on_stack(struct channel *,struct module *module, uint32_t identifier, faddr_t dest, size_t extra_size);
struct flow *channel_alloc_flow(struct channel *,struct module *module);
struct channel channel_alloc_init_threaded(void);
void channel_flow_barrier_push(struct channel *,struct flow *);
void _channel_wuid_push(struct channel *,wuid_t, faddr_t, uintptr_t arg1, uintptr_t arg2);
void _channel64_wuid_push(struct channel *channel, wuid_t wuid, faddr_t dest, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6);
void _channel_wuid_flow_push(struct channel *,wuid_t, struct flow *,uintptr_t arg2);
void _channel64_wuid_flow_push(struct channel *,wuid_t, struct flow *,uintptr_t arg2, uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6);
void _channel_hw_wuid_push(struct channel *,wuid_t, faddr_t, uintptr_t arg1, uintptr_t arg2);
bool _channel_fork_setup(struct channel *parent, struct frame *frame, OUT struct channel *child, struct frame ***child_framepp);
void _channel_exec_pop_and_block(struct channel *,bool cancel_if_no_activity);
struct channel _channel_init_for_thread(void);
struct channel _channel_init_noextent(struct frame *);
struct channel _channel_init_and_default_flow_threaded(struct module *,char *buf, size_t buf_len);

--------------

nucleus/config.h: 

  
  
extern bool reset_on_halt;
extern bool crash_inst_log;
extern const char *wp_workload;

--------------

nucleus/fabric_address.h: 

typedef uint8_t sntype_t;
   
  
  
  
   
   
   
 
 
   
   
    
   
   
   
   
     
    
   

--------------

nucleus/faddr.h: 

typedef uint32_t faddr_t;
bool faddr_compare(faddr_t, faddr_t);
bool faddr_is_vp(faddr_t faddr);
const char *faddr_human_readable(faddr_t);
faddr_t faddr_vp_to_high_priority(faddr_t);
faddr_t faddr_vp_to_low_priority(faddr_t);
void _assert_faddr_valid(faddr_t faddr, bool invalid_ok);
void _assert_pc_faddr_valid(faddr_t faddr);

--------------

nucleus/fun_privileges.h: 

enum fun_privilege {fun_privilege_superuser =0, fun_privilege_editor, fun_privilege_viewer, fun_privilege_guest, fun_privilege_none};
static inline bool fun_can_access(enum fun_privilege level, enum fun_privilege needed)
 {return level <=needed;}
static inline const char *fun_privilege_string(enum fun_privilege level)
 {switch(level){case fun_privilege_superuser:return"superuser";case fun_privilege_editor:return"editor";case fun_privilege_viewer:return"viewer";case fun_privilege_guest:return"guest";case fun_privilege_none:return"none";default:return"???";}
}

--------------

nucleus/mem_region.h: 

enum mem_region_id {PLATFORM_MEM_REGIONS MEM_REGION_KEY, MEM_REGION_COHERENT_STATIC_POOL, MEM_REGION_NON_COHERENT_STATIC_POOL, MEM_REGION_COHERENT_POOL, MEM_REGION_NON_COHERENT_POOL, MEM_REGION_TASK_PRI_COH, MEM_REGION_TASK_PRI_NONCOH, MEM_REGION_FUN_MTRACKER, MEM_REGION_SDK, MEM_REGION_MAX};
ENUM_DEF(mem_access_rule_t);
struct mem_region {const char *name; void *start; void *end; bool read_only; bool zero_if_ddr; bool private_for_dumps; bool skip_for_leaks; size_t req_size; size_t req_align; enum mem_access_rule_t access_rule;};
void mem_region_bootstrap(void);
void platform_mem_region_bootstrap(void);
void platform_mem_region_config_init(const struct fun_json *);
void platform_mem_region_config_update(void);
void mem_region_heap_bootstrap(void);
void mem_region_fun_heap_bootstrap(void);
void mem_region_noncoh_bootstrap(void);
void mem_region_fun_mtracker_bootstrap(size_t size);
void mem_region_init(void **zbase, size_t *zsize);
void platform_mem_region_init(void **zbase, size_t *zsize);
__attribute((const))
const struct mem_region *mem_region_for_id(enum mem_region_id region_id);
size_t mem_region_size_p(const struct mem_region *mr);
size_t mem_region_size(enum mem_region_id region_id);
void mem_region_init_done(void);
bool mem_region_init_done_check(void);
void mem_region_force_dumpable(enum mem_region_id region_id);
enum mem_region_id mem_region_id_for_region(const struct mem_region *r);
void mem_region_info_dump(void);

--------------

nucleus/module.h: 

struct module;
struct fun_json;
struct hu_fn_params;
struct metaflow_resource_params;
typedef uint16_t module_index_t;
typedef bool(*module_predicate_f)(const struct module *);
struct module *module_named(const char *name);
NULLABLE struct module *module_named_safe(const char *name);
struct module *module_at_index(module_index_t);
module_index_t module_total_count(void);
const char *module_name(const struct module *);
module_index_t module_index(const struct module *);
int module_effective_log_level(const struct module *);
metaflow_res_type_t module_metaflow_resource_type(const struct module *);
struct fun_json *module_config_json(const struct module *);
const struct fun_json *_module_issu_previous_state(struct module *);
const struct fun_json *_module_issu_previous_cfg(struct module *);
void module_issu_set_state(struct fun_json *modcfg, struct fun_json *modstate);
void module_start_push(struct channel *,struct module *);
void module_start_threaded(struct module *);
void module_quiesce_all_push(struct channel *);
bool module_is_started(const struct module *module);
bool module_is_ready(const struct module *);
void module_log_stats(struct module *,bool verbose);
void module_log_all(bool verbose);
bool module_set_log_level(struct module *,int log_level);
void module_effective_log_level_update(void);
void module_print_dependency_tree(struct module *);
extern bool module_log_init;
extern bool module_log_json;
bool module_defines_commands(const struct module *);
bool module_commander_install(struct module *);
bool module_props_bridge_has_install(const struct module *);
bool module_props_bridge_install(struct module *);
void module_metaflow_resource_fill_params(const struct module *,const struct hu_fn_params *params, OUT struct metaflow_resource_params *);
void module_start_all_not_yet_started_matching_push(struct channel *,module_predicate_f);
void module_enumerate_started_module_matching(void *context, module_predicate_f, void(*each)(void *context, struct module *));
struct fun_json *module_boot_config(void);
NORETURN module_note_in_error(struct module *,const char *message);
enum module_state {MODULE_STATE_INITIAL =0, MODULE_STATE_STARTED, MODULE_STATE_STARTING, MODULE_STATE_START_DONE, MODULE_STATE_READY,};
struct modcfg_entry;
typedef void(*module_init_f)(const struct fun_json *config_json);
typedef void(*metaflow_resource_fill_params_f)(const struct hu_fn_params *,OUT struct metaflow_resource_params *);
typedef void(*module_commander_install_f)(void);
typedef void(*module_props_bridge_install_f)(void);
typedef void(*module_config_updated_f)(struct module *);
typedef void(*module_issu_save_state_f)(struct fun_json *);
struct module {const char *name; module_index_t index; const metaflow_res_type_t metaflow_resource_type; NULLABLE metaflow_resource_fill_params_f metaflow_resource_fill_params; struct module **deps; NULLABLE module_props_bridge_install_f props_bridge_install; NULLABLE module_commander_install_f commander_install; NULLABLE module_init_f direct_init; module_config_updated_f json_update_callback; module_issu_save_state_f issu_save; ALIGNED(64)enum module_state state; fun_time_t init_start_time; bool quiesced; bool props_bridge_installed; uint16_t notif_register_reqs_pending; int log_level; int effective_log_level; struct modcfg_entry **modcfg; struct fun_json *config_json;};

--------------

nucleus/nucleus.h: 


--------------

nucleus/refbuf.h: 

struct refbuf_dec_msg {union{struct{uint64_t action; uint64_t arg0;};uint64_t elts[2];};
};
void *refbuf_alloc_32k(void)RETURN_ALIGNED(32*1024);
void *refbuf_alloc_64k(void)RETURN_ALIGNED(64*1024);
void refbuf_inc(void *refbuf, uint8_t amount);
void refbuf_dec(void *refbuf, uint8_t amount);
void refbuf_32k_dec(void *refbuf, uint8_t amount);
void refbuf_64k_dec(void *refbuf, uint8_t amount);
void refbuf_prepare_dec(void *refbuf, uint8_t amount, struct refbuf_dec_msg *msg);
void refbuf_prepare_inc(void *refbuf, uint8_t amount, struct refbuf_dec_msg *msg);
void refbuf_cluster_init(void);
int refbuf_free_count(dam_pool_t dam_pool);
int refbuf_32k_free_count(void);
int refbuf_64k_free_count(void);
int refbuf_32k_pool_size_indices(void);
int refbuf_64k_pool_size_indices(void);
uint32_t refbuf_32k_to_index(void *buf);
uint32_t refbuf_64k_to_index(void *buf);
bool refbuf_addr_valid(dam_pool_t pool, void *ptr);
static inline size_t refbuf_32k_page_size(void) {return REFBUF_SIZE_32K;}
static inline size_t refbuf_64k_page_size(void){return REFBUF_SIZE_64K;}

--------------

nucleus/res_alloc_harden.h: 

void res_alloc_harden_en(bool enable);
NULLABLE struct frame *ws_alloc_harden(void)RETURN_ALIGNED(EXTENT_ALIGN);
uint8_t ws_alloc_multiple_harden(OUT struct frame **,uint8_t);
struct frame *ws_alloc_with_scratch_harden(OUT void **,size_t);
struct frame *ws_alloc_with_callback_harden(ws_free_callback_t, void *);
NULLABLE void *bam_alloc_harden(size_t, struct module *);
NULLABLE void *bam_alloc_epcq_cmdlist_harden(struct module *);
NULLABLE void *bam_alloc_in_cluster_harden(size_t, struct module *,bam_pool_t, bool, uint8_t);
void *refbuf_alloc_32k_harden(void);
void *refbuf_alloc_64k_harden(void);

--------------

nucleus/resource.h: 

void resource_check_random_failure_disable();
void resource_check_random_failure_enable();
void resource_check_req(struct rlevel *,faddr_t);
void bm_pool_resource_check_req(struct rlevel *level, bam_pool_t);
void dam_pool_resource_check_req(struct rlevel *level, int pool);
void ocm_dam_pool_resource_check_req(struct rlevel *level, int pool);
void hbm_dam_pool_resource_check_req(struct rlevel *level, int pool);
void resource_check_req5(struct rlevel *,faddr_t, faddr_t, faddr_t, faddr_t, faddr_t);
static inline void resource_check_multi(struct rlevel *rlevel, unsigned int argc, faddr_t *argv)
 {assert(argc <=RLEVEL_MULTI_COUNT);resource_check_req5(rlevel,(argc >0)?argv[0]:DEST_INVALID,(argc >1)?argv[1]:DEST_INVALID,(argc >2)?argv[2]:DEST_INVALID,(argc >3)?argv[3]:DEST_INVALID,(argc >4)?argv[4]:DEST_INVALID);}
void resource_check_poll(struct rlevel *);
void resource_resched_req(faddr_t, wuid_t, uint64_t);
void resource_check_rindex_req(rindex_t);
void resource_check_rindex_multi_req_prepare(rindex_t, rindex_t, rindex_t, rindex_t, rindex_t, uint64_t out_req[]);
void resource_check_rindex_multi_req_write(const uint64_t req[]);
void resource_check_rindex_multi_req(rindex_t, rindex_t, rindex_t, rindex_t, rindex_t);
rindex_rsp_t resource_check_poll_and_return_result(void);
resource_level_t resource_check_poll_and_return_status0(void);
resource_level_t resource_check(rindex_t);
bool resource_check_safe(rindex_t ridx, OUT resource_level_t *level);
void resource_resched_rindex_req(rindex_t, wuid_t, uint64_t, uint8_t);
void resource_check_faddr_req(faddr_t rsrc);
resource_level_t resource_check_faddr_poll(void);
resource_level_t resource_check_faddr(faddr_t rsrc);
void assert_resource_checks_started(void);

--------------

nucleus/resource_types.h: 

typedef uint64_t rindex_rsp_t;
struct rlevel {uint8_t valid; uint8_t reserved[2];union{uint8_t level; uint8_t levels[RLEVEL_MULTI_COUNT];};
};
ENUM_DEF(resource_level_t);

--------------

nucleus/stack_alloc.h: 

struct wustack_lru {uint16_t first; uint16_t count; uint16_t ids[PER_VP_WUSTACK_CACHE];void *pref_pending_frame;};
void wustack_init(void);
NULLABLE void *wustack_alloc(void);
void wustack_free(void *wustack);
int get_wustack_count(void);
int get_cached_wustack_count(void);
void *get_wustack_by_index(uint32_t i);
int get_wustack_index(void *ptr);
bool is_wustack_addr(void *ptr);
bool wustack_allocated_by_index(uint32_t i);

--------------

nucleus/time.h: 

typedef uint64_t fun_time_t;
fun_time_t fun_time_now(void);
fun_time_t fun_time_since(fun_time_t from);
void busy_loop_until(fun_time_t limit);
void busy_loop_for(fun_time_t duration);
double _duration_scaled(fun_time_t);
const char *_duration_unit(fun_time_t);
struct time1588 {uint32_t secs; uint32_t nsecs;};
struct time1588 time1588_now(void);
static inline fun_time_t fun_time_from_time1588(struct time1588 t) {return(uint64_t)t.secs *NSECS_PER_SEC +(uint64_t)t.nsecs;}
static inline struct time1588 fun_time_to_time1588(fun_time_t nsecs) {uint64_t secs =nsecs /NSECS_PER_SEC; uint64_t rest =nsecs -secs *NSECS_PER_SEC; if(secs >=UINT32_MAX){struct time1588 t ={.secs =UINT32_MAX ,.nsecs =0};return t;}else{struct time1588 t = {.secs =(uint32_t)secs ,.nsecs =(uint32_t)rest};return t;}
}

--------------

nucleus/timer.h: 

typedef uint32_t timerid_t;
static inline uint64_t fun_time_to_delay_ticks(fun_time_t fun_time)
{uint64_t nsecs =FUN_TIME_TO_NSECS(fun_time);uint64_t ticks =NSECS_TO_DELAY_TICKS(nsecs);if(ticks <1){ticks =1;}return ticks;
}
struct timer_arg {bool is_tracing; uint64_t value;};
timerid_t wu_timer_allocate(void);
timerid_t wu_timer_allocate_or_none(void);
enum fun_ret wu_timer_cancel(timerid_t);
void wu_timer_fast_cancel(timerid_t);
enum fun_ret wu_timer_deallocate(timerid_t);
void _wu_timer_start(timerid_t, uint32_t timer_action, faddr_t, struct timer_arg *timer_arg, fun_time_t delay);
enum fun_ret _wu_timer_start_unnatural(timerid_t, uint32_t timer_action, faddr_t, struct timer_arg *timer_arg, fun_time_t delay);
uint32_t wu_timer_get_action_count(void);

--------------

nucleus/topology.h: 

typedef uint8_t cluster_t;
typedef uint8_t core_t;
typedef uint16_t vpnum_t;
struct topo_ccv {cluster_t cluster; core_t core; vpnum_t vp;};
enum ccv_state {ccv_state_invalid =0, ccv_state_offline, ccv_state_online};
void topo_bootstrap(void);
void topo_ccv_online(struct topo_ccv);
bool topo_vpnum_isonline(vpnum_t);
bool topo_ccv_isonline(struct topo_ccv);
bool topo_cluster_isonline(cluster_t);
bool topo_core_isonline(struct topo_ccv);
cluster_t topo_num_clusters_online(void);
vpnum_t topo_cluster_num_vps_online(cluster_t);
vpnum_t topo_vpnum_from_ccv(struct topo_ccv);
vpnum_t topo_vpnum_from_faddr(faddr_t);
cluster_t topo_cluster_from_faddr(faddr_t);
faddr_t topo_faddr_from_vpnum(vpnum_t);
faddr_t topo_faddr_from_ccv(struct topo_ccv);
struct topo_ccv topo_ccv_from_faddr(faddr_t);
struct topo_ccv topo_ccv_from_vpnum(vpnum_t);
core_t topo_corenum_from_ccv(struct topo_ccv);
core_t topo_cluster_core_count(cluster_t);
vpnum_t topo_cluster_vp_count(cluster_t);
uint8_t topo_local_vpnum_from_ccv(struct topo_ccv);
uint32_t topo_ccv_distance(faddr_t, faddr_t);
bool topo_faddr_is_ccv(faddr_t);
struct topo_ccv topo_ccv_first(void);
struct topo_ccv topo_ccv_next(struct topo_ccv);
struct topo_ccv topo_ccv_first_online(void);
struct topo_ccv topo_ccv_next_online(struct topo_ccv);
uint16_t topo_num_vps_online(void);
struct topo_grid {char s[TOPO_GRID_MAX];};
void topo_grid_clear(struct topo_grid *);
void topo_grid_set(struct topo_grid *,struct topo_ccv, char c);
char topo_grid_get(struct topo_grid *,struct topo_ccv);
const char *topo_grid_str(struct topo_grid *);

--------------

nucleus/trace.h: 

bool trace_init(periodic_trigger_f flusher);
void trace_flight_flush_log(void);
extern bool tracing_enabled;
void trace_shutdown_push(struct channel *channel);
void trace_wu_start(uint32_t wuid, faddr_t origin, uint64_t arg0, uint64_t arg1);
LTO_SLOWPATH void trace_wu_send(uint32_t wuid, uint64_t arg0, uint64_t arg1, uint32_t flags, faddr_t dst);
void trace_wu_end(void);
void trace_wu_end_wuid(uint32_t wuid);
void trace_transaction_start(void);
void trace_transaction_annot(const char *fmt, ...);
void trace_timer_start(uint32_t timer_id, wuid_t wuid, faddr_t dest, uint64_t arg0);
enum wu_send_event_flags {TRACE_EVENT_SEND_GATED =(1<<0),TRACE_EVENT_SEND_HW =(1<<1),};
void flush_traces(struct channel *channel, NULLABLE struct flow *flow, void *);

--------------

nucleus/types.h: 

typedef int64_t ssize_t;
typedef uint32_t wuid_t;
struct wu32 {uint64_t action; union{uint64_t arg0; void *frame;};union {uint64_t arg1; void *flow;};union {uint64_t arg2; void *packet;};
};
static_assert(sizeof(struct wu32)==32,"WU is incorrect size");
struct wu64 {uint64_t action; union{uint64_t arg0; void *frame;};union {uint64_t arg1; void *flow;};union {uint64_t arg2; void *packet;};uint64_t arg3; uint64_t arg4; uint64_t arg5; uint64_t arg6;
};
static_assert(sizeof(struct wu64)==64,"WU64 is incorrect size");
struct wu {uint64_t action; union{uint64_t arg0; void *frame;};union {uint64_t arg1; void *flow;};union {uint64_t arg2; void *packet;};
 uint64_t arg3; uint64_t arg4; uint64_t arg5; uint64_t arg6;
};
static_assert(sizeof(struct wu)==sizeof(struct wu64),"WU is incorrect size");
static_assert(sizeof(struct wu)==sizeof(struct wu32),"WU is incorrect size");
struct fun_ptr_and_size {NULLABLE uint8_t *ptr; size_t size;};
struct fun_ptr_size_and_alloc_size {struct fun_ptr_and_size ps; size_t allocated_size;};
typedef enum allocation_policy {allocation_policy_wait =0, allocation_policy_try, allocation_policy_raise,}allocation_policy_t;
typedef uint16_t __be16;
typedef uint32_t __be32;
typedef uint64_t __be64;
typedef uint16_t __le16;
typedef uint32_t __le32;
typedef uint64_t __le64;
struct stack_frame {const void *pc;};
typedef uint8_t metaflow_res_type_t;

--------------

nucleus/vplocal.h: 

struct fun_mcache;
struct fun_recycler;
struct wuthread_state;
struct vplocal_wuthread {struct dispatch_context *dispatch_context; struct frame *thread_frame; struct wuthread_state *ts; fun_time_t dispatch_time;};
struct vplocal_runtime_accum {fun_time_t last_idle_exit; fun_time_t total_runtime; uint64_t shallow_idle_count; uint64_t deep_idle_count;};
struct vplocal_ipc_stats {fun_time_t cycle_count0; uint64_t instruction_count; fun_time_t cycle_count1;};
struct vplocal_exec_stats {uint64_t nwsallocs; uint64_t nwsfrees; uint64_t nforks; uint64_t njoins; uint64_t nflowinit; uint64_t nflowfini; uint64_t nfloweqmrestart; uint64_t nthreadcreat; uint64_t nthreadexit; uint64_t nthreadacts; uint64_t nnopwus;};
struct vplocal_hmon_stats {fun_time_t last_printlock_entry; fun_time_t total_print_time; fun_time_t prev_total_print_time;};
struct vplocal_le_mgmt_stats {uint64_t err_tbl_alloc; uint64_t err_tbl_dealloc; uint64_t err_tbl_dealloc_cluster; uint64_t flush_rsp_cnt; uint64_t las_rsp_cnt; uint64_t fwd_rsp_hit_cnt; uint64_t fwd_rsp_miss_cnt;};
struct vplocal_le_table_stats {uint64_t entry_used; uint64_t entry_add_cnt; uint64_t entry_del_cnt; uint64_t err_cnt_add_space; uint64_t err_cnt_add_dup; uint64_t err_cnt_del_key; uint64_t null_rsp_cnt; uint64_t hit_cnt; uint64_t miss_cnt; uint64_t tbl_clear_cnt;};
struct rdsock_vp_local_ac {uint32_t data_bytes; uint32_t resp_bytes;};
struct vplocal_wurxtx_log {struct wu cbuf[VPLOCAL_RXTX_CBUF_DEPTH];fun_time_t timestamps[VPLOCAL_RXTX_CBUF_DEPTH];bool gated_flags[VPLOCAL_RXTX_CBUF_DEPTH];uint32_t head;};
struct fiu_sim {int rxwu_valid; struct wu rxwu[2];};
struct vplocal_res_harden_counters {uint16_t count; uint16_t fail;};
enum vplocal_res_type {RES_WS_STACK, RES_BAM, RES_REFBUF, MAX_RES};
struct refbuf_share {void *buf; uint8_t unit; bool initialized;};
struct trace_record_state {bool page_allocated; void *current_record;};
struct epsq_f_q {void *epsq_f; TAILQ_ENTRY(epsq_f_q)queue;};
struct vplocal
 {faddr_t faddr; rindex_t faddr_ridx; vpnum_t vpnum; struct vplocal_wuthread wuthread; struct fun_mcache *malloc_caches[2];struct fun_recycler *recyclers[VPLOCAL_NUM_RECYCLERS];struct fun_mbuf_cache *mbuf_caches[VPLOCAL_FUN_MBUF_NUM_CACHES];uint64_t mbuf_stats[VPLOCAL_FUN_MBUF_LAST_MEM_TYPE][VPLOCAL_FUN_MBUF_PER_MEM_TYPE_LAST];union{struct{bool debug_wu_txlog; bool is_tracing;};uint32_t tx_tracing_flags;};bool trace_paused;
 bool in_wu_handler;
 uint64_t rand_state[2];struct wustack_lru wustack_lru; uint64_t idle_watcher_seq_num; fun_time_t vp_idle_start; timerid_t vp_idle_timer; uint64_t *wake_counts; struct vplocal_runtime_accum runtime_accum; struct vplocal_exec_stats exec_stats; struct vplocal_ipc_stats funtop_ipc_stats; struct vplocal_le_mgmt_stats le_mgt_stats; struct vplocal_le_table_stats le_tbl_stats[VPLOCAL_LE_MAX_LOGICAL_TBL];struct vplocal_hmon_stats hmon_stats; struct {void *fwd;}ctr_base; struct {uint64_t outstanding; uint32_t num_ac_on; uint32_t num_ac_off; bool is_ac_on; bool is_pending_queue_initialized; TAILQ_HEAD(epsq_f_pending_q, epsq_f_q)epsq_f_pending_q;}epsq_ac; struct {uint32_t ew_target_connections; uint32_t target_connections; uint32_t initiator_connections;}rdsock_stats; struct rdsock_vp_local_ac rdsock_vp_ac; struct refbuf_share rdsock_share;
 struct fiu_sim fiu; struct rlevel level;
 uint16_t perf_sample_countdown; uint32_t perf_sample_seed; struct trace_record_state trace_state; struct vplocal_wurxtx_log rx_log; struct vplocal_wurxtx_log tx_log; struct wu trace_current_wu;
 struct vplocal_res_harden_counters counters[MAX_RES];
 uint64_t hsm_refcnt_upd_sn_msg[2];
 uint64_t cc_dam_refcnt_dec_sn_msg[2];
};
static inline faddr_t vplocal_faddr(void)
 {return vplocal()->faddr;}
static inline rindex_t vplocal_faddr_ridx(void)
{assert(vplocal()->faddr_ridx !=RID_INVALID);return vplocal()->faddr_ridx;
}
static inline vpnum_t vplocal_vpnum(void)
{return vplocal()->vpnum;
}
static inline cluster_t vplocal_my_cluster(void)
{return FADDR_GET_GID(vplocal_faddr());
}
static inline void *
vplocal_ctr_base_fwd(void)
{return vplocal()->ctr_base.fwd;
}
void vp_ctr_base_fwd_set(vpnum_t vpnum, void *fwd);
static inline uint64_t vplocal_epsq_outstanding(void)
{return vplocal()->epsq_ac.outstanding;
}
static inline void vplocal_increment_epsq_outstanding(uint64_t val)
{vplocal()->epsq_ac.outstanding +=val;
}
static inline uint64_t vplocal_decrement_epsq_outstanding(uint64_t val)
{vplocal()->epsq_ac.outstanding -=val; return vplocal()->epsq_ac.outstanding;
}
static inline void vplocal_set_epsq_ac_on()
{vplocal()->epsq_ac.is_ac_on =true; vplocal()->epsq_ac.num_ac_on++;
}
static inline void vplocal_set_epsq_ac_off()
{vplocal()->epsq_ac.is_ac_on =false; vplocal()->epsq_ac.num_ac_off++;
}
static inline bool vplocal_epsq_is_ac_on()
{return vplocal()->epsq_ac.is_ac_on;
}
static inline bool vplocal_is_pending_queue_initialized()
{return vplocal()->epsq_ac.is_pending_queue_initialized;
}
static inline void vplocal_set_pending_queue_initialized()
{vplocal()->epsq_ac.is_pending_queue_initialized =true;
}
static inline struct epsq_f_pending_q*vplocal_get_epsq_pending_q()
 {return &vplocal()->epsq_ac.epsq_f_pending_q;}
static inline void vplocal_increment_ew_target_connections()
{vplocal()->rdsock_stats.ew_target_connections++;
}
static inline void vplocal_increment_target_connections()
{vplocal()->rdsock_stats.target_connections++;
}
static inline void vplocal_increment_initiator_connections()
{vplocal()->rdsock_stats.initiator_connections++;
}
extern PER_VP char _per_vp_other_vp_anchor;
extern char *_per_vp_other_vp_base[];
bool per_vp_ptr_validate(void *p);

--------------

nucleus/workerpool.h: 

struct workerpool {uint16_t size; uint16_t count; uint32_t flags; uint32_t next; faddr_t workers[];};
struct workerpool_attributes {const char *name; struct workerpool *pool;};
void wp_bootstrap(void);
faddr_t wp_get_any(struct workerpool *wp);
faddr_t wp_get(struct workerpool *wp, uint32_t i);
faddr_t wp_get_wrapped(struct workerpool *wp, uint32_t i);
faddr_t wp_try_get_in_affinity(struct workerpool *,faddr_t affinity_vp);
void wp_print_workers(struct workerpool *wp);
void wp_print_topology(struct workerpool *pool, NULLABLE const char *header);
void wp_print_affinity_hierarchy(void);
struct workerpool *wp_dyn_init(void *buf, uint16_t nworkers, struct workerpool *wp_src);
void wp_field_init(struct workerpool *wp, uint16_t nworkers, struct workerpool *wp_src);
WORKERPOOL_REFERENCE(wp_control_pool);
WORKERPOOL_REFERENCE(wp_data_pool);
WORKERPOOL_REFERENCE(wp_benchmark_pool);
faddr_t wp_get_any_from_cluster(cluster_t);
faddr_t wp_get_any_local(void);
faddr_t wp_find_other_dest(void);
WORKERPOOL_REFERENCE(wp_all_pool);
WORKERPOOL_REFERENCE(wp_all_pc_pool);
struct workerpool *wp_random_cluster_pool(void);
cluster_t wp_zip_random_cluster();
faddr_t wp_find_hu(void);
faddr_t wp_find_nu(uint8_t instance, uint16_t queue);
faddr_t wp_find_hnu(uint8_t instance, uint16_t queue);
faddr_t wp_find_le(void);
faddr_t wp_find_bam(uint8_t);
faddr_t wp_find_pc_dma_by_cluster(cluster_t);
faddr_t wp_find_pc_dma_by_cluster_or_next_online(cluster_t cluster);
faddr_t wp_find_pc_dma(void);
faddr_t wp_find_pc_dma_random(void);
faddr_t wp_find_hu_dma(uint8_t gid, uint16_t queue);
faddr_t wp_find_sbp(void);
faddr_t wp_find_zip(uint8_t);
faddr_t wp_find_zip_faddr(cluster_t, uint8_t);
faddr_t wp_find_rgx(uint8_t);
bool wp_cluster_has_le(cluster_t);
bool wp_is_initialized(struct workerpool *);
bool wp_dispatch_loop_switch(const struct workerpool *pool, const char *dispatch_loop_name);
uint16_t wp_count_for_cluster(const struct workerpool *,cluster_t);
uint64_t wp_hash(const struct workerpool *);
bool wp_is_equal(const struct workerpool *,const struct workerpool *);
bool wp_is_in_pool(const struct workerpool *,faddr_t);
struct workerpool *wp_data_vps_per_cluster(cluster_t);
struct workerpool *wp_data_pool_per_cluster(cluster_t);
struct workerpool *wp_all_data_vps_on_this_cluster_excluding_here(void);
struct workerpool *wp_byname(const char *name);

--------------

nucleus/workerpool_internal.h: 

struct workerpool;
struct workerpool_attributes;
extern struct workerpool_attributes *wp_workerpool_list;
void wp_policy_apply(void);
void wp_policy_apply_json(void);
bool wp_policy_sort(struct workerpool *wp, const char *wp_sort_name);
void affinity_tag_vp(struct topo_ccv ccv, uint64_t tag);
void wp_construct(const char *name, struct workerpool *wp, struct workerpool *src);
bool wp_affinity_match_cluster(cluster_t, const char *affinity);
bool wp_affinity_match_core(struct topo_ccv, const char *affinity);
bool wp_affinity_match_vp(struct topo_ccv, const char *affinity);

--------------

nucleus/wu.h: 

extern const uint64_t sn_vc_wul;
extern const uint64_t sn_vc_wuh;
uint32_t wu_get_handler_count(void);
void _wu_send_raw_by_struct(const struct wu *wu, uint64_t sn_hdr);
void _wu_send32_raw_by_struct(const struct wu32 *wu, uint64_t sn_hdr);
void _wu_send64_raw_by_struct(const struct wu *wu, uint64_t sn_hdr);
void _wu_send64_ungated_raw_by_struct(const struct wu *wu, uint64_t sn_hdr);
void wu_send_by_ptr_align16(const struct wu *wu);
void wu_send_by_ptr_ungated_align16(const struct wu *wu);
void wu_send_ungated_batch_align16(uint16_t n, const struct wu *wus);
void wu_send_low_ungated_batch_align16(uint16_t n, const struct wu *wus);
void wu_send_by_words(uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2);
void wu_send_high_by_words(uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2);
void wu_send_low_by_words(uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2);
wuid_t wu_find_by_name(const char *);
const char *try_wu_get_name(wuid_t);
const char *try_wu_get_name_or_default(wuid_t, const char *);
const char *wuid_to_name(wuid_t);
const struct wu_attributes *wuid_to_attributes(wuid_t id);
wu_handler_t wuid_to_handler(wuid_t id);
wu_handler_t wuid_to_handler_default(wuid_t id);
void wu_flush_gated_unsafe(void);
void wu_flush_gated_if_wul(uint32_t lwm, bool is_l1b_flush);
wuid_t wu_wuid_fixup(uint64_t action, uint64_t arg0);
wuid_t wu_wuid_fixup_bugcheck(uint64_t action, uint64_t arg0);
uint64_t wu_global_credit_count(void);
void wu_watchdog_disable(void);
void wu_watchdog_reenable(void);
void _wu_watchdog_assert_enabled(void);
void _wu_watchdog_assert_disabled(void);
static inline void wu_watchdog_assert_enabled(void)
 { _wu_watchdog_assert_enabled(); }
static inline void wu_watchdog_assert_disabled(void)
{
 _wu_watchdog_assert_disabled();
}
void wu_watchdog_reset_test(int test_mode);
const char *wu_dispatch_get_pc_debug_status(uint64_t pc);
uint64_t wu_debug_get_last_action(void);
void wu_debug_print_last_action(void);
void _wu_send_raw(wuid_t wuid, unsigned int type, unsigned int order, unsigned int vc, faddr_t dest, uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2);
void _wu_send64_raw(wuid_t wuid, unsigned int type, unsigned int order, unsigned int vc, faddr_t dest, uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6);
void _wu_send_ungated_raw(wuid_t wuid, unsigned int type, unsigned int order, unsigned int vc, faddr_t dest, uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2);
void _wu_send64_ungated_raw(wuid_t wuid, unsigned int type, unsigned int order, unsigned int vc, faddr_t dest, uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6);
void _wu_send_ungated_raw_nobarrier_unsafe(wuid_t wuid, unsigned int type, unsigned int order, unsigned int vc, faddr_t dest, uint64_t arg0, uint64_t arg1, uint64_t arg2);
void _assert_wu_action_valid(uint64_t action);
void wu_decode(uint64_t *buf, size_t num_words);

--------------

nucleus/wu_attributes.h: 

struct module;
typedef void(*wu_handler_t)(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t action, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6);
typedef void(*wu_handler_t)(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t action);
struct wu_attributes {struct module *module; const char *name; uint32_t attrs; wuid_t wuid; wu_handler_t handler;};

--------------

nucleus/wu_register.h: 

struct wuthread_state;

--------------

nucleus/wu_types.h: 

typedef uint8_t hsuid_t;
typedef uint8_t ctlid_t;
typedef uint64_t notification_ticket_t;
typedef NULLABLE uintptr_t notification_subject_t;
struct channel;
typedef void(*dpcserver_tx_push_f)(struct channel *,const struct fun_ptr_and_size ,void * ,int *retval);

--------------

nucleus/wustack.h: 

struct ws_exception;
struct frame;
struct _frame
 {struct wu return_wu; uintptr_t slots[0];};
void ws_send_continuation(struct frame *);
void
ws_peek_continuation(struct frame *frame, uintptr_t *arg0, uintptr_t *arg1, uintptr_t *arg2, faddr_t *dest);
struct frame *MUST_CHECK
_ws_push_continuation(wuid_t wuid, faddr_t dest, struct frame *frame, uintptr_t arg1, uintptr_t arg2);
struct frame *MUST_CHECK
_ws_push_continuation64(wuid_t wuid, faddr_t dest, struct frame *on_frame, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6);
struct frame *MUST_CHECK
_ws_push_continuation_by_words_noex(uint64_t action, struct frame *frame, uintptr_t arg1, uintptr_t arg2);
struct frame *MUST_CHECK
_ws_push_continuation64_by_words_noex(uint64_t action, struct frame *colder_frame, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6);
uint64_t ws_set_action_template(uint64_t action);
struct foreign_frame;
struct foreign_frame *MUST_CHECK
ws_prepare_foreign_frame(void *buf, wuid_t wuid, faddr_t dest, struct frame *frame, uint64_t arg1, uint64_t arg2);
struct frame *MUST_CHECK
ws_push_foreign_frame(wuid_t wuid, faddr_t dest, struct frame *frame, uint64_t arg0, uint64_t arg1, uint64_t arg2);
struct frame *MUST_CHECK
ws_push_nop_continuation(struct frame *)RETURN_ALIGNED(EXTENT_ALIGN);
struct frame *MUST_CHECK
ws_push_nop_continuation_with_dest(struct frame *frame, faddr_t dest)RETURN_ALIGNED(EXTENT_ALIGN);
struct frame *MUST_CHECK ws_push_copy_colder(struct frame *frame)RETURN_ALIGNED(EXTENT_ALIGN);
NULLABLE struct frame *ws_alloc(void)RETURN_ALIGNED(EXTENT_ALIGN);
NULLABLE struct frame *ws_alloc_long_lived(void)RETURN_ALIGNED(EXTENT_ALIGN);
typedef void(*ws_free_callback_t)(struct frame *frame, NULLABLE struct ws_exception *,void *cookie);
struct frame *ws_alloc_with_callback(ws_free_callback_t callback, void *cookie);
void ws_free_stack_bottom_private(struct frame *);
uint8_t ws_alloc_multiple(OUT struct frame **,uint8_t num_wanted);
struct frame *MUST_CHECK ws_set_buf2ws(void *);
struct frame *MUST_CHECK
ws_set_extent(struct frame *,uint32_t nwords);
static inline bool is_extent(struct frame *frame)
 {bool extent_exists =(uint64_t)(frame)&EXTENT_MASK; return extent_exists;}
void *ws_set_extent_size(INOUT struct frame **,size_t)RETURN_ALIGNED(8);
void *ws_set_extent_size_and_copy_colder_noex(struct frame **frame, size_t size);
void *ws_set_extent_size_with_alignment(INOUT struct frame **,size_t size, size_t align)RETURN_ALIGNED(8);
struct frame *ws_alloc_with_scratch(OUT void **ptr, size_t size);
void *
ws_set_extent_size_and_zero(struct frame **frame, size_t size);
struct frame *MUST_CHECK
_ws_push_exception_continuation(wuid_t wuid, faddr_t dest, struct frame *frame, uintptr_t arg1);
struct ws_exception {const char *message; struct stack_frame raised_by; uint32_t error_code; uint32_t type; uintptr_t custom;};
static_assert(sizeof(struct ws_exception)==32,"*** Incorrect size for exception");
void ws_raise_exception(struct frame *,struct ws_exception);
struct ws_exception exception_with_errno(const char *message, enum fun_ret);
struct ws_exception exception_generic(const char *message);
struct frame *ws_get_hotter(struct frame *);
struct frame *ws_get_colder(struct frame *,uint32_t depth);
struct frame_q {struct wu continuation; TAILQ_ENTRY(frame_q)queue;};
static inline struct frame *ws_queue_to_frame(struct frame_q *frame_q)
 {return ws_get_colder((struct frame *)frame_q, 0);}
static inline struct frame_q *
ws_push_continuation_frame_q(struct frame *frame, struct wu *wu)
 {frame =ws_push_continuation(WU_GET_ID(*wu),WU_GET_DEST(*wu),frame, wu->arg1, wu->arg2);return(struct frame_q *)frame;}
static inline uint64_t frame_to_paddr(struct frame *frame)
 {uint64_t addr =(uint64_t)frame; assert((addr & ~PADDR_MASK)==0);return addr;}
static inline uint64_t frame_to_paddr(struct frame *frame)
 {return va_to_pa((vaddr_t)frame);}
static inline struct frame *paddr_to_frame(uint64_t pa, bool paddr_in_wustack)
 { assert((pa & ~PADDR_MASK)==0);return(struct frame *)pa; return(struct frame *)paddr_to_vaddr(pa, paddr_in_wustack); }
void ws_get_statistics(OUT uint64_t *num_ws_in_use);
void ws_coldtrace(struct frame *);
void ws_hottrace(struct frame *);
void ws_hottrace_no_addr_check(struct frame *);
void ws_hottrace_all(void);
uint64_t ws_debug_num_allocated_stacks(void);
void ws_debug_park(struct frame *frame);
void ws_debug_unpark(struct frame *frame);
enum wsdepth_tag ws_set_depth_tag_if_tracked(struct frame *frame, enum wsdepth_tag new_tag, bool overwrite);
enum wsdepth_tag ws_set_depth_tag_if_tracked_threaded(enum wsdepth_tag new_tag, bool overwrite);
struct frame *ws_get_hotter_if_room(struct frame *,size_t min_space);
void ws_depth_chain_stacks(struct frame *base, struct frame *new);
size_t ws_get_max_depth_if_tracked(struct frame *frame, NULLABLE enum wsdepth_tag *tag);

--------------

nucleus/wuthread.h: 

struct wuthread_sidecar_buf;
struct wuthread_state;
typedef void(*wu_thread_entry_t)(struct frame *frame, uint64_t arg1, uint64_t arg2, uint64_t action);
typedef void(*wu_thread64_entry_t)(struct frame *frame, uint64_t arg1, uint64_t arg2, uint64_t action, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6);
void wuthread_reactivate_func(struct frame *frame, struct wuthread_state *ts);
void wuthread_create(wu_thread_entry_t, struct frame *,uint64_t arg1, uint64_t arg2, uint64_t action, wuid_t reactivate_id);
void wuthread64_create(wu_thread64_entry_t entry, struct frame *oframe, uint64_t arg1, uint64_t arg2, uint64_t action, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6, wuid_t restart_id);
void wuthread_yield(void);
void wuthread_yield_on_timeslice(void);
faddr_t wuthread_hop(faddr_t new_vp);
void wuthread_sleep(fun_time_t duration);
bool wuthread_loop_until(fun_time_t min_duration, fun_time_t max_duration, uint8_t percent_increase, bool(*predicate)(void *context),void *context);
struct frame **wuthread_wpc_prepare(void);
void wuthread_block_for_wpc(void);
void wuthread_cancel_wpc(void);
bool wuthread_watchdog_enable(void);
bool wuthread_watchdog_disable(void);
bool wuthread_watchdog_set_enabled(bool);
wuid_t wuthread_wuid_fixup(uint64_t action, uint64_t arg0);
static inline void assert_is_threaded(void)
 {assert(vplocal()->wuthread.thread_frame !=NULL);}
size_t wuthread_sidecar_size(void);
struct wuthread_sidecar_buf *wuthread_sidecar_get(void);
void wuthread_sidecar_create(struct wuthread_sidecar_buf *);
void wuthread_sidecar_destroy(struct wuthread_sidecar_buf *);
static inline bool is_threaded(void)
 {return posix_has_vplocal()&&(vplocal()->wuthread.dispatch_context !=NULL);}
static inline bool is_threaded(void)
{return vplocal()->wuthread.dispatch_context !=NULL;
}

--------------

platform/include/bsd/strlcat.h: 

static inline size_t strlcpy(char *dst, const char *src, size_t dstlen)
{size_t needed =0; while(needed <dstlen &&(dst[needed]=src[needed]))needed++;while(src[needed++]);if(needed >dstlen &&dstlen)dst[dstlen -1]=0; return needed;
}
static inline size_t strlcat(char *dst, const char *src, size_t dstlen)
{size_t needed =0; size_t j =0; while(dst[needed])needed++;while(needed <dstlen &&(dst[needed]=src[j]))needed++,j++;while(src[j++])needed++;needed++;if(needed >dstlen &&dstlen)dst[dstlen -1]=0; return needed;
}

--------------

platform/include/platform/abort.h: 


--------------

platform/include/platform/align_copy.h: 

static inline void align8_copy(void *dst, const void *src, size_t len)
{assert((uint64_t)dst %8==0);assert((uint64_t)src %8==0);assert(len !=0&&len %8==0);memcpy(dst, src, len);
}
static inline void align16_copy(void *dst, const void *src, size_t len)
{assert((uint64_t)dst %16==0);assert((uint64_t)src %16==0);assert(len !=0&&len %16==0);memcpy(dst, src, len);
}
static inline void align16_copy64(void *dst, const void *src, size_t len)
{assert((uint64_t)dst %16==0);assert((uint64_t)src %16==0);assert(len !=0&&len %64==0);memcpy(dst, src, len);
}

--------------

platform/include/platform/cache_size.h: 

struct cache_line {union{uint64_t u64; uint32_t u32; uint16_t u16; uint8_t u8; uint64_t words[CACHE_LINE_SIZE /sizeof(uint64_t)];};
}ALIGNED(CACHE_LINE_SIZE);

--------------

platform/include/platform/cpu_cache.h: 

void cpu_cache_writeback_invalidate_data(void *address);
void cpu_cache_writeback_invalidate_l1d_wmb(void *address);
void cpu_cache_writeback_invalidate_random(void);
void non_coherent_cache_write_back_wait(void);
void prefetch_coherent_memory(volatile void *coherent_mem);
void prefetch_non_coherent_memory(volatile void *non_coherent_mem, uint32_t cache_lines);
void non_coherent_memory_sync(volatile void *mem, uint32_t cache_lines);
void non_coherent_memory_cache_allocate(volatile void *mem, uint32_t cache_lines);
void prefetch_coherent_memory_for_load_to_l2(volatile void *mem);
void prefetch_coherent_memory_for_store_to_l2(volatile void *mem);
void non_coherent_memory_zero_align64(volatile void *mem, size_t nbytes);
void check_cache_error_exception(void);
void notify_cache_error(void);
extern volatile uint64_t cache_exceptions_processed;

--------------

platform/include/platform/fiu_ia.h: 

enum fiu_ia_op {FIU_IA_OP_NOOP =0, FIU_IA_OP_POPCNT =1, FIU_IA_OP_ROTHASH =2, FIU_IA_OP_PRLCMP =3, FIU_IA_OP_CRC32 =4, FIU_IA_OP_CRC32C =5, FIU_IA_OP_TOEPLITZ =6, FIU_IA_OP_UNUSED =7,};
struct fun_nu_n2p_hdr;
uint64_t fiu_ia_crc(enum fiu_ia_op op, uint64_t seed, const void *input, size_t sz);
uint64_t fiu_ia_crc_n2p_4tuple(enum fiu_ia_op op, uint64_t seed, const struct fun_nu_n2p_hdr *n2p, bool is_v6);
uint32_t fiu_ia_crc32_roce_hdr(uint64_t seed, const void *hdr, uint32_t len);
uint64_t fiu_ia_crc_as_hash(enum fiu_ia_op op, uint64_t seed, const void *input, size_t sz);
uint64_t fiu_ia_rothash(uint64_t input);
uint64_t fiu_ia_crc_rothash(enum fiu_ia_op op, uint64_t seed, const void *input, size_t sz, uint16_t *crc16);
uint64_t fiu_ia_prlcmp(uint16_t a, uint16_t b, const void *value, size_t sz);
uint64_t fiu_ia_popcnt(uint64_t value);
uint32_t fiu_ia_toeplitz(const void *key, size_t ksz, const void *data, size_t dsz, uint32_t seed);
uint32_t fiu_ia_toeplitz_n2p_4tuple(const void *key, size_t ksz, const struct fun_nu_n2p_hdr *n2p, uint32_t seed, bool is_v6);

--------------

platform/include/platform/linker_magic.h: 


--------------

platform/include/platform/linker_magic_internal.h: 


--------------

platform/include/platform/lock.h: 

static inline void
spinlock_init(spinlock_t *lock)
{pthread_mutex_init(lock, NULL);
}
static inline void
spinlock_lock(spinlock_t *lock)
{pthread_mutex_lock(lock);
}
static inline void
spinlock_unlock(spinlock_t *lock)
{pthread_mutex_unlock(lock);
}
typedef union {uint64_t lock_v; struct{uint32_t ticket; uint16_t now_serving; uint16_t contested;};
}spinlock_t;
static_assert(sizeof(spinlock_t)==8,"Wrong spinlock_t size");
static_assert_offset(spinlock_t, ticket, 0);
static_assert_offset(spinlock_t, now_serving, 4);
static_assert_offset(spinlock_t, contested, 6);
void mips_spinlock_lock(spinlock_t *);
bool mips_spinlock_trylock(spinlock_t *);
void mips_spinlock_unlock(spinlock_t *);
static inline void
spinlock_init(spinlock_t *lock)
{lock->lock_v =0;
}
static inline void
spinlock_lock(spinlock_t *lock)
{
 uint32_t tix =__atomic_fetch_add(&lock->ticket, 1, __ATOMIC_ACQUIRE);uint16_t ns; for(;;){ns =__atomic_load_n(&lock->now_serving, __ATOMIC_ACQUIRE);if(ns ==(uint16_t)tix)break; sched_yield();}
 mips_spinlock_lock(lock);
}
static inline bool
spinlock_trylock(spinlock_t *lock)
{
 spinlock_t locked_v; uint64_t current_v =__atomic_load_n(&lock->lock_v, __ATOMIC_ACQUIRE);locked_v.lock_v =current_v; if((uint16_t)locked_v.ticket !=locked_v.now_serving)return false; locked_v.ticket +=1; return __atomic_compare_exchange_n(&lock->lock_v, &current_v, locked_v.lock_v, true, __ATOMIC_ACQUIRE, __ATOMIC_RELAXED);
 return mips_spinlock_trylock(lock);
}
static inline void
assert_spinlock_locked(const spinlock_t *lock)
{spinlock_t current_v MAYBE_UNUSED; assert((current_v.lock_v =__atomic_load_n(&lock->lock_v, __ATOMIC_RELAXED),(uint16_t)current_v.ticket !=current_v.now_serving));
}
static inline void
assert_spinlock_unlocked(const spinlock_t *lock)
{spinlock_t current_v MAYBE_UNUSED; assert((current_v.lock_v =__atomic_load_n(&lock->lock_v, __ATOMIC_RELAXED),(uint16_t)current_v.ticket ==current_v.now_serving));
}
static inline void
spinlock_unlock(spinlock_t *lock)
{assert_spinlock_locked(lock);
 uint64_t ns =__atomic_load_n(&lock->now_serving, __ATOMIC_RELAXED);__atomic_store_n(&lock->now_serving, ns +1, __ATOMIC_RELEASE);
 mips_spinlock_unlock(lock);
}
static inline void fun_platform_lock_init(fun_platform_lock_t *l)
{pthread_mutex_init(l, NULL);
}

--------------

platform/include/platform/mem_region_platform.h: 


--------------

platform/include/platform/mm.h: 


--------------

platform/include/platform/platform.h: 

uint64_t platform_gettime_nsecs(void);
uint64_t platform_get_wct_adjustment(void);
void platform_vp_idle(void);
void platform_terminate_begin(void);
void *malloc_bigly(size_t size);
void free_bigly(void *ptr, size_t size);
void platform_init_heap(void *heap_start, size_t heap_size);
size_t platform_get_heap_size(void);
void platform_broadcast_vp_very_late_init(void);
void *platform_early_alloc_try(size_t);
void *platform_early_calloc_try(size_t);
void *platform_early_alloc_end(void);
void platform_early_alloc_done(void);
enum {WAKE_REASON_SPURIOUS =0, WAKE_REASON_WU, WAKE_REASON_INTERRUPT, WAKE_REASON_COUNT,};
uint64_t *platform_get_wake_counts(void);
uint64_t *platform_get_wake_counts_other(vpnum_t vpnum);
int vp_wake_reason(void);
fun_time_t platform_first_wct(void);
bool posix_has_vplocal(void);
struct fun_json;
CALLER_TO_RELEASE struct fun_json *posix_csr_replay_from_sdk(void);
bool platform_vp_wu_dispatch_loop_switch(faddr_t dest_vp, const char *dispatch_loop_name);
bool platform_cluster_wu_dispatch_loop_switch(cluster_t, const char *dispatch_loop_name);
void platform_find_config(void **cfg_addr, OUT size_t *cfg_size);
void assert_platform_valid_wustack_vp(void);
void platform_shutdown_debug_puts(const char *msg);
extern const char *platform_SDK_version;
extern const char *platform_branch_version;
extern const char *build_date_time;
struct platform_release_version {uint8_t major; uint8_t minor; uint8_t patch;};
static inline struct platform_release_version platform_get_release_version(void)
 {struct platform_release_version vn ={.major =6,.minor =0,.patch =0};return vn;
}

--------------

platform/include/platform/popcount.h: 

static inline uint64_t popcount(uint64_t num)
{
 v2i64 num_vec ={num, num};return __msa_copy_u_d(__msa_pcnt_d(num_vec),0);
 return __builtin_popcountl(num);
}
uint64_t _popcount16(const uint64_t *ptr, const uint64_t *end);
static inline uint64_t popcount16(const uint64_t *array_mem, size_t size)
{assert(size !=0&&size %16==0);return _popcount16(array_mem, &array_mem[size/8]);
}

--------------

platform/include/platform/stack_size.h: 


--------------

platform/include/platform/sym.h: 

struct func_sym {uint64_t start_pc; uint64_t length; const char *name;};
MUST_CHECK bool pc_to_function(uint64_t pc, OUT struct func_sym *);
MUST_CHECK bool pc_to_function_cached(uint64_t pc, OUT struct func_sym *);
static inline void pc_to_string(uint64_t pc, OUT char *buf, size_t buf_len)
 {struct func_sym sym; assert(buf_len !=0);if(pc_to_function_cached(pc, &sym)){snprintf(buf, buf_len,"%s+%"PRId64, sym.name, pc -sym.start_pc);}else{snprintf(buf, buf_len,"%p",(void *)(uintptr_t)pc);}
}
void init_func_sym(void);
struct func_sym_entry {uint64_t start_pc; uint32_t length; uint32_t name_offset;};
extern struct func_sym_entry *_func_array;
extern uint32_t _func_count;
__attribute__((pure))
struct func_sym _func_sym_by_index(uint64_t index);

--------------

platform/include/platform/thread.h: 

void begin_thread_execution(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, void *stack, void *fn, struct dispatch_context *dispatch_context);
void begin_thread64_execution(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6, uint64_t arg7, void *stack, void *fn, struct dispatch_context *dispatch_context);
void switch_to_thread(struct dispatch_context *dispatch_context, struct thread_context *thread_context);
void switch_to_dispatch(struct thread_context *thread_context, struct dispatch_context *dispatch_context);
void end_thread_execution(struct dispatch_context *dispatch_context);

--------------

platform/include/platform/utils_platform.h: 

void platform_snooze(void);
extern const char *platform_SDK_version;
extern const char *platform_branch_version;

--------------

platform/include/platform/vplocal_platform.h: 

struct vplocal *vplocal_other(faddr_t vpaddr);

--------------

platform/mips64/abort_mips64.h: 

void _abort(const char *str);
void _abort_vmsg(const char *fmt, va_list ap);
void _abort_msg(const char *fmt, ...);
void _assert_vmsg(const char *fmt, va_list ap);
void _assert_msg(const char *fmt, ...);
extern int debug_test_recursive_assert_level;
extern int debug_test_failure_in_printf;
void assert_not_bug_check(void);
void BUG_ON_BUG_CHECK(void);

--------------

platform/mips64/bug_check.h: 

typedef bool(*bug_check_handler_t)(uintptr_t user_data, uint64_t source_pc, uint64_t regs[32]);
void register_bug_check_handler(bug_check_handler_t handler, uintptr_t user_data);
void unregister_bug_check_handler(bug_check_handler_t handler);
void print_stack_trace_context(uint64_t epc, uint64_t *ctx);
void print_regs(uint64_t *regs);
bool try_get_frame(uint64_t pc, struct func_sym *func, int16_t *frame_size, int16_t *s8_offset, int16_t *ra_offset, bool *is_s8_frame, bool print_errors);
void bug_check_fast_restart(void);
void bug_check_fast_abort(char *errmsg);
void bug_check_intr_enable(void);

--------------

platform/mips64/cache_size_mips64.h: 


--------------

platform/mips64/cp0.h: 

DEFINE_CP0_REG32("$0,0",cp0_index_read, cp0_index_write);
DEFINE_CP0_REG64("$2,0",cp0_entrylo0_read, cp0_entrylo0_write);
DEFINE_CP0_REG64("$3,0",cp0_entrylo1_read, cp0_entrylo1_write);
DEFINE_CP0_REG32("$3,1",cp0_globalnumber_read, cp0_globalnumber_write);
DEFINE_CP0_REG64("$4,2",cp0_userlocal_read, cp0_userlocal_write);
DEFINE_CP0_REG32("$4,5",cp0_memorymapid_read, cp0_memorymapid_write);
DEFINE_CP0_REG64("$5,0",cp0_pagemask_read, cp0_pagemask_write);
DEFINE_CP0_REG32("$5,1",cp0_pagegrain_read, cp0_pagegrain_write);
DEFINE_CP0_REG32("$6,0",cp0_wired_read, cp0_wired_write);
DEFINE_CP0_REG32("$7,0",cp0_hwrena_read, cp0_hwrena_write);
DEFINE_CP0_REG64("$8,0",cp0_badvaddr_read, cp0_badvaddr_write);
DEFINE_CP0_REG32("$8,1",cp0_badinstr_read, cp0_badinstr_write);
DEFINE_CP0_REG32("$8,2",cp0_badinstrp_read, cp0_badinstrp_write);
DEFINE_CP0_REG32("$9,0",cp0_count_read, cp0_count_write);
DEFINE_CP0_REG32("$9,6",cp0_saari_read, cp0_saari_write);
DEFINE_CP0_REG64("$9,7",cp0_saar_read, cp0_saar_write);
DEFINE_CP0_REG64("$10,0",cp0_entryhi_read, cp0_entryhi_write);
DEFINE_CP0_REG32("$11,0",cp0_compare_read, cp0_compare_write);
DEFINE_CP0_REG64("$11,6",cp0_bc_config_read, cp0_bc_config_write);
DEFINE_CP0_REG64("$11,7",cp0_bc_actvseg_read, cp0_bc_actvseg_write);
DEFINE_CP0_REG32("$12,0",cp0_status_read, cp0_status_write);
DEFINE_CP0_REG32("$12,6",cp0_guestctl0_read, cp0_guestctl0_write);
DEFINE_CP0_REG32("$13,0",cp0_cause_read, cp0_cause_write);
DEFINE_CP0_REG64("$14,0",cp0_epc_read, cp0_epc_write);
DEFINE_CP0_REG64("$14,2",cp0_nestedepc_read, cp0_nestedepc_write);
DEFINE_CP0_REG32("$15,0",cp0_prid_read, cp0_prid_write);
DEFINE_CP0_REG64("$15,1",cp0_ebase_read, cp0_ebase_write);
DEFINE_CP0_REG64("$15,2",cp0_cdmmbase_read, cp0_cdmmbase_write);
DEFINE_CP0_REG32("$16,0",cp0_config_read, cp0_config_write);
DEFINE_CP0_REG32("$16,1",cp0_config1_read, cp0_config1_write);
DEFINE_CP0_REG32("$16,2",cp0_config2_read, cp0_config2_write);
DEFINE_CP0_REG32("$16,3",cp0_config3_read, cp0_config3_write);
DEFINE_CP0_REG32("$16,4",cp0_config4_read, cp0_config4_write);
DEFINE_CP0_REG32("$16,5",cp0_config5_read, cp0_config5_write);
DEFINE_CP0_REG32("$16,7",cp0_config7_read, cp0_config7_write);
DEFINE_CP0_REG64("$17,1",cp0_maar_read, cp0_maar_write);
DEFINE_CP0_REG64("$17,2",cp0_maari_read, cp0_maari_write);
DEFINE_CP0_REG64("$18,0",cp0_watchlo0_read, cp0_watchlo0_write);
DEFINE_CP0_REG64("$18,1",cp0_watchlo1_read, cp0_watchlo1_write);
DEFINE_CP0_REG64("$18,2",cp0_watchlo2_read, cp0_watchlo2_write);
DEFINE_CP0_REG64("$18,3",cp0_watchlo3_read, cp0_watchlo3_write);
DEFINE_CP0_REG32("$19,0",cp0_watchhi0_read, cp0_watchhi0_write);
DEFINE_CP0_REG32("$19,1",cp0_watchhi1_read, cp0_watchhi1_write);
DEFINE_CP0_REG32("$19,2",cp0_watchhi2_read, cp0_watchhi2_write);
DEFINE_CP0_REG32("$19,3",cp0_watchhi3_read, cp0_watchhi3_write);
DEFINE_CP0_REG32("$23,0",cp0_debug_read, cp0_debug_write);
DEFINE_CP0_REG64("$24,0",cp0_depc_read, cp0_depc_write);
DEFINE_CP0_REG32("$23,1",cp0_tcbcontrola_read, cp0_tcbcontrola_write);
DEFINE_CP0_REG32("$23,2",cp0_tcbcontrolb_read, cp0_tcbcontrolb_write);
DEFINE_CP0_REG64("$23,3",cp0_usertracedata1_read, cp0_usertracedata1_write);
DEFINE_CP0_REG32("$24,2",cp0_tcbcontrolc_read, cp0_tcbcontrolc_write);
DEFINE_CP0_REG64("$24,3",cp0_usertracedata2_read, cp0_usertracedata2_write);
DEFINE_CP0_REG32("$24,5",cp0_tcbcontrole_read, cp0_tcbcontrole_write);
DEFINE_CP0_REG32("$25,0",cp0_perfcntctl0_read, cp0_perfcntctl0_write);
DEFINE_CP0_REG32("$25,2",cp0_perfcntctl1_read, cp0_perfcntctl1_write);
DEFINE_CP0_REG32("$25,4",cp0_perfcntctl2_read, cp0_perfcntctl2_write);
DEFINE_CP0_REG32("$25,6",cp0_perfcntctl3_read, cp0_perfcntctl3_write);
DEFINE_CP0_REG32("$25,1",cp0_perfcnt0_read, cp0_perfcnt0_write);
DEFINE_CP0_REG32("$25,3",cp0_perfcnt1_read, cp0_perfcnt1_write);
DEFINE_CP0_REG32("$25,5",cp0_perfcnt2_read, cp0_perfcnt2_write);
DEFINE_CP0_REG32("$25,7",cp0_perfcnt3_read, cp0_perfcnt3_write);
DEFINE_CP0_REG32("$26,0",cp0_errctl_read, cp0_errctl_write);
DEFINE_CP0_REG32("$27,0",cp0_cacheerr_read, cp0_cacheerr_write);
DEFINE_CP0_REG64("$28,2",cp0_dtaglo_read, cp0_dtaglo_write);
DEFINE_CP0_REG64("$30,0",cp0_errorepc_read, cp0_errorepc_write);
DEFINE_CP0_REG64("$31,2",cp0_kscratch1_read, cp0_kscratch1_write);
DEFINE_CP0_REG64("$31,3",cp0_kscratch2_read, cp0_kscratch2_write);
DEFINE_CP0_REG64("$31,4",cp0_kscratch3_read, cp0_kscratch3_write);
DEFINE_CP0_REG64("$31,5",cp0_kscratch4_read, cp0_kscratch4_write);
DEFINE_CP0_REG64("$31,6",cp0_kscratch5_read, cp0_kscratch5_write);
DEFINE_CP0_REG64("$31,7",cp0_kscratch6_read, cp0_kscratch6_write);

--------------

platform/mips64/cp0_asm.h: 


--------------

platform/mips64/halt.h: 

void platform_halt(int status);
void platform_debug_break(void);

--------------

platform/mips64/i6400.h: 

void check_cache_err(void);
static inline void __bmcache_init(uint64_t buf_ptr, uint64_t size)
{
 int i; uint64_t nlines =(size >>BM_UNIT_SIZE_LOG_SIZE);for(i =0; i <nlines; i++){__asm__ __volatile__("cca_bcpfs_%=:\n" "\tpref   3, 0(%0)\n": :"r"(buf_ptr):"cc");
 __asm__ __volatile__("bc_flush_%=:\n" "\tcache   0xd, 0x04(%0)\n": :"r"(buf_ptr):"cc");
 buf_ptr +=BM_UNIT_SIZE;}
}
static inline void __bp_flush(uint64_t flush_addr)
{__asm__ __volatile__("cca_bc_flush_%=:\n" "\tcache   "XSTRINGIFY(BCIndxOp)", "XSTRINGIFY(BCOp_SegWBInv)"(%0)\n": :"r"(flush_addr):"cc");
}
static inline void __mips_sync(void)
{__asm__ __volatile__(" sync "XSTRINGIFY(SYNC)"   \n");
}
static inline void __mips_sync_wmb(void)
{__asm__ __volatile__("sync 4\n");
}
static inline void __mips_sync_mb(void)
{__asm__ __volatile__(" sync "XSTRINGIFY(SYNC_MB)"  \n");
}
static inline void __mips_execution_hazard_barrier(void)
{__asm__ __volatile__(" ehb    \n");
}
static inline void __mips_wait(void)
{
 uint32_t status =cp0_status_read();cp0_status_write(status & ~CP0_STATUS_IE);
 __asm__ __volatile__(
 ".set push        \n" ".set noreorder   \n" " nop;nop;nop;nop;nop;nop;nop;nop;  \n" " nop;nop;nop;nop;nop;nop;nop;      \n" " wait      \n" ".set pop   \n"
 " wait      \n"
 );
 cp0_status_write(status);
}
static inline void __mips_pause(void)
{abort();__asm__ __volatile__(" pause    \n");
}
static inline void __mips_sdbbp(void)
{__asm__ __volatile__("sdbbp");
}
static inline void __mips_tlb_write_index(void)
{__asm__ __volatile__("tlbwi");
}
static inline void __mips_returnable_trap(void)
{__asm__ __volatile__("teq    $0,$0    \n");
}
static inline void __mips_pref3(volatile uint8_t *magic_addr)
{__asm__ __volatile__("cca_bcpfs_%=:\n" "\tpref   3, 0(%0)\n": :"r"(magic_addr):"cc");
}
static inline void __mips_l1b_flush_invalidate_begin(void)
{__asm__ __volatile__("  cache "XSTRINGIFY(BCIndxOp)", "XSTRINGIFY(BCOp_SegWBInv)"($0) \n");
}
static inline void __mips_active_seg_wait_flush(void)
{int64_t reg; do{__asm__ __volatile__("dmfc0 %0, $11, 7\n":"=r"(reg));}while(reg <0);
}
static inline void __mips_l1b_flush_invalidate(void)
{__mips_sync();__mips_l1b_flush_invalidate_begin();__mips_execution_hazard_barrier();
 check_cache_err();
}
void __mips_l1b_flush_invalidate_wait(void);
void __mips_l2_flush_invalidate(void);
static inline void __mips_l1_writeback_invalidate_vaddr(void *address)
{__asm__ __volatile__("cache "XSTRINGIFY(Hit_Writeback_Inv_D)",0(%[address]);\n\t": :[address]"r"(address));
}
static inline void __mips_l2_writeback_invalidate_vaddr(void *address)
{__asm__ __volatile__("cache "XSTRINGIFY(Hit_Writeback_Inv_S)",0(%[address]);\n\t": :[address]"r"(address));
}
static inline void __mips_l2_invalidate_vaddr_unsafe(void *address)
{__asm__ __volatile__("cache "XSTRINGIFY(Hit_Inv_S)",0(%[address]);\n\t": :[address]"r"(address));
}
static inline void __mips_l1_writeback_invalidate_index(uint32_t index)
{index <<=6; __asm__ __volatile__("cache "XSTRINGIFY(Index_Writeback_Inv_D)",0(%[index]);\n\t": :[index]"r"(index));
}
static inline void __mips_l2_writeback_invalidate_index(uint32_t index)
{index <<=6; __asm__ __volatile__("cache "XSTRINGIFY(Index_Writeback_Inv_S)",0(%[index]);\n\t": :[index]"r"(index));
}
static inline uint64_t __mips_get_sp(void)
{uint64_t r; __asm__ __volatile__("move	%0,	$sp":"=r"(r));return r;
}
static inline uintptr_t __mips_get_k1(void)
{uint64_t r; __asm__ __volatile__("move	%0,	$k1":"=r"(r));return r;
}
static inline void __mips_set_k1(uintptr_t val)
{__asm__("move $k1, %0": :"r"(val));
}
static inline void __mips_ld(uintptr_t address)
{__asm__ __volatile__("ld $0, 0(%[base])": :[base]"r"(address));
}
static inline uint64_t __mips_read_cycles(void)
{return((uint64_t)cp0_count_read())*2ULL;
}
static inline uint64_t __mips_cycles_delta(uint64_t t1, uint64_t t0)
{if(t1 >t0){return t1 -t0;}else{return(t1 |(1ULL<<32))-t0;}
}
static inline uint32_t __mips_slt(uint32_t a, uint32_t b)
{uint32_t r; __asm__ __volatile__("slt	%0, %1, %2":"=r"(r):"r"(a),"r"(b));return r;
}
static inline uint32_t __mips_seleqz(uint32_t rt, uint32_t rs)
{uint32_t rd; __asm__ __volatile__("seleqz	%0, %1, %2":"=r"(rd):"r"(rs),"r"(rt));return rd;
}
static inline uint32_t __mips_selnez(uint32_t rt, uint32_t rs)
{uint32_t rd; __asm__ __volatile__("selnez	%0, %1, %2":"=r"(rd):"r"(rs),"r"(rt));return rd;
}
static inline uint32_t __mips_or(uint32_t rt, uint32_t rs)
{uint32_t rd; __asm__ __volatile__("or	%0, %1, %2":"=r"(rd):"r"(rs),"r"(rt));return rd;
}
static inline uint32_t __mips_max(uint32_t a, uint32_t b)
{uint32_t r, n, t0, t1; n =__mips_slt(a, b);t0 =__mips_seleqz(n, a);t1 =__mips_selnez(n, b);r =__mips_or(t0, t1);return r;
}
static inline uint32_t __mips_min(uint32_t a, uint32_t b)
{uint32_t r, n, t0, t1; n =__mips_slt(b, a);t0 =__mips_seleqz(n, a);t1 =__mips_selnez(n, b);r =__mips_or(t0, t1);return r;
}
static inline v2i64 __mips_volatile_ld_d(void *loc)
{v2i64 rv; v2i64 *reg_bank =loc; __asm__ __volatile__("ld.d\t%w[rv], %[reg_bank]":[rv]"=f"(rv):[reg_bank]"m"(*reg_bank));return rv;
}

--------------

platform/mips64/include/align_copy_mips64.h: 

void _msa_copy64(void *dst, const void *src, size_t len);
static inline void align8_copy(void *dst, const void *src, size_t len)
{assert((uint64_t)dst %8==0);assert((uint64_t)src %8==0);assert(len !=0&&len %8==0);if(__builtin_constant_p(len)&&len ==64){((uint64_t *)dst)[0]=((uint64_t *)src)[0];((uint64_t *)dst)[1]=((uint64_t *)src)[1];((uint64_t *)dst)[2]=((uint64_t *)src)[2];((uint64_t *)dst)[3]=((uint64_t *)src)[3];((uint64_t *)dst)[4]=((uint64_t *)src)[4];((uint64_t *)dst)[5]=((uint64_t *)src)[5];((uint64_t *)dst)[6]=((uint64_t *)src)[6];((uint64_t *)dst)[7]=((uint64_t *)src)[7];}else if(__builtin_constant_p(len)&&len ==56){((uint64_t *)dst)[0]=((uint64_t *)src)[0];((uint64_t *)dst)[1]=((uint64_t *)src)[1];((uint64_t *)dst)[2]=((uint64_t *)src)[2];((uint64_t *)dst)[3]=((uint64_t *)src)[3];((uint64_t *)dst)[4]=((uint64_t *)src)[4];((uint64_t *)dst)[5]=((uint64_t *)src)[5];((uint64_t *)dst)[6]=((uint64_t *)src)[6];}else if(__builtin_constant_p(len)&&len ==48){((uint64_t *)dst)[0]=((uint64_t *)src)[0];((uint64_t *)dst)[1]=((uint64_t *)src)[1];((uint64_t *)dst)[2]=((uint64_t *)src)[2];((uint64_t *)dst)[3]=((uint64_t *)src)[3];((uint64_t *)dst)[4]=((uint64_t *)src)[4];((uint64_t *)dst)[5]=((uint64_t *)src)[5];}else if(__builtin_constant_p(len)&&len ==40){((uint64_t *)dst)[0]=((uint64_t *)src)[0];((uint64_t *)dst)[1]=((uint64_t *)src)[1];((uint64_t *)dst)[2]=((uint64_t *)src)[2];((uint64_t *)dst)[3]=((uint64_t *)src)[3];((uint64_t *)dst)[4]=((uint64_t *)src)[4];}else if(__builtin_constant_p(len)&&len ==32){((uint64_t *)dst)[0]=((uint64_t *)src)[0];((uint64_t *)dst)[1]=((uint64_t *)src)[1];((uint64_t *)dst)[2]=((uint64_t *)src)[2];((uint64_t *)dst)[3]=((uint64_t *)src)[3];}else if(__builtin_constant_p(len)&&len ==24){((uint64_t *)dst)[0]=((uint64_t *)src)[0];((uint64_t *)dst)[1]=((uint64_t *)src)[1];((uint64_t *)dst)[2]=((uint64_t *)src)[2];}else if(__builtin_constant_p(len)&&len ==16){((uint64_t *)dst)[0]=((uint64_t *)src)[0];((uint64_t *)dst)[1]=((uint64_t *)src)[1];}else if(__builtin_constant_p(len)&&len ==8){((uint64_t *)dst)[0]=((uint64_t *)src)[0];}else{const void *src_end =src +len; do{*(uint64_t *)dst = *(uint64_t *)src; src +=8; dst +=8;}while(src <src_end);}
}
static inline void align16_copy(void *dst, const void *src, size_t len)
{assert((uint64_t)dst %16==0);assert((uint64_t)src %16==0);assert(len !=0&&len %16==0);if(__builtin_constant_p(len)&&len ==64){v2i64 pair1 =__msa_ld_d(src, 0);v2i64 pair2 =__msa_ld_d(src, 16);v2i64 pair3 =__msa_ld_d(src, 32);v2i64 pair4 =__msa_ld_d(src, 48);__msa_st_d(pair1, dst, 0);__msa_st_d(pair2, dst, 16);__msa_st_d(pair3, dst, 32);__msa_st_d(pair4, dst, 48);}else if(__builtin_constant_p(len)&&len ==48){v2i64 pair1 =__msa_ld_d(src, 0);v2i64 pair2 =__msa_ld_d(src, 16);v2i64 pair3 =__msa_ld_d(src, 32);__msa_st_d(pair1, dst, 0);__msa_st_d(pair2, dst, 16);__msa_st_d(pair3, dst, 32);}else if(__builtin_constant_p(len)&&len ==32){v2i64 pair1 =__msa_ld_d(src, 0);v2i64 pair2 =__msa_ld_d(src, 16);__msa_st_d(pair1, dst, 0);__msa_st_d(pair2, dst, 16);}else if(__builtin_constant_p(len)&&len ==16){__msa_st_d(__msa_ld_d(src, 0),dst, 0);}else if(__builtin_constant_p(len)&&len %64==0){_msa_copy64(dst, src, len);}else{const void *src_end =src +len; do{__msa_st_d(__msa_ld_d(src, 0),dst, 0);src +=16; dst +=16;}while(src <src_end);}
}
static inline void align16_copy64(void *dst, const void *src, size_t len)
{assert((uint64_t)dst %16==0);assert((uint64_t)src %16==0);assert(len !=0&&len %64==0);if(__builtin_constant_p(len)&&len ==64){v2i64 pair1 =__msa_ld_d(src, 0);v2i64 pair2 =__msa_ld_d(src, 16);v2i64 pair3 =__msa_ld_d(src, 32);v2i64 pair4 =__msa_ld_d(src, 48);__msa_st_d(pair1, dst, 0);__msa_st_d(pair2, dst, 16);__msa_st_d(pair3, dst, 32);__msa_st_d(pair4, dst, 48);}else{_msa_copy64(dst, src, len);}
}

--------------

platform/mips64/include/thread.h: 

struct thread_context {uint64_t sp; uint64_t ra; uint64_t s0; uint64_t s1; uint64_t s2; uint64_t s3; uint64_t s4; uint64_t s5; uint64_t s6; uint64_t s7; uint64_t s8; uint64_t f24; uint64_t f25; uint64_t f26; uint64_t f27; uint64_t f28; uint64_t f29; uint64_t f30; uint64_t f31;};
struct dispatch_context {uint64_t sp; uint64_t ra; uint64_t s0; uint64_t s1; uint64_t s2; uint64_t s3; uint64_t s4; uint64_t s5; uint64_t s6; uint64_t s7; uint64_t s8; uint64_t f24; uint64_t f25; uint64_t f26; uint64_t f27; uint64_t f28; uint64_t f29; uint64_t f30; uint64_t f31;};

--------------

platform/mips64/include/vplocal_mips64.h: 

uint8_t vplocal_my_local_vpid(void);
struct topo_ccv vplocal_ccv_address(void);
struct bug_check_params {bug_check_handler_t user_handler; uintptr_t user_data; bool initiated; uint64_t first_epc; uint64_t trap_state[MIPS64_REGCOUNT];int status; char buf[BUG_CHECK_BUFSIZ];volatile const char *error_msg; volatile uint64_t test_magic;};
struct fiu_wutx_template {struct regfile fiu_wu; uint64_t credit_mask;};
struct wdt_vp_state {bool bite; volatile uint64_t printlock_pending; uint32_t decr_count; uint32_t disabled_decr_count; bool warn; bool fail_on_warn; fun_time_t last; uint64_t reset_count; uint64_t reset_decr; uint64_t reset_threshold;};
struct chario_vp_state {bool header; int prio;};
struct cmh *vplocal_cmh(void);
struct mips64_vp {struct regfile fiu; struct fiu_wutx_template gated_wu[2];struct fiu_wutx_template ungated_wu[2]; struct regfile fiu_vp0; struct bug_check_params bug_check; uint32_t assert_depth; const char *assert_first_fmt; uint32_t depc_depth; int runstate; bool backtrace_requested; uint64_t wake_counts[WAKE_REASON_COUNT];uint64_t irq_count; uint64_t adel_count; uint64_t ades_count; void *debug_exception_context; void *debug_trap_context; struct wdt_vp_state wdt; struct thread_context *sandbox_return_context; uint64_t sandbox_code_generation; uint32_t sandbox_wired_base; uint64_t bm_non_coh_base_addr; struct chario_vp_state chario; struct vplocal vplocal;}ALIGNED(CACHE_LINE_SIZE);
static __attribute__((const))inline struct mips64_vp *vplocal_mips64(void)
 { register void *ptr; __asm__("move %0, $27":"=r"(ptr)); register void *ptr __asm__("$k1"); assert(ptr ==(void *)cp0_kscratch1_read());return ptr;}
static __attribute__((const))inline struct vplocal *vplocal(void)
 {return &vplocal_mips64()->vplocal;}
struct mips64_vp *vplocal_mips64_other(vpnum_t);
struct mips64_vp *vplocal_mips64_bugcheck(void);

--------------

platform/mips64/mem_region_mips64.h: 

void mem_region_core_maar_init(void);
void mem_region_ddr_mem_speculation_init(void);
bool region_check_range(unsigned int, void *,size_t);

--------------

platform/mips64/mm_mips64.h: 

typedef uint64_t vaddr_t;
typedef uint64_t paddr_t;
void init_mm(void);
int alloc_wired_vtlb(void);
vaddr_t pa_to_xkphys_cached(paddr_t pa);
vaddr_t pa_to_xkphys_ncoherent(paddr_t pa);
paddr_t va_to_pa(vaddr_t va);
vaddr_t paddr_to_vaddr(paddr_t pa, bool paddr_in_wustack);
bool va_is_valid_memory(vaddr_t va);
vaddr_t va_to_noncoherent_va(vaddr_t va);
vaddr_t va_to_coherent_va(vaddr_t va);
bool pa_is_pri_mem_coherent(paddr_t pa);
bool pa_is_pri_mem_ncoherent(paddr_t pa);
bool pa_is_bm(paddr_t pa);
paddr_t pa_to_pri_mem_coherent(paddr_t pa);
paddr_t pa_to_pri_mem_ncoherent(paddr_t pa);
paddr_t pa_to_coherent_pa(paddr_t pa);
bool pa_is_ocm_ncoherent(paddr_t pa);
paddr_t pa_to_ocm_ncoherent(paddr_t pa);
bool pa_is_ddr_coherent(paddr_t pa);
bool pa_is_ddr_ncoherent(paddr_t pa);
paddr_t pa_to_ddr_coherent(paddr_t pa);
paddr_t pa_to_ddr_ncoherent(paddr_t pa);
uint64_t mm_vp_stack_top(void);
void mm_wire_stack(void);
uint64_t mm_mkentrylo(uint64_t paddr, bool rw);
bool is_guard_page(vaddr_t va);
vaddr_t guard_va(vaddr_t va, size_t size);
vaddr_t unguard_va(vaddr_t va, size_t size);
vaddr_t unguard_any_va(vaddr_t va);
vaddr_t pa_to_single_guard_va(paddr_t pa);
void *pa_to_single_guard_va_ptr(paddr_t pa);
void *pa_to_xkphys_cached_ptr(paddr_t pa);
bool pa_is_coherent(paddr_t pa);
paddr_t pa_pri_mem_ncoherent_start(void);
paddr_t pa_pri_mem_coherent_start(void);
bool pa_is_ncoherent(paddr_t pa);
void *pa_to_xkphys_ptr(paddr_t pa);
vaddr_t pa_to_xkphys_uncached(paddr_t pa);
paddr_t ptr_to_pa(const void *ptr);
bool ptr_is_bm(void *ptr);
bool is_xkphys(vaddr_t va);
bool is_xkphys_cached(vaddr_t va);
bool is_xkseg(vaddr_t va);
bool is_xkphys_cached_ptr(void *ptr);
bool is_kseg1(vaddr_t va);
paddr_t kseg1_to_pa(uint64_t va);
 bool _try_read_pa_uncached(paddr_t pa, void *out_ptr, size_t size);
bool read_from_va(void *dest, vaddr_t va, size_t len);
bool read_from_vptr(void *dest, void *va, size_t len);

--------------

platform/mips64/regfile.h: 

extern bool regfile_raw;
REGFILE_DEFINE(regfile, uint64_t, 64, regfile_init, regfile_read, regfile_write);
REGFILE_DEFINE(regfile32, uint32_t, 32, regfile32_init, regfile32_read, regfile32_write);
REGFILE_DEFINE(regfile8, uint8_t, 8, regfile8_init, regfile8_read, regfile8_write);

--------------

platform/posix/abort_posix.h: 


--------------

platform/posix/cache_size_posix.h: 


--------------

platform/posix/cmh.h: 

struct wu_q;
struct cmh;
struct cmh *cmh_construct(faddr_t, uint64_t flags);
void cmh_dequeue_wu(struct cmh *,struct wu *);
void cmh_enqueue_gated_wu(struct cmh *,struct wu *);
int cmh_drain_gated_fifos(struct cmh *cmh);
void cmh_drain_gated_fifo_if_wul(struct cmh *cmh, uint32_t lwm);
void cmh_ack_wu(struct cmh *cmh);
void cmh_peek_wu(struct cmh*,struct wu*);
bool cmh_has_work(struct cmh *cmh);
void cmh_increment_send(struct cmh *);
uint64_t cmh_read_counter(struct cmh *,unsigned int idx);
uint64_t cmh_get_flags(struct cmh *cmh);
void cmh_set_state_callbacks(struct cmh *cmh, void(*queues_empty)(void *),void(*queues_not_empty)(void *),void *cookie);
void cmh_sn_read32(struct cmh *cmh, uint64_t data[4]);

--------------

platform/posix/fabric.h: 

enum fabric_endpoint_type
 {FABRIC_ENDPOINT_INVALID =0, FABRIC_ENDPOINT_CMH, FABRIC_ENDPOINT_LE, FABRIC_ENDPOINT_BAM, FABRIC_ENDPOINT_DAM, FABRIC_ENDPOINT_OCMDAM, FABRIC_ENDPOINT_EQM, FABRIC_ENDPOINT_MUHDAM,};
struct fabric_dispatch
 {int(*send_wu)(enum fabric_endpoint_type type, void *cookie, struct wu *wu);void(*sn_send16)(enum fabric_endpoint_type type, void *cookie, uint64_t data[2]);void(*sn_send32)(enum fabric_endpoint_type type, void *cookie, uint64_t data[4]); void(*sn_send64)(enum fabric_endpoint_type type, void *cookie, uint64_t data[8]); unsigned(*get_level)(enum fabric_endpoint_type type, void *cookie);void(*cleanup)(void *cookie);};
void fabric_construct_gid(unsigned gid);
bool fabric_gid_exists(unsigned int gid);
void fabric_register_lid(faddr_t, enum fabric_endpoint_type, struct fabric_dispatch *,void *);
int fabric_send_wu(struct wu *wu);
void fabric_ack_wu(void);
void fabric_sn_send16(uint64_t action, uint64_t arg0);
void fabric_sn_send32(uint64_t action, uint64_t arg0, uint64_t arg1, uint64_t arg2);
void fabric_sn_send64(uint64_t data[8]);
unsigned fabric_get_level(faddr_t);
void *fabric_lookup_cookie(faddr_t);
void posix_cleanup(void);
struct posix_vp;

--------------

platform/posix/include/mm_posix.h: 

typedef uint64_t vaddr_t;
typedef uint64_t paddr_t;
static inline bool pa_is_coherent(paddr_t pa)
{enum mem_region_id coh_regions[]= {MEM_REGION_COHERENT_STATIC_POOL, MEM_REGION_COHERENT_POOL, MEM_REGION_TASK_PRI_COH};for(int i =0; i >ARRAY_SIZE(coh_regions);i++){const struct mem_region *r =mem_region_for_id(coh_regions[i]);if((pa >=(paddr_t)(r->start))&&(pa <(paddr_t)(r->end))) {return true;}}return false;
}
static inline bool pa_is_noncoherent(paddr_t pa)
{enum mem_region_id ncoh_regions[]= {MEM_REGION_NON_COHERENT_STATIC_POOL, MEM_REGION_NON_COHERENT_POOL, MEM_REGION_TASK_PRI_NONCOH};for(int i =0; i >ARRAY_SIZE(ncoh_regions);i++){const struct mem_region *r =mem_region_for_id(ncoh_regions[i]);if((pa >=(paddr_t)(r->start))&&(pa <(paddr_t)(r->end))) {return true;}}return false;
}
static inline bool pa_is_ddr_coherent(paddr_t pa)
{return false;
}
static inline bool pa_is_ddr_ncoherent(paddr_t pa)
{return false;
}
static inline bool pa_is_pri_mem_coherent(paddr_t pa)
{return pa_is_coherent(pa);
}
static inline bool pa_is_pri_mem_ncoherent(paddr_t pa)
{return pa_is_noncoherent(pa);
}
bool read_from_vptr(void *dest, void *src, size_t size);
static inline bool is_guard_page(vaddr_t va)
{return false;
}
static inline bool ptr_is_bm(void *ptr){return true;
}

--------------

platform/posix/include/thread.h: 

struct thread_context {ucontext_t ucontext;};
struct dispatch_context {ucontext_t ucontext;};
struct _arm64_darwin_context {uint64_t gprs[NGPRS];uint64_t fpus[NFPUS];};
struct thread_context {struct _arm64_darwin_context context;};
struct dispatch_context {struct _arm64_darwin_context context;};

--------------

platform/posix/include/vplocal_posix.h: 

struct cmh;
struct cmh *vplocal_cmh(void);
uint8_t vplocal_my_local_vpid(void);
struct topo_ccv vplocal_ccv_address(void);
struct vplocal *vplocal(void);

--------------

platform/posix/mem_region_posix.h: 

static inline void mem_region_ddr_mem_speculation_init(void){}

--------------

platform/posix/wufifo.h: 

struct wu_q;
struct wu_q *wufifo_alloc(void);
enum fun_ret wufifo_pop(struct wu_q *q, struct wu *wu);
enum fun_ret wufifo_push(struct wu_q *q, struct wu *wu);
enum fun_ret wufifo_peek(struct wu_q *q, struct wu *wu);
int wufifo_isempty(struct wu_q *q);
unsigned wufifo_getdepth(struct wu_q *q);

--------------

props_bridges/version_bridge.h: 

const char *version_bridge_build_description(void);

--------------

services/bin_ctl/bin_ctl_handler.h: 

struct bin_ctl_connection;
struct bin_ctl_handler_info {enum fun_ret(*create_push)(struct channel *,struct flow *);enum fun_ret(*destroy_push)(struct channel *,struct flow *);enum fun_ret(*open_connection_push)(struct channel *,struct flow *,struct bin_ctl_connection *,void **handler_context);enum fun_ret(*close_connection_push)(struct channel *,struct flow *,struct bin_ctl_connection *,void *handler_context);enum fun_ret(*handle_data_push)(struct channel *,struct bin_ctl_connection *connection, void *handler_context, uint8_t *input_ptr, size_t input_size);size_t(*message_size)(const uint8_t *data_ptr, size_t data_size);};
bool bin_ctl_register_handler(uint16_t handler_id, struct bin_ctl_handler_info info);
void bin_ctl_transfer_push(struct channel *channel, struct bin_ctl_connection *connection, const uint8_t *data_ptr, size_t data_size, int *ret);

--------------

services/commander/fun_command_environment.h: 

struct channel;
typedef void(*fun_command_tx_push_f)(struct channel *,const struct fun_ptr_and_size data, void *connection, OUT int *retval);
typedef void(*fun_command_connection_close_f)(void *connection);
struct fun_command_environment {uint32_t extra_refcount; enum fun_privilege privilege_level; void *connection; fun_command_tx_push_f connection_tx_push; fun_command_connection_close_f connection_close; struct fun_json *variables;};
WU_THREADED struct fun_command_environment *fun_command_environment_create(void);
struct fun_command_environment *fun_command_environment_retain(struct fun_command_environment *);
WU_THREADED void fun_command_environment_release(NULLABLE struct fun_command_environment *);
NULLABLE struct fun_json *fun_command_environment_lookup(const struct fun_command_environment *,const char *key);

--------------

services/commander/fun_commander.h: 

struct fun_command_transaction {int64_t current_tid;};
typedef CALLER_TO_RELEASE struct fun_json *(*fun_json_command_f)(struct fun_command_environment *env, struct fun_command_transaction *trans, const struct fun_json *array);
typedef CALLER_TO_RELEASE struct fun_json *(*fun_json_macro_f)(const struct fun_json *);
CALLER_TO_RELEASE WU_THREADED struct fun_json *fun_commander_execute(struct fun_command_environment *,const struct fun_json *input);
CALLER_TO_RELEASE WU_THREADED NULLABLE struct fun_json *fun_commander_line_to_command(const char *line, INOUT uint64_t *tid, NULLABLE OUT const char **error);
CALLER_TO_RELEASE WU_THREADED struct fun_json *parse_json_sequence(const char *text);
struct fun_commander_reg_info {const char *verb; const char *short_description; NULLABLE const char *long_description; bool is_macro; bool has_subverbs; bool no_log_arguments; enum fun_privilege privilege_needed; const char *arguments_schema; fun_json_command_f command; fun_json_macro_f macro;};
WU_THREADED void fun_commander_register(const struct fun_commander_reg_info *);
WU_THREADED void fun_commander_register_multiple(const struct fun_commander_reg_info *,size_t);
void fun_commander_register_unevaluated(const struct fun_commander_reg_info *);
void fun_commander_register_unevaluated_multiple(const struct fun_commander_reg_info *,size_t);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_commander_lookup_description(const char *verb);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_commander_lookup_schema(const char *verb);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_commander_lookup_all_verbs(void);
CALLER_TO_RELEASE struct fun_json *fun_commander_lookup_all_short_descriptions(void);
struct fun_commander_sub_reg_info {const char *sub_verb; const char *short_description; NULLABLE const char *long_description; bool no_log_arguments; enum fun_privilege privilege_needed; const char *arguments_schema; fun_json_command_f command;};
WU_THREADED void fun_commander_root_verb_register(const char *verb, const char *short_description);
WU_THREADED void fun_commander_sub_verb_register(const char *verb, const struct fun_commander_sub_reg_info *);
WU_THREADED NULLABLE void fun_commander_sub_verb_register_multiple(const char *verb, const struct fun_commander_sub_reg_info *,size_t);
WU_THREADED void fun_commander_sub_verb_help_register(const char *verb);
WU_THREADED NULLABLE CALLER_TO_RELEASE struct fun_json *fun_commander_lookup_all_sub_verbs(const char *verb);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_commander_lookup_sub_verb(const char *verb, const char *sub_verb);
CALLER_TO_RELEASE struct fun_json *fun_commander_wrap_result(FUN_JSON_XFER struct fun_json *,int64_t tid, fun_time_t duration);
CALLER_TO_RELEASE struct fun_json *fun_commander_evaluate_json(struct fun_command_environment *,const struct fun_json *arg, uint64_t tid);
CALLER_TO_RELEASE struct fun_json *fun_commander_evaluate_array(struct fun_command_environment *env, const struct fun_json *arg, uint64_t tid);
CALLER_TO_RELEASE NULLABLE struct fun_json *
fun_commander_array_to_command(const struct fun_json *array, INOUT uint64_t *tid, NULLABLE OUT const char **error);
bool fun_commander_has_root_command(const char *verb);
CALLER_TO_RELEASE struct fun_json *fun_commander_evaluate_root_help(const char *verb, const struct fun_json *array);

--------------

services/commander/fun_commander_basic_commands.h: 

void fun_commander_register_basic_commands(void);
void fun_commander_register_help_command(void);

--------------

services/mbuf/fun_mbuf.h: 

struct fun_mbuf;
typedef uint16_t fun_mbuf_flags_t;
ENUM_DEF(fun_mbuf_mem_type_t);
void fun_mbuf_create_indirect_push(struct channel *,bool mbuf_owns, void *memory, size_t size, size_t capacity, fun_mbuf_flags_t flags, struct module *,OUT struct fun_mbuf **mbuf_ptr);
void fun_mbuf_create_allocate_push(struct channel *,size_t capacity, fun_mbuf_flags_t flags, struct module *,OUT struct fun_mbuf **mbuf_ptr);
void fun_mbuf_create_allocate_multiple_push(struct channel *,size_t capacity, fun_mbuf_flags_t flags, struct module *,uint32_t num, OUT struct fun_mbuf **mbuf_ptr);
NULLABLE struct fun_mbuf *fun_mbuf_try_allocate(size_t capacity, fun_mbuf_flags_t, struct module *);
typedef NULLABLE void *fun_mbuf_finalize_context_t;
typedef void(*fun_mbuf_finalizer_f)(struct fun_mbuf *,fun_mbuf_finalize_context_t);
void fun_mbuf_set_finalizer(struct fun_mbuf *,fun_mbuf_finalize_context_t, fun_mbuf_finalizer_f);
void fun_mbuf_init_indirect(struct fun_mbuf *mbuf, bool mbuf_owns, void *pointed_to, size_t size, size_t capacity, fun_mbuf_flags_t flags, struct module *,fun_mbuf_finalize_context_t, fun_mbuf_finalizer_f);
struct fun_mbuf *fun_mbuf_retain(struct fun_mbuf *);
bool fun_mbuf_release(NULLABLE struct fun_mbuf *);
void fun_mbuf_release_multiple(struct fun_mbuf **,uint32_t count);
void fun_mbuf_release_async(struct flow *caller_flow, NULLABLE struct fun_mbuf *);
void fun_mbuf_release_multiple_async(struct flow *caller_flow, struct fun_mbuf **,uint32_t count);
bool fun_mbuf_release_ptr(INOUT struct fun_mbuf **);
void fun_mbuf_set_data_size(struct fun_mbuf *,size_t);
void fun_mbuf_set_data_offset(struct fun_mbuf *mbuf, size_t off, size_t size);
size_t fun_mbuf_data_size(const struct fun_mbuf *);
size_t fun_mbuf_data_capacity(const struct fun_mbuf *);
size_t fun_mbuf_data_offset(const struct fun_mbuf *);
struct fun_ptr_and_size fun_mbuf_data(struct fun_mbuf *);
void fun_mbuf_fill_general_stats(OUT uint64_t *num_in_use, OUT uint64_t *bytes_in_use);
ENUM_DEF(fun_mbuf_per_mem_type_stats_t);
void fun_mbuf_fill_per_mem_type_stats(fun_mbuf_mem_type_t, OUT uint64_t stats[FUN_MBUF_PER_MEM_TYPE_LAST]);
struct fun_mbuf_cache_entry_info {fun_mbuf_mem_type_t mem_type; size_t size;};
struct fun_mbuf_cache_entry_info fun_mbuf_cache_get_entry_info(int cache_entry);
void fun_mbuf_fill_caches_stats(int cache_entry, OUT uint64_t *);
void
fun_mbuf_set_4k_cache_size(uint32_t num_vps);
void fun_mbuf_dump_general_stats(bool details, const char *separator);
void fun_mbuf_dump_general_stats_if_non_trivial(void);
void fun_mbuf_dump_caches_stats(bool only_if_non_trivial);
void fun_mbuf_prevent_final_release(struct fun_mbuf *);
void fun_mbuf_reenable_final_release(struct fun_mbuf *);
uint32_t fun_mbuf_debug_refcount(NULLABLE const struct fun_mbuf *);
extern bool fun_mbuf_debug_logs;

--------------

services/mbuf/fun_mbuf_utils.h: 

struct fun_mbuf_list {uint8_t numbuf; struct fun_mbuf **buf;};
struct fun_mbuf_list_ext {struct fun_mbuf **mbufs; uint16_t size; uint16_t currsize; uint16_t startindex; uint32_t startmbufoffset; uint32_t totalbytes; uint32_t capacitybytes;};
struct fun_ptr_array {bool use_capacity; uint32_t size; struct fun_ptr_and_size ptrarray[0];};
void fun_mbuf_push_list_coalesce(struct channel *,struct fun_mbuf_list *lists, uint8_t listsize, fun_mbuf_flags_t flags, struct module *,OUT struct fun_mbuf **);
void mbuf_append(struct fun_mbuf *dst, struct fun_mbuf *src);
void fun_mbuf_list_coalesce_noalloc(struct frame *,struct fun_mbuf_list *lists, uint8_t listsize, struct fun_mbuf *);
void fun_mbuf_list_coalesce_dma_push(struct channel *,struct fun_mbuf_list *lists, uint8_t listsize, struct fun_mbuf *mbuf);
void fun_mbuf_list_init(struct fun_mbuf_list_ext *list, struct fun_mbuf **mbufs, uint16_t size);
bool fun_mbuf_list_empty(struct fun_mbuf_list_ext *list);
bool fun_mbuf_list_full(struct fun_mbuf_list_ext *list);
struct fun_mbuf *mbuf_list_first(struct fun_mbuf_list_ext *list);
bool fun_mbuf_list_add(struct fun_mbuf_list_ext *list, struct fun_mbuf *mbuf, const char *);
bool fun_mbuf_list_remove_first(struct fun_mbuf_list_ext *list);
void fun_mbuf_list_trim(struct fun_mbuf_list_ext *list, uint64_t size);
struct fun_mbuf *fun_mbuf_list_last(struct fun_mbuf_list_ext *list);
void fun_mbuf_list_coalesce_one(struct fun_mbuf_list_ext *list);
void fun_mbuf_list_release_all(struct fun_mbuf_list_ext *list);
bool fun_mbuf_list_copy(struct fun_mbuf *dst_mbuf, struct fun_mbuf_list_ext *list);
void fun_mbuflist_set_size(struct fun_mbuf_list_ext *list, uint32_t offset, uint64_t bytes);
void fun_free_mbuf_ext(struct fun_mbuf_list_ext **mbuf_list_addr);
void fun_mbuflist2ptrarray(struct fun_mbuf_list_ext *list, struct fun_ptr_and_size *ptr_array, bool use_capacity);
void fun_mbuflist2ptrarray_allocate_push(struct channel *channel, struct fun_mbuf_list_ext *list, struct fun_ptr_array **ptr_array, bool use_capacity);
bool fun_mbuflist_equal_ptrarray(struct fun_mbuf_list_ext *list, struct fun_ptr_array *ptr_array, bool use_capacity);
void fun_mbuf_vector_create_allocate_push(struct channel *channel, uint32_t size, uint32_t chunk_size, uint32_t flags, struct module *,struct fun_mbuf_list_ext **list);
void fun_free_mbuf_vector(struct fun_mbuf_list_ext **list_addr);
void fun_mbuflist_copy_data(struct fun_mbuf_list_ext **mbuflist, struct fun_ptr_and_size ptrsize);
int fun_mbuflist_cmp(struct fun_mbuf_list_ext *mbuflist, void *buffer, uint32_t size);

--------------

services/mbuf/fun_refbuf_share.h: 

void refbuf_share_init(struct refbuf_share *share);
void refbuf_share_destroy(struct refbuf_share *share);
void *refbuf_share_alloc(struct refbuf_share *share, uint16_t size);
void refbuf_share_free(void *buf, uint16_t size);

--------------

services/notification/notification.h: 

void notification_post_push(struct channel *,struct notification *note, notification_subject_t subject);
void notification_register_push(struct channel *,struct notification *note, notification_subject_t subject, NULLABLE uintptr_t registration_data, notification_subscriber_f subscriber, NULLABLE OUT notification_ticket_t *ticket_ptr);
typedef void *notification_unregister_context_t;
typedef void(*notification_unregister_f)(NULLABLE notification_unregister_context_t, notification_ticket_t, NULLABLE uintptr_t registration_data);
void notification_unregister_ticket_push(struct channel *,struct notification *,notification_ticket_t, NULLABLE notification_unregister_context_t, NULLABLE notification_unregister_f each_entry);
void notification_unregister_subject_push(struct channel *,struct notification *note, notification_subject_t subject, NULLABLE notification_unregister_context_t, NULLABLE notification_unregister_f each_entry);
const char *notification_name(const struct notification *);
NULLABLE struct notification *notification_from_name(const char *);
size_t notification_total_count(void);
void notification_wait_for_note_push(struct channel *,struct notification *note, notification_subject_t subject, struct frame *frame_to_resume);
void notification_bootstrap(void);
void notification_debug_dump(bool include_registrations);
void notification_note_debug_dump(struct notification *,bool include_registrations);
size_t notification_number_registrations_for_note(const struct notification *);

--------------

services/pattern_match/pattern_match.h: 

enum pattern_match_ret {pattern_match_ret_ok =0, pattern_match_ret_oom, pattern_match_ret_load_fail, pattern_match_ret_unload_fail, pattern_match_ret_graphid_not_found, pattern_match_ret_graph_regadd_fail, pattern_match_lookup_failed, pattern_match_apply_failed, pattern_match_resources_overflow, pattern_match_apply_too_many_matches, pattern_match_ret_regadd_fail, pattern_match_ret_entry_not_found, pattern_match_ret_acl_assign_fail,};
struct pattern_match_info;
enum pattern_match_ret pattern_match_graph_register(OUT fun_uuid_t *,struct fun_ptr_and_size graphdata, int64_t loadmask, const char *name);
NULLABLE struct pattern_match_info *pattern_match_lookup(const fun_uuid_t);
void pattern_match_lookup_clear(struct pattern_match_info *);
struct pattern_match_apply_setup {struct fun_ptr_and_size *records; int num_records; int starting_record;};
struct pattern_match_match_info {int s_gidx; int s_goff; int e_gidx; int e_goff; const char *pattern_name;};
struct pattern_match_apply_results {size_t max_num_matches; OUT int matches_reported; struct pattern_match_match_info matches[];};
struct pattern_match_results {enum pattern_match_ret ret; uint32_t record_size; uint32_t num_matches;};
struct pattern_match_results pattern_match_apply_basic(struct pattern_match_info *s_ctx, uint8_t *data, size_t num_avail_bytes, struct pattern_match_apply_results *matches);
struct pattern_match_results pattern_match_apply_core(struct pattern_match_info *s_ctx, struct pattern_match_apply_setup *ges, struct pattern_match_apply_results *matches);
enum pattern_match_ret pattern_match_graph_unregister(const fun_uuid_t id);
struct fun_ptr_and_size pattern_match_get_blob_data(fun_uuid_t);
enum pattern_match_ret pattern_match_acl_register(OUT fun_uuid_t *,int64_t);
enum pattern_match_ret pattern_match_acl_unregister(fun_uuid_t);
enum pattern_match_ret pattern_match_acl_remove_all(fun_uuid_t);
enum pattern_match_ret pattern_match_acl_remove(fun_uuid_t, uint8_t);
enum pattern_match_ret pattern_match_acl_assign(fun_uuid_t, fun_uuid_t, uint8_t, struct fun_ptr_and_size);
void *pattern_match_get_acl_handle(fun_uuid_t);

--------------

services/rdma_cm/ib_cm.h: 

enum ib_mtu {IB_MTU_256 =1, IB_MTU_512 =2, IB_MTU_1024 =3, IB_MTU_2048 =4, IB_MTU_4096 =5};
static inline int ib_mtu_enum_to_int(enum ib_mtu mtu)
 {switch(mtu){case IB_MTU_256:return 256; case IB_MTU_512:return 512; case IB_MTU_1024:return 1024; case IB_MTU_2048:return 2048; case IB_MTU_4096:return 4096; default:return -1;}
}
enum ib_cm_state {IB_CM_IDLE, IB_CM_LISTEN, IB_CM_REQ_SENT, IB_CM_REQ_RCVD, IB_CM_MRA_REQ_SENT, IB_CM_MRA_REQ_RCVD, IB_CM_REP_SENT, IB_CM_REP_RCVD, IB_CM_MRA_REP_SENT, IB_CM_MRA_REP_RCVD, IB_CM_ESTABLISHED, IB_CM_DREQ_SENT, IB_CM_DREQ_RCVD, IB_CM_TIMEWAIT, IB_CM_SIDR_REQ_SENT, IB_CM_SIDR_REQ_RCVD};
enum ib_cm_lap_state {IB_CM_LAP_UNINIT, IB_CM_LAP_IDLE, IB_CM_LAP_SENT, IB_CM_LAP_RCVD, IB_CM_MRA_LAP_SENT, IB_CM_MRA_LAP_RCVD,};
enum ib_cm_event_type {IB_CM_REQ_ERROR, IB_CM_REQ_RECEIVED, IB_CM_REP_ERROR, IB_CM_REP_RECEIVED, IB_CM_RTU_RECEIVED, IB_CM_USER_ESTABLISHED, IB_CM_DREQ_ERROR, IB_CM_DREQ_RECEIVED, IB_CM_DREP_RECEIVED, IB_CM_TIMEWAIT_EXIT, IB_CM_MRA_RECEIVED, IB_CM_REJ_RECEIVED, IB_CM_LAP_ERROR, IB_CM_LAP_RECEIVED, IB_CM_APR_RECEIVED, IB_CM_SIDR_REQ_ERROR, IB_CM_SIDR_REQ_RECEIVED, IB_CM_SIDR_REP_RECEIVED};
extern const char *ib_cm_event_str[];
enum ib_cm_data_size {IB_CM_REQ_PRIVATE_DATA_SIZE =92, IB_CM_MRA_PRIVATE_DATA_SIZE =222, IB_CM_REJ_PRIVATE_DATA_SIZE =148, IB_CM_REP_PRIVATE_DATA_SIZE =196, IB_CM_RTU_PRIVATE_DATA_SIZE =224, IB_CM_DREQ_PRIVATE_DATA_SIZE =220, IB_CM_DREP_PRIVATE_DATA_SIZE =224, IB_CM_REJ_ARI_LENGTH =72, IB_CM_LAP_PRIVATE_DATA_SIZE =168, IB_CM_APR_PRIVATE_DATA_SIZE =148, IB_CM_APR_INFO_LENGTH =72, IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE =216, IB_CM_SIDR_REP_PRIVATE_DATA_SIZE =136, IB_CM_SIDR_REP_INFO_LENGTH =72,};
enum ib_cm_rej_reason {IB_CM_REJ_NO_QP =1, IB_CM_REJ_NO_EEC =2, IB_CM_REJ_NO_RESOURCES =3, IB_CM_REJ_TIMEOUT =4, IB_CM_REJ_UNSUPPORTED =5, IB_CM_REJ_INVALID_COMM_ID =6, IB_CM_REJ_INVALID_COMM_INSTANCE =7, IB_CM_REJ_INVALID_SERVICE_ID =8, IB_CM_REJ_INVALID_TRANSPORT_TYPE =9, IB_CM_REJ_STALE_CONN =10, IB_CM_REJ_RDC_NOT_EXIST =11, IB_CM_REJ_INVALID_GID =12, IB_CM_REJ_INVALID_LID =13, IB_CM_REJ_INVALID_SL =14, IB_CM_REJ_INVALID_TRAFFIC_CLASS =15, IB_CM_REJ_INVALID_HOP_LIMIT =16, IB_CM_REJ_INVALID_PACKET_RATE =17, IB_CM_REJ_INVALID_ALT_GID =18, IB_CM_REJ_INVALID_ALT_LID =19, IB_CM_REJ_INVALID_ALT_SL =20, IB_CM_REJ_INVALID_ALT_TRAFFIC_CLASS =21, IB_CM_REJ_INVALID_ALT_HOP_LIMIT =22, IB_CM_REJ_INVALID_ALT_PACKET_RATE =23, IB_CM_REJ_PORT_CM_REDIRECT =24, IB_CM_REJ_PORT_REDIRECT =25, IB_CM_REJ_INVALID_MTU =26, IB_CM_REJ_INSUFFICIENT_RESP_RESOURCES =27, IB_CM_REJ_CONSUMER_DEFINED =28, IB_CM_REJ_INVALID_RNR_RETRY =29, IB_CM_REJ_DUPLICATE_LOCAL_COMM_ID =30, IB_CM_REJ_INVALID_CLASS_VERSION =31, IB_CM_REJ_INVALID_FLOW_LABEL =32, IB_CM_REJ_INVALID_ALT_FLOW_LABEL =33};
enum ib_cm_apr_status {IB_CM_APR_SUCCESS, IB_CM_APR_INVALID_COMM_ID, IB_CM_APR_UNSUPPORTED, IB_CM_APR_REJECT, IB_CM_APR_REDIRECT, IB_CM_APR_IS_CURRENT, IB_CM_APR_INVALID_QPN_EECN, IB_CM_APR_INVALID_LID, IB_CM_APR_INVALID_GID, IB_CM_APR_INVALID_FLOW_LABEL, IB_CM_APR_INVALID_TCLASS, IB_CM_APR_INVALID_HOP_LIMIT, IB_CM_APR_INVALID_PACKET_RATE, IB_CM_APR_INVALID_SL};
enum ib_cm_sidr_status {IB_SIDR_SUCCESS, IB_SIDR_UNSUPPORTED, IB_SIDR_REJECT, IB_SIDR_NO_QP, IB_SIDR_REDIRECT, IB_SIDR_UNSUPPORTED_VERSION};

--------------

services/rdma_cm/rdma_cm.h: 

void rdma_cm_flow_bind(struct flow *app_flow);
unsigned int rdma_cm_cm_id_in_use_count(void);

--------------

services/services.h: 


--------------

storage/common/qos_common.h: 

enum qosl_shaper_mode {QOSL_SHPR_MODE_L1_ONLY =0, QOSL_SHPR_MODE_L1 =1, QOSL_SHPR_MODE_L2 =2,};
struct qosl_shaper_info {uint32_t handle; faddr_t vp;};

--------------

storage/common/qos_shaper.h: 

struct nvme_s;
enum qosl_tx_type {QOSL_RD =0, QOSL_WR =1};
struct qosl_add_l1_to_l2_status {enum fun_ret ret; uint16_t child_id;};
struct nvme_s {uint64_t *context; enum qosl_tx_type txType; uint32_t numRead; uint32_t numWrite; uint32_t crdts; struct nvme_s *nxtPtr;};
typedef void(*volDeqCb_t)(uint64_t *,uint32_t, uint32_t);
struct qosl_child_info
 {bool occupied; struct qosl_shaper_info shaper_info;};
struct qosl_l1_enqueue_req {uint32_t child_id; uint32_t curGuarCdt; uint32_t guarCdt; uint32_t curPeakCdt; uint32_t peakCdt; uint32_t recvdGurCdt; uint32_t recvdPeakCdt;};
struct qosl_l2_state {uint32_t num_children; uint32_t prevGuarCdt; uint32_t prevPeakCdt; uint32_t reqCnt; uint32_t prevReqCnt; struct qosl_child_info children[QOSL_MAX_L2_CHILDREN];};
struct qos_l1_state
 {uint32_t child_id; struct qosl_shaper_info parent; struct qosl_l1_enqueue_req enqueue_req; bool enqueue_to_l2_in_progress; bool delete_issued; uint32_t recvdGuarCdt; uint32_t recvdPeakCdt;};
struct qos_l1_only_state
 {};
struct qosl_vol_s {faddr_t vp; uint32_t idx; struct nvme_s *hdPtr; struct nvme_s *tlPtr; uint32_t numPending; int32_t curGuarCdt; int32_t curPeakCdt; uint32_t guarCdt; uint32_t peakCdt; uint32_t peakClip; uint32_t rdCdt; uint32_t wrCdt; uint32_t cdtsFor2writes; uint32_t nextWrCdt; uint16_t shaperFlags; enum qosl_shaper_mode mode; union{struct qos_l1_only_state l1_only; struct qos_l1_state l1; struct qosl_l2_state *l2;};uint64_t startTime; uint64_t totIO; uint64_t totEnq; uint64_t totGcdtIssued; uint64_t totPcdtIssued;
};
struct qosl_cfg_s {uint32_t cdtUpdIntv; uint32_t maxDeqPerWu; uint32_t deqIdleIntv; volDeqCb_t volDeqCb;};
struct qosl_gbl_state_s {struct bitmap *activeVol; struct bitmap *gPending; struct bitmap *pPending; fun_time_t nxtCdtUpdateTime; uint32_t gDeqLastIdx; uint32_t pDeqLastIdx; timerid_t deqTimer; struct timer_arg deqTimerArg; bool deqTimerIsScheduled; timerid_t cdtRefrTimer; struct timer_arg cdtRefrTimerArg; bool creditRefreshScheduled;};
void qosl_register_cb(volDeqCb_t volDeqCb);
void qosl_mem_alloc(void);
void qosl_upd_cfg(uint32_t cdtUpdIntv, uint32_t maxDeqPerWu, uint32_t deqIdleIntv);
enum fun_ret qosl_init(faddr_t vp_faddr, uint32_t cdtUpdIntv, uint32_t maxDeqPerWu, uint32_t deqIdleIntv, volDeqCb_t volDeqCb);
enum fun_ret qosl_create_volume(uint32_t *idx, uint32_t GuarCdt, uint32_t PeakCdt, uint32_t PeakClip, uint32_t rdCdt, uint32_t wrCdt, uint16_t shaperFlags, enum qosl_shaper_mode mode, struct qosl_shaper_info *parent_l2);
enum fun_ret qosl_update_volume(uint32_t idx, uint32_t GuarCdt, uint32_t PeakCdt, uint32_t PeakClip, uint32_t rdCdt, uint32_t wrCdt);
enum fun_ret qosl_delete_volume(uint32_t qos_idx);
enum fun_ret qosl_delete_all_volumes(void);
enum fun_ret qosl_enque_volume(uint32_t idx, bool newEnq, uint64_t *context, uint32_t numRead, uint32_t numWrite, bool *sendImm);
enum fun_ret nvmePush(uint32_t idx, uint64_t *context, enum qosl_tx_type txType, uint32_t numIO, uint32_t crdts);
struct nvme_s *nvmePop(uint32_t idx);
bool refreshCdt(uint32_t idx);
void scheduleCdtRefreshTimer(uint64_t adjTime);
void scheduleDeqTimer(void);
void print_nvmeq_ll(uint32_t idx);
bool qosl_all_volumes_idle(void);

--------------

storage/device/dev_common.h: 

typedef int64_t logical_dev_id_t;
typedef uint64_t physical_dev_id_t;
enum dev_error_type {DEV_ERROR_TYPE_RMMU =0, DEV_ERROR_TYPE_IO_ERR,};
enum dev_type {DEV_TYPES(DEV_TYPE_ENUM)DEV_TYPE_ALL};
extern const char*dev_type_str[];
enum dev_state {DEV_STATES(GEN_DEV_STATE_ENUM)DEV_STATE_MAX,};
enum dev_non_state_events {DEV_FORMAT_COMPLETE =DEV_STATE_MAX,};
enum drive_type {DRIVE_TYPES(GEN_DRIVE_TYPE_ENUM)};
struct drv_ops;
struct dev_info {fun_uuid_t dev_uuid; uint32_t lba_size; uint32_t max_io_size; uint64_t dev_size;  uint64_t dev_flags; enum dev_state state; uint16_t n_ioqueues; uint16_t md_size; enum drive_type drive_type; uint16_t num_err_log_entries; uint32_t write_atomicity_normal; uint32_t write_atomicity_pf_err; uint16_t vendor_id; OUT uint16_t status;};
struct device_event_info {fun_time_t timestamp; uint16_t sub_event_type; enum dev_type device_type; logical_dev_id_t dev_id;};
struct dev_io_op {uint64_t dev_cookie; uint64_t offset; union{uint8_t *data; bool deallocate;};uint8_t *meta; uint32_t len; uint16_t meta_size; uint8_t qid; uint8_t type; uint32_t epoch; OUT uint16_t *status;
};
struct dev_format_spec {uint32_t lba_sz; uint8_t md_settings; uint8_t prot_info; uint8_t prot_info_loc;   uint8_t sec_erase; bool device_level_format; uint32_t epoch; uint16_t pref_md_size; uint8_t selected_lbafs; OUT uint16_t status;};
struct dev_get_log_spec {uint8_t page_id; uint8_t lsp; uint64_t lpo; uint16_t lsi; bool rae; uint8_t uuid_ix; uint32_t data_len; void *data; uint32_t epoch; OUT uint16_t status;};
struct dev_fw_download_spec {void *fw_image; uint32_t image_sz; uint8_t slot; uint32_t crc; uint32_t epoch; OUT uint16_t status;};
void device_reset_drv_ops(enum dev_type type);
bool device_update_drv_ops(struct drv_ops *ops, enum dev_type type);

--------------

storage/device/device.h: 

void dev_open_push(struct channel *channel, logical_dev_id_t dev_id, struct dev_cookie *dev_cookie);
void dev_submit_io_push(struct channel *channel, struct dev_cookie *dev_cookie, struct dev_io_op *op);
void dev_submit_io_send(struct frame *frame, struct flow *caller_flow, struct dev_cookie *dev_cookie, struct dev_io_op *op);
void dev_submit_flush_push(struct channel *channel, struct dev_cookie *dev_cookie, uint8_t qid, uint16_t *status);
void dev_get_info_push(struct channel *channel, struct dev_cookie *dev_cookie, struct dev_info *info);
void dev_close_push(struct channel *channel, struct dev_cookie *dev_cookie);
void dev_register_notifier_push(struct channel *channel, notif_handler, void *cookie);
void dev_get_devmap_push(struct channel *channel, enum dev_type dev_type, struct bitmap *devmap);
int dev_set_read_only(logical_dev_id_t dev_id);
int dev_reset_read_only(logical_dev_id_t dev_id);
void dev_format_push(struct channel *channel, struct dev_cookie *dev_cookie, struct dev_format_spec *format_spec);
void
dev_get_log_push(struct channel *channel, struct dev_cookie *dev_cookie, struct dev_get_log_spec *get_log_spec);
void dev_enable_polling(logical_dev_id_t dev_id);
void dev_disable_polling(logical_dev_id_t dev_id);
void dev_gather_perf(logical_dev_id_t dev_id, struct opperf *write_perf, struct opperf *read_perf);
void dev_fw_download_push(struct channel *channel, struct dev_cookie *dev_cookie, struct dev_fw_download_spec *fw_download);
void dev_submit_wr_zeros_push(struct channel *channel, struct dev_cookie *dev_cookie, struct dev_io_op *op);
void dev_submit_deallocate_push(struct channel *channel, struct dev_cookie *dev_cookie, struct dev_io_op *op);
void dev_update_label_uuid(logical_dev_id_t dev_id, const fun_uuid_t label_uuid);
void dev_get_temp_push(struct channel *channel, logical_dev_id_t dev_id, int *temp_ptr);
void
dev_get_temperature(uint32_t slot_id, int *temp_ptr);
void dev_set_warning_temp_push(struct channel *channel, logical_dev_id_t dev_id, int temp);
void dev_set_warning_temp(uint32_t slot_id, int temp);
NULLABLE CALLER_TO_RELEASE struct fun_json *device_event_to_json(const struct fun_json *cookie, struct notification *note, NULLABLE uintptr_t subject);

--------------

storage/device/drive_plugin.h: 

struct dev_info;
typedef void(*drv_open_push)(struct channel *channel, physical_dev_id_t dev_id, void **drv_cookie, uint32_t *drv_epoch);
typedef void(*drv_close_push)(struct channel *channel, void *drv_cookie);
typedef void(*drv_submit_io_push)(struct channel *channel, void *drv_cookie, struct dev_io_op *op);
typedef void(*drv_submit_io_send)(struct frame *frame, struct flow *caller_flow, void *drv_cookie, struct dev_io_op *op);
typedef int(*drv_set_err_inject)(physical_dev_id_t dev_id, enum dev_error_type err_type);
typedef int(*drv_clear_err_inject)(physical_dev_id_t dev_id, enum dev_error_type err_type);
typedef void(*drv_submit_flush_push)(struct channel *channel, void *drv_cookie, uint8_t qid, uint32_t epoch, uint16_t *status);
typedef void(*drv_format)(struct channel *channel, void *drv_cookie, struct dev_format_spec *format_spec);
typedef void(*drv_get_log)(struct channel *channel, void *drv_cookie, struct dev_get_log_spec *get_log_spec);
typedef void(*drv_fw_download)(struct channel *channel, void *drv_cookie, struct dev_fw_download_spec *fw_download);
typedef void(*drv_submit_wr_zeros_push)(struct channel *channel, void *drv_cookie, struct dev_io_op *op);
typedef void(*drv_submit_deallocate_push)(struct channel *channel, void *drv_cookie, struct dev_io_op *op);
typedef void(*drv_simulate_unplug)(struct channel *channel, physical_dev_id_t dev_id);
typedef void(*drv_simulate_plug)(struct channel *channel, uint32_t dev_id);
typedef void(*drv_get_temp)(struct channel *channel, physical_dev_id_t dev_id, int *temp_ptr);
typedef void(*drv_set_warning_temp)(struct channel *channel, physical_dev_id_t dev_id, int temp);
typedef int(*drv_get_info_fn)(physical_dev_id_t dev_id, struct dev_info*info);
typedef void(*drv_enable_polling)(physical_dev_id_t dev_id);
typedef void(*drv_disable_polling)(physical_dev_id_t dev_id);
typedef void(*drv_gather_perf)(physical_dev_id_t dev_id, struct opperf *write_perf, struct opperf *read_perf);
typedef void(*drv_dump_debug)(physical_dev_id_t dev_id);
typedef NULLABLE CALLER_TO_RELEASE struct fun_json *(*drv_gather_stats_dict_f)(physical_dev_id_t dev_id);
struct drv_ops {char driver_name[64];drv_open_push open_push; drv_close_push close_push; drv_submit_io_push io_push; drv_submit_io_send io_send; drv_submit_flush_push flush_push; drv_submit_wr_zeros_push wr_zeros_push; drv_submit_deallocate_push deallocate_push; drv_get_info_fn get_info_fn; drv_set_err_inject set_err_injection; drv_clear_err_inject clear_err_injection; drv_format format_push; drv_enable_polling enable_polling; drv_disable_polling disable_polling; drv_gather_perf gather_perf; drv_get_log get_log_push; drv_dump_debug dump_debug; drv_simulate_unplug simulate_unplug; drv_simulate_plug simulate_plug; drv_gather_stats_dict_f gather_stats_dict; drv_fw_download fw_download_push; drv_get_temp get_temp; drv_set_warning_temp set_warning_temp;};
struct dev_cookie {drv_submit_io_push io_push; drv_submit_io_send io_send; logical_dev_id_t dev_id; void *drv_cookie; struct drv_ops *drv_ops; uint32_t nsid; uint32_t dev_epoch; enum dev_type dev_type;};
enum device_event_type {DEV_OFFLINE, DEV_ONLINE, DEV_SET_RO, DEV_RESET_RO, DEV_PERF_DEGRADED, DEV_PERF_NORMAL, DEV_FAILURE, DEV_RECOVERY_SUCCESS, DEV_RECOVERY_FAILED, DEV_FORMAT, DEV_FORMAT_SUCCESS, DEV_FORMAT_FAILED, DEV_SIMULATE_OFFLINE_ENABLE, DEV_SIMULATE_OFFLINE_DISABLE, DEV_ERR_INJECT_ENABLE, DEV_ERR_INJECT_DISABLE, DEV_EVENT_MAX,};
struct drv_device_event_info {fun_time_t timestamp; enum device_event_type sub_event_type; enum dev_type device_type; physical_dev_id_t phy_dev_id; logical_dev_id_t logical_dev_id;};
static inline bool is_dev_opened(struct dev_cookie *cookie)
 {return cookie->drv_cookie !=NULL;}
void dev_register_driver(struct drv_ops *,enum dev_type dev_type);
void dev_unregister_driver(enum dev_type type);
void dev_state_change_push(struct channel *channel, struct drv_device_event_info *drv_event);

--------------

storage/flvm/include/vol_common.h: 

bool uuids_unique(const fun_uuid_t *uuids, uint8_t count);
typedef void(*fork_push_f)(struct channel *,struct flow *,void *arg, uint8_t index);
bool lw_fork(struct channel *par_channel, struct flow *flow, faddr_t vp, uint8_t count, fork_push_f push_f, void *arg);
void crc_compute_push(struct channel *channel, uint64_t seed, uint8_t *header, uint16_t header_len, uint16_t start_off, uint8_t *input, uint32_t input_len, uint8_t *output, uint32_t *checksum);

--------------

storage/flvm/nvmem/include/nvmem.h: 

struct nvmem_sb_data {uint64_t magic; uint64_t nvmem_size; uint32_t ext_size; uint16_t ext_cnt_total; uint16_t ext_cnt_used_by_meta; uint16_t metadata_slots_start_pn; uint32_t metadata_slots_num_pages;};
static_assert(sizeof(struct nvmem_sb_data)==32,"nvmem_sb_data size is different from expected");
struct nvmem_exts_info;
struct nvmem_metadata_slot
 {fun_uuid_t uuid; uint64_t size; uint16_t lbn; uint8_t sizeofmeta; uint8_t in_use; uint8_t metadata[NVMEM_SIZE_OF_META_DATA];};
struct nvmem_alloc_req {fun_uuid_t uuid; void *metadata; uint32_t size; uint16_t sizeofmeta; uint16_t current_lbn; struct nvmem_exts_info *exts; enum fun_ret error_code; struct vol_create_req *vreq;};
struct nvmem_free_req {fun_uuid_t uuid; struct nvmem_exts_info *exts; uint16_t current_lbn; enum fun_ret error_code;};
size_t nvmem_ext_size(void);
void *nvmem_uuid_to_exts(const fun_uuid_t uuid);
uint64_t nvmem_get_allocated_size(const fun_uuid_t uuid);
void nvmem_init_alloc_req_push(struct channel *channel, struct nvmem_alloc_req *req, const fun_uuid_t uuid, uint8_t sizeofmeta, void *mdata, uint32_t size);
void nvmem_alloc_push(struct channel *channel, struct nvmem_alloc_req *req);
void nvmem_free_push(struct channel *,const fun_uuid_t uuid);
bool nvmem_is_ready(void);
bool nvmem_is_usable(void);
void nvmem_wait_for_ready_push(struct channel *channel);
int nvmem_write_push(struct channel *channel, const fun_uuid_t, struct fun_ptr_and_size *src, uint8_t src_count, uint64_t srartoff);
int nvmem_read_push(struct channel *channel, const fun_uuid_t, struct fun_ptr_and_size *src, uint8_t src_count, uint64_t srartoff);

--------------

storage/include/epnvme_ana.h: 

enum nvme_ana_grpids {NVME_INVALID_ANA_GRPID =0, NVME_OPTIMIZED_ANA_GRPID, NVME_INACCESSIBLE_ANA_GRPID, NVME_NON_OPTIMIZED_ANA_GRPID, NVME_PERSIST_LOSS_ANA_GRPID, NVME_CHANGE_ANA_GRPID, NVME_MAX_ANA_GRPID =NVME_CHANGE_ANA_GRPID,};
enum nvme_ana_state {NVME_ANA_INVALID =0x00, NVME_ANA_OPTIMIZED =0x01, NVME_ANA_NONOPTIMIZED =0x02, NVME_ANA_INACCESSIBLE =0x03, NVME_ANA_PERSISTENT_LOSS =0x04, NVME_ANA_CHANGE =0x0f,};
struct epnvme_ana_grp {uint64_t change_cnt; uint32_t ana_grpid; uint32_t num_ns; enum nvme_ana_state ana_state; uint64_t ns_bm[(NVME_MAX_NS_PER_GRP/64)+1];};

--------------

storage/include/epnvme_cp_api.h: 

enum epnvme_initiator_type {EPNVME_INIT_TYPE_FC =1, EPNVME_INIT_TYPE_OTHER =2,};
struct epnvme_create_params {uint32_t huid; uint32_t ctlid; uint32_t fnid; uint32_t pcie_bus_id; uint32_t pcie_dev_id; uint32_t pcie_fnid; bool host_pcie_supplied; fun_uuid_t ctrlr_uuid; struct fabrics_conn_params *f; enum nvme_ctrlr_type ctrlr_type; uint32_t nvme_version; bool qos_enabled; bool internally_created; struct vol_qos qos_params; bool east_west; uint16_t connections; uint16_t qdepth; int32_t status;};
struct epnvme_delete_params {fun_uuid_t ctrlr_uuid; bool internally_created; int32_t status;};
struct epnvme_attach_params {uint32_t nsid; struct vol_flow *vol_f; fun_uuid_t vol_uuid; fun_uuid_t base_vol_uuid; enum vol_type type; uint64_t nsze; uint64_t ncap; uint8_t dps; uint8_t nmic; bool encryption; bool create_nsid; enum crc_flags_type crctype; uint8_t lba_shift; uint8_t lba_shift_native; bool use_seed; uint16_t md_size; fun_uuid_t ctrlr_uuid; void *fabricst_oreq; void *kv_req; struct vol_open_req *vol_open_req; fun_uuid_t vol_nguid; enum nvme_ana_state ana_state; bool change_ana_state; bool enable_connection; bool ext_md; bool host_attach_detach; struct vol_qos attached_vol_qos; bool disable_crc_check; bool expand_volume; uint8_t disable_filter_flags; uint32_t wait_count; uint32_t chunk_size; bool disable_chunking; bool force_crc_check; enum epnvme_initiator_type initiator_type; bool disable_chunk_vector_support; bool clone_vol_attached; uint32_t host_lbasize; bool fused_cmd_support; uint32_t max_io_size; uint16_t opt_io_boundary; int32_t status;};
void epnvme_cp_ctrlr_create_push(struct channel *channel, struct epnvme_create_params *params);
void epnvme_cp_ctrlr_delete_push(struct channel *channel, struct epnvme_delete_params *params);
void epnvme_cp_ctrlr_check_status_push(struct channel *channel, struct epnvme_create_params *params);
void epnvme_cp_ctrlr_ns_attach_push(struct channel *channel, struct epnvme_attach_params *params);
void epnvme_cp_ctrlr_ns_detach_push(struct channel *channel, struct epnvme_attach_params *params);

--------------

storage/include/flvm/directory.h: 

struct vol_dir_flush_bridge_req {fun_uuid_t uuid;};
struct vol_dir_bridge_ctx {fun_uuid_t uuid; fun_uuid_t nguid; enum vol_type type; void *handle; struct fun_props_bridge *bridge; uint64_t block_size; uint64_t size_in_blocks; bool is_encrypted; bool is_compressed; bool is_clone; bool is_dedup; bool is_read_only; bool stats_enable; struct vol_crypto crypto; struct vol_compression compress; struct vol_clone clone; struct vol_dedup dedup; struct vol_snap snap; struct vol_qos qos; struct vol_flow *flow; uint32_t open_count; bool mounted; bool installing_bridge; enum crc_flags_type crctype; bool user_created; enum vol_activity activity;};
struct volume_info {enum vol_type type; uint64_t block_size; uint64_t size_in_blocks; enum crc_flags_type crctype; struct vol_qos qos; void *handle; struct vol_flow *vol_f; uint32_t open_count; uint8_t crypto_key_len; bool is_compressed; bool is_encrypted; bool is_clone; bool is_dedup; bool is_read_only; struct vol_snap snap;};
void vol_dir_install_props_bridge_push(struct channel *channel, const fun_uuid_t, struct vol_dir_bridge_ctx *ctx);
void vol_dir_prepare_bridge_ctx(fun_uuid_t uuid, fun_uuid_t nguid, void *handle, enum vol_type, struct vol_compression *compress, struct vol_crypto *crypto, struct vol_clone *clone, struct vol_dedup *dedup, struct vol_snap *snap, bool *ro, uint64_t block_size, uint64_t size_in_blocks, enum crc_flags_type crctype, struct vol_qos *qos, bool user_created, struct vol_dir_bridge_ctx *ctx);
void vol_dir_uninstall_props_bridge_push(struct channel *,const fun_uuid_t);
void vol_dir_suspend_props_bridge(const fun_uuid_t);
void vol_dir_resume_props_bridge(const fun_uuid_t);
int vol_dir_get_info(const fun_uuid_t, struct volume_info *);
int vol_dir_get_num_pvols(const fun_uuid_t, uint64_t *num_pvols);
bool vol_dir_get_encryption(const fun_uuid_t, struct vol_crypto *crypto);
bool vol_dir_get_compression(const fun_uuid_t, struct vol_compression *compress);
bool vol_dir_get_clone(const fun_uuid_t, struct vol_clone *clone);
bool vol_dir_get_dedup(const fun_uuid_t, struct vol_dedup *dedup);
bool vol_dir_get_snap(const fun_uuid_t, struct vol_snap *snap);
bool vol_dir_get_is_read_only(const fun_uuid_t);
bool vol_dir_get_is_user_created(const fun_uuid_t);
enum vol_type vol_dir_uuid_to_type(const fun_uuid_t);
bool vol_dir_valid_volume_uuid(const fun_uuid_t);
void vol_dir_init(void);
bool vol_dir_insert_flow(const fun_uuid_t, struct vol_flow *vol_f);
void vol_dir_vol_flow_setup(const fun_uuid_t, struct vol_flow *vol_f);
bool vol_dir_put_flow(const fun_uuid_t, bool del);
struct vol_flow *vol_dir_get_flow(const fun_uuid_t);
int vol_dir_vol_is_open(const fun_uuid_t);
bool vol_dir_volume_exists(const fun_uuid_t);
bool vol_dir_volume_deletable(fun_uuid_t uuid);
bool vol_dir_nguid_exists(fun_uuid_t nguid);
typedef void(*vol_dir_handler)(struct vol_flow *);
void vol_dir_flow_iterate(vol_dir_handler handler);
bool vol_dir_vol_set_activity(const fun_uuid_t, enum vol_activity op);
bool vol_dir_vol_clear_activity(const fun_uuid_t, enum vol_activity op);
bool vol_dir_activity_in_progress(fun_uuid_t uuid);
bool vol_dir_reset_clone(fun_uuid_t uuid);
bool
vol_dir_update_clone_base(fun_uuid_t clone_uuid, fun_uuid_t old_base_uuid, fun_uuid_t new_base_uuid);
void
vol_dir_change_nguid_push(struct channel *channel, const fun_uuid_t uuid, const fun_uuid_t nguid, int *status);
void vol_dir_stats_enable_push(struct channel *channel, const fun_uuid_t);
void vol_dir_stats_disable_push(struct channel *channel, const fun_uuid_t);

--------------

storage/include/flvm/plugin.h: 

struct vol_flow;
typedef void(*vol_submit_op_push_f)(struct channel *,struct vol_flow *,struct fun_vol_data_op *);
typedef struct vol_size(*vol_get_size_f)(void *handle);
typedef void(*vol_get_blocks_used_push_f)(struct channel *channel, void *handle, uint64_t *blocks_used);
typedef void(*vol_get_usage_push_f)(struct channel *channel, struct vol_flow *vol_f, struct vol_exts_info *exts, struct vol_size *vs);
typedef faddr_t(*vol_assign_flow_vps_f)(struct vol_flow *);
typedef void(*vol_create_push_f)(struct channel *,struct vol_create_req *);
typedef void(*vol_delete_push_f)(struct channel *,struct vol_delete_req *);
typedef void(*vol_open_push_f)(struct channel *,struct vol_flow *,struct vol_open_req *);
typedef void(*vol_get_stats_f)(void *,struct vol_stats *);
typedef void(*vol_close_push_f)(struct channel *,struct vol_flow *,struct vol_close_req *);
typedef void(*vol_unmap_push_f)(struct channel *,struct vol_flow *,struct vol_unmap_req *);
typedef void(*vol_inject_fault_push_f)(struct channel *,struct vol_fault_inject_req *req);
typedef void(*vol_mount_push_f)(struct channel *,struct vol_mount_req *);
typedef void(*vol_unmount_push_f)(struct channel *,struct vol_unmount_req *);
typedef void(*vol_rebuild_push_f)(struct channel *,struct vol_rebuild_req *);
typedef void(*vol_dedup_rbld_cnt_push_f)(struct channel *,struct vol_dedup_rebuild_counters_req *);
typedef void(*vol_get_status_push_f)(struct channel *,struct vol_status_req *);
typedef void(*vol_get_config_push_f)(struct channel *,struct vol_get_config_req *);
typedef void(*vol_set_config_push_f)(struct channel *,struct vol_set_config_req *);
typedef uint64_t(*vol_get_num_pvols_f)(void *handle);
typedef void(*vol_log_debug_f)(void *handle);
typedef void(*vol_fail_plex_push_f)(struct channel *,struct vol_fail_plex_req *);
typedef void(*vol_fail_plex_ack_f)(struct channel *,struct vol_fail_plex_ack *);
typedef void(*vol_snap_create_push_f)(struct channel *,struct vol_flow *,struct vol_snap_create_req *);
typedef void(*vol_snap_delete_push_f)(struct channel *,struct vol_flow *,struct vol_snap_delete_req *);
typedef void(*vol_snap_mount_push_f)(struct channel *,struct vol_flow *,struct vol_snap_mount_req *);
typedef void(*vol_snap_get_changed_blocks_push_f)(struct channel *,struct vol_flow *,struct vol_snap_changed_blocks_info *);
typedef void(*vol_snap_get_size_f)(struct channel *,struct vol_flow *,const fun_uuid_t snap_uuid, struct vol_size *);
typedef void(*vol_snap_get_usage_f)(struct channel *,struct vol_flow *,struct vol_exts_info *,struct vol_size *);
typedef void(*vol_snap_get_list_f)(struct channel *,struct vol_flow *,struct vol_snap_list_req *);
typedef void(*vol_resize_push_f)(struct channel *,struct vol_resize_req *);
typedef void(*vol_add_path_push_f)(struct channel *,struct vol_path_req *);
typedef void(*vol_remove_path_push_f)(struct channel *,struct vol_path_req *);
typedef void(*vol_inject_fault_config_f)(struct channel *,struct vol_fault_inject_req *);
typedef void(*vol_relocate_plex_push_f)(struct channel *,struct vol_relocate_plex_req *);
typedef void(*vol_scrub_push_f)(struct channel *,struct vol_scrub_req *);
typedef void(*vol_debug_push_f)(struct channel *,struct vol_debug_req *);
typedef void(*vol_get_alloc_blks_push_f)(struct channel *,struct vol_flow *,struct vol_alloc_blks_info *);
struct vol_handler {vol_create_push_f create_push; vol_delete_push_f delete_push; vol_submit_op_push_f submit_op_push; vol_submit_op_push_f submit_write_op_push; vol_submit_op_push_f submit_read_op_push; vol_assign_flow_vps_f assign_flow_vps_handler; vol_get_size_f get_size; vol_get_blocks_used_push_f get_blocks_used_push; vol_get_usage_push_f get_usage_push; vol_open_push_f open_push; vol_get_stats_f get_stats; vol_close_push_f close_push; vol_unmap_push_f unmap_push; vol_inject_fault_push_f inject_fault_push; vol_mount_push_f mount_push; vol_unmount_push_f unmount_push; vol_rebuild_push_f rebuild_push; vol_get_status_push_f get_status_push; vol_get_config_push_f get_config_push; vol_set_config_push_f set_config_push; vol_get_num_pvols_f get_num_pvols; vol_log_debug_f log_debug; enum nvme_ns_flags extra_features; vol_fail_plex_push_f fail_plex_push; vol_fail_plex_ack_f fail_plex_ack; vol_snap_create_push_f snap_create_push; vol_snap_delete_push_f snap_delete_push; vol_snap_mount_push_f snap_mount_push; vol_snap_get_changed_blocks_push_f snap_get_changed_blocks_push; vol_get_alloc_blks_push_f get_alloc_blks_push; vol_snap_get_size_f snap_get_size; vol_snap_get_usage_f snap_get_usage; vol_snap_get_list_f snap_get_list; vol_resize_push_f resize_push; vol_add_path_push_f add_path_push; vol_remove_path_push_f remove_path_push; vol_debug_push_f debug_push; vol_inject_fault_config_f inject_fault_config_push; vol_relocate_plex_push_f relocate_plex_push; vol_scrub_push_f scrub_push; vol_dedup_rbld_cnt_push_f dedup_rbld_cnt;};
void vol_register_handler(struct vol_handler *,enum vol_type);

--------------

storage/include/flvm/vol_enums.h: 

enum vol_type {VOL_TYPES(GEN_VOL_TYPE_ENUM)};
enum vol_cost_idx {VP_COST_INDEX(GEN_VOL_COST_ENUM)};
extern const char *const vol_cost_indx_str[VOL_LAST_COST_IDX +1];
static_assert(RSV_TYPE_FIRST >=VOL_TYPE_LAST,"increase storage_wp.h:RSV_TYPE_FIRST if VOL_TYPE_LAST changes");
enum fun_vol_admin_opcode {VOL_ADMIN_OPCODE_GET_SIZE =0, VOL_ADMIN_OPCODE_CREATE =1, VOL_ADMIN_OPCODE_DELETE =2, VOL_ADMIN_OPCODE_INJECT_FAULT =3, VOL_ADMIN_OPCODE_MOUNT =4, VOL_ADMIN_OPCODE_UNMOUNT =5, VOL_ADMIN_OPCODE_REBUILD =6, VOL_ADMIN_OPCODE_STATUS =7, VOL_ADMIN_OPCODE_FAIL_PLEX =8, VOL_ADMIN_OPCODE_FAIL_PLEX_ACK =9, VOL_ADMIN_OPCODE_RESIZE =10, VOL_ADMIN_OPCODE_ADD_PATH =11, VOL_ADMIN_OPCODE_REMOVE_PATH =12, VOL_ADMIN_OPCODE_CONFIG_FAULT =13, VOL_ADMIN_OPCODE_GET_CHANGES =14, VOL_ADMIN_OPCODE_GET_ALLOC_BLKS =15, VOL_ADMIN_OPCODE_SCRUB =16, VOL_ADMIN_OPCODE_GET_CONFIG =17, VOL_ADMIN_OPCODE_DELINK =18, VOL_ADMIN_OPCODE_CHANGE_NGUID =19, VOL_ADMIN_OPCODE_SET_CONFIG =20, VOL_ADMIN_OPCODE_UPDATE_CLONE =21, VOL_ADMIN_OPCODE_DEDUP_RBLD_CNT =22, VOL_ADMIN_OPCODE_HOLD_IO =23, VOL_ADMIN_OPCODE_RELEASE_IO =24,};
enum drive_state {DRIVE_STATES(GEN_DRIVE_STATE_ENUM)};
enum vol_rebuild_cmd {VOL_REBUILD_PAUSE, VOL_REBUILD_RESUME, VOL_REBUILD_ISSUE,};
enum vol_scrub_cmd {VOL_SCRUB_ISSUE,};
enum vol_state {VOL_STATES(GEN_VOL_STATE_ENUM)};
enum svol_rebuild_state {SVOL_REBUILD_NOT_NEEDED, SVOL_REBUILD_PENDING, SVOL_REBUILD_IN_PROGRESS, SVOL_REBUILD_COMPLETED, SVOL_REBUILD_PAUSED,};
enum vol_status_cmd {VOL_REBUILD_STATUS =1, VOL_SCRUB_STATUS =2};
enum vol_get_config_cmd {VOL_CONFIG_SUB_NONE =0, VOL_CONFIG_SUB_PVG_ALL =1,};
enum clone_hydration_flag {CLONE_HYDRATION_INVALID =0, CLONE_HYDRATION_NONE =1, CLONE_HYDRATION_FULL =2, CLONE_HYDRATION_ON_READ =3,};
enum vol_activity {VOL_ACTIVITY_SNAP_CREATE =1<<0, VOL_ACTIVITY_SNAP_DELETE =1<<1, VOL_ACTIVITY_VOL_OPEN =1<<2,};
enum vol_status_code {VOL_STATUS_CODES(GEN_VOL_STATUS_CODE_ENUM)};

--------------

storage/include/flvm/volume.h: 

WORKERPOOL_REFERENCE(volume_vp_pool);
extern const char *const vol_type_str[VOL_TYPE_LAST +1];
extern const char *const vol_type_desc[VOL_TYPE_LAST +1];
extern const char *const drive_state_str[DRIVE_STATE_LAST +1];
extern const char *const drive_state_desc[DRIVE_STATE_LAST +1];
extern const char *const vol_state_str[VOL_STATE_LAST +1];
extern const char *const vol_state_desc[VOL_STATE_LAST +1];
struct vol_admin_common_req {enum fun_vol_admin_opcode opcode;};
struct vol_admin_op {struct vol_flow *vol_f; enum fun_vol_admin_opcode opcode; void *priv; struct vol_crypto *crypto;};
enum vol_debug_opcode {VOL_DEBUG_GET_SB =0, VOL_DEBUG_GET_MAP =1, VOL_DEBUG_GET_INFO =2, VOL_DEBUG_GET_PLEX_SB =3, VOL_DEBUG_GET_CHUNK_HEADER =4,};
enum vol_debug_format_type {VOL_DEBUG_FORMAT_RAW =0, VOL_DEBUG_FORMAT_PARSED =1,};
struct vol_debug_req {struct vol_flow *vol_f; enum vol_type voltype; enum vol_debug_opcode opcode; enum vol_debug_format_type format; uint16_t cur_attempt; uint16_t max_retry; uint32_t lbc; uint64_t slba; uint32_t chunkno; void **ret_json;};
struct vol_get_used_slba_range {int status; uint64_t start_lba; uint64_t end_lba;};
struct repvol_init_args {union{fun_uuid_t uuid[MAX_PVOLS];}pvol; uint8_t num_pvols; uint8_t min_replicas_insync; uint8_t preferred_plex; bool transient_error_no_retry;
};
struct ecvol_init_args {union{fun_uuid_t uuid[MAX_PVOLS];}pvol; uint8_t num_pvols; uint8_t ndata; uint8_t nparity; bool transient_error_no_retry;
};
struct concatvol_init_args {uint64_t max_size; fun_uuid_t pvol_uuid[MAX_PVOLS];uint8_t num_pvols;};
struct stripevol_init_args {fun_uuid_t uuid[MAX_PVOLS];uint8_t nplex; uint8_t stripe_unit_blks;};
struct vol_create_req {struct vol_admin_common_req c; struct hu_fn_flow *hu_fn_f; uint64_t size; uint64_t block_size; fun_uuid_t uuid; fun_uuid_t nguid; enum vol_type type; uint32_t nsid; enum nvme_ns_flags flags; enum crc_flags_type crctype; struct vol_crypto crypto; struct vol_compression compress; struct vol_clone clone; struct vol_dedup dedup; struct vol_qos qos; bool ro; bool user_created; uint64_t placement_cookie; fun_time_t start_time; fun_time_t vol_handler_create_time; uint16_t md_size; union{struct concatvol_init_args concat; struct{union{fun_uuid_t uuid;}svol; fun_uuid_t journal_uuid; uint8_t sblk_group; uint8_t chunk_block_bits; uint8_t flushthreads; uint8_t numextentbits; uint8_t maxversions; uint8_t maxsnapspace_pct; uint16_t maxsnapshots; uint8_t block_packing_bits; bool dedup_map; bool dedup_pool;}lsv; struct repvol_init_args repvol; struct {struct fabrics_conn_params *f; uint32_t remote_nsid; uint8_t connections; uint8_t mp_policy; bool compress_and_encrypt;}rdsvol; struct ecvol_init_args ecvol; struct {bool no_mount; bool use_ddr; uint16_t write_delay_usec; uint16_t read_delay_usec;}memvol; struct {fun_uuid_t base_uuid;}snapvol; struct {fun_uuid_t base_uuid; void *clone_handle;}clonevol; struct {fun_uuid_t drive_uuid;}blt; struct {uint8_t drive_id;}nvmevol; struct {uint16_t read_delay_usec; uint16_t write_delay_usec;}nullvol; struct {uint8_t preferred_id;}filevol; struct {uint16_t write_delay_usec;}nvmemvol; struct {fun_uuid_t partvg_uuid; uint16_t stripe_width; uint32_t ext_alloc_policy; uint64_t svol_grp_id;}partvol; struct {fun_uuid_t svol_uuid[MAX_SVOLS_PER_PVG];uint16_t num_svols; uint16_t stripe_width; uint32_t ext_alloc_policy; uint64_t svol_grp_id; uint64_t svol_size; uint64_t ext_size;}partvg; struct stripevol_init_args stripevol;}p; int status; void *handle;
};
struct vol_delete_req {enum vol_type type; fun_uuid_t uuid; void *handle; fun_time_t start_time; bool async; int status;};
struct vol_path_req {enum vol_type type; fun_uuid_t uuid; struct fabrics_conn_params f; void *handle; fun_time_t start_time; int status;};
struct vol_append_req {struct vol_admin_common_req c; fun_uuid_t concat_uuid; fun_uuid_t participant_uuid; struct hu_fn_flow *hu_fn_f; void *cv_handle; int status; uint64_t assigned_slba;};
struct vol_open_req {uint32_t nsid; bool is_flow_malloced; fun_uuid_t uuid; bool ns_mgmt; bool attach_on_cclinux; bool enable_internal_retry; int status; struct vol_flow *vol_f; struct vol_flow *vol_filter_io_flow; uint8_t num_filterqs;};
struct vol_flush_req {struct frame *frame; fun_time_t flush_start; fun_time_t flush_timeout; int status;};
enum vol_fault_inject_at {FAULT_INJECT_AT_VOL =1<<0, FAULT_INJECT_AT_COMPRESS =1<<1, FAULT_INJECT_AT_CRYPTO =1<<2, FAULT_INJECT_AT_FLVM =1<<3};
struct vol_close_req {struct vol_flush_req flush_req; int status;};
struct vol_exts_info {uint64_t extent_size; uint32_t num_exts; uint32_t *extents;};
struct vol_unmap_req {struct vol_exts_info exts; int status;};
struct io_timer_args {timerid_t io_timer; struct timer_arg args; fun_time_t start_time; fun_time_t timeout;};
enum vol_fault_op_type {VOL_FAULT_OP_TYPE_CREATE =1<<0, VOL_FAULT_OP_TYPE_MOUNT =1<<1, VOL_FAULT_OP_TYPE_DELETE =1<<2, VOL_FAULT_OP_TYPE_VOL_READ =1<<3, VOL_FAULT_OP_TYPE_VOL_WRITE =1<<4, VOL_FAULT_OP_TYPE_PVG =1<<5};
enum fault_type {FAULT_TYPE_NONE, FAULT_TYPE_CRASH, FAULT_TYPE_DELAY, FAULT_TYPE_ERROR, FAULT_TYPE_DATA_CORRUPT, FAULT_TYPE_CRC_CORRUPT, FAULT_TYPE_SLBA_CORRUPT, FAULT_TYPE_ENOSPC, FAULT_TYPE_LAST};
struct fault_inject_opt {uint32_t fault_id; uint32_t num_faults; int delay_msecs; uint32_t skip_cnt; int err_ret_code; uint32_t random_pct; uint64_t fault_reserved;};
struct vol_fault_inject_req {fun_uuid_t uuid; enum vol_type type; enum vol_fault_op_type op_type; enum fault_type fault_type; enum vol_fault_inject_at inject_at; struct fault_inject_opt fi_opt; void *handle; int status;};
struct vol_fault_config {enum vol_fault_op_type op_type; enum fault_type fault_type; struct fault_inject_opt fi_opt;};
enum list_type {BLOCK_LIST, RANGE_LIST, UNKNOWN_LIST};
struct vol_snap_changed_blocks_info {void *nss_context; fun_uuid_t snap1; fun_uuid_t snap2; uint64_t slba; uint64_t nlb; struct bitmap *change_map; uint64_t block_size; size_t blocks_done; int status;};
struct vol_alloc_blks_info {void *nss_context; fun_uuid_t uuid; uint64_t slba; uint64_t nlb; struct bitmap *alloc_map; uint64_t block_size; size_t blocks_done; int status;};
struct vol_get_changes_req {enum vol_type type; enum list_type format; struct vol_snap_changed_blocks_info cbi; int status;};
struct vol_get_alloc_blks_req {enum vol_type type; enum list_type format; struct vol_alloc_blks_info abi; int status;};
struct vol_delink_req {fun_uuid_t clone_uuid; fun_uuid_t base_uuid; int status;};
struct vol_change_nguid_req {fun_uuid_t uuid; fun_uuid_t nguid; int status;};
struct vol_update_clone_req {fun_uuid_t clone_uuid; fun_uuid_t old_base_uuid; fun_uuid_t new_base_uuid; int status;};
enum dedup_rebuild_counters {DEDUP_RBLD_CNT_INVALID=0, DEDUP_RBLD_CNT_BEGIN=1, DEDUP_RBLD_CNT_ABORT=2, DEDUP_RBLD_CNT_QUERY=3,};
struct vol_dedup_rebuild_counters_req {fun_uuid_t uuid; enum dedup_rebuild_counters action; void *handle; int status; bool active; uint32_t total_chunks; uint32_t done_chunks;};
struct vol_hold_io_req {fun_uuid_t uuid; fun_time_t start_time; fun_time_t timeout; int status;};
struct vol_release_io_req {fun_uuid_t uuid; int status;};
struct vol_mount_req {fun_uuid_t uuid; fun_uuid_t nguid; enum vol_type type; enum nvme_ns_flags flags; struct vol_crypto crypto; struct vol_compression compress; struct vol_clone clone; struct vol_dedup dedup; struct vol_qos qos; bool ro; bool user_created; uint64_t size; uint64_t block_size; uint64_t placement_cookie; enum crc_flags_type crctype; union{struct{uint64_t volume_id;}memvol; struct {uint64_t volume_id;}emmcvol; struct {union{fun_uuid_t uuid;}svol; fun_uuid_t journal_uuid; uint8_t sblk_group; uint8_t flushthreads;}lsv; struct {fun_uuid_t base_uuid;}snapvol; struct {struct repvol_init_args init_args; fun_uuid_t failed_uuid[MAX_PVOLS];uint8_t failed_count;}repvol; struct {struct ecvol_init_args init_args; fun_uuid_t failed_uuid[MAX_PVOLS];uint8_t failed_count;}ecvol; struct stripevol_init_args stripevol; struct {fun_uuid_t partvg_uuid;}partvol; struct {fun_uuid_t svol_uuid[MAX_SVOLS_PER_PVG];uint16_t num_svols; uint64_t svol_size; uint64_t ext_size;}partvg;}p; int status; void *handle;
};
struct vol_unmount_req {fun_uuid_t uuid; enum vol_type type; void *handle; int status;};
struct vol_rebuild_req {fun_uuid_t uuid; enum vol_type type; fun_uuid_t failed_uuid; fun_uuid_t spare_uuid; enum vol_type spare_type; enum vol_rebuild_cmd cmd; uint16_t rate; void *handle; int status;};
struct vol_fail_plex_req {fun_uuid_t uuid; enum vol_type type; fun_uuid_t fail_uuid; bool force; void *handle; int status;};
struct vol_fail_plex_ack {fun_uuid_t uuid; enum vol_type type; fun_uuid_t fail_uuids[MAX_PVOLS];uint8_t fail_count; void *handle; int status;};
struct vol_resize_req {fun_uuid_t uuid; enum vol_type type; uint64_t new_size; void *handle; union{struct{fun_uuid_t partvg_uuid; uint16_t stripe_width; uint32_t ext_alloc_policy; uint64_t svol_grp_id;}partvol; struct {fun_uuid_t svol_uuid[MAX_SVOLS_PER_PVG];uint16_t num_svols; uint16_t stripe_width; uint32_t ext_alloc_policy; uint64_t svol_grp_id; uint64_t svol_size; uint64_t ext_size;}partvg;}p; int status;
};
struct fun_vol_pi_crc16 {uint16_t crc; union{uint16_t app_tag; uint16_t compressed_len;};uint32_t ref_tag;
};
struct fun_vol_pi_crc32 {uint32_t crc; union{uint16_t app_tag; uint16_t compressed_len;};uint8_t ref_tag[10];
};
struct fun_vol_pi_crc64 {uint64_t crc; union{uint16_t app_tag; uint16_t compressed_len;};union {uint8_t ref_tag[6];struct{uint16_t offset; uint16_t ref_tag_short[2];};};
};
struct vol_relocate_plex_req {fun_uuid_t uuid; fun_uuid_t base_uuid; fun_uuid_t relocate_uuid; struct vol_open_req open_req; enum vol_type type; void *handle; int status;};
struct vol_scrub_req {enum vol_scrub_cmd cmd; enum vol_type type; fun_uuid_t uuid; struct vol_open_req open_req; uint64_t start_lba; uint64_t end_lba; uint16_t rate; void *handle; int status;};
struct fun_vol_blk_hdr {union{struct fun_vol_pi_crc16 crc16; struct fun_vol_pi_crc32 crc32; struct fun_vol_pi_crc64 crc64;};
};
struct fun_vol_blkhdr_type {uint8_t crctype; uint8_t md_size;};
static_assert(sizeof(struct fun_vol_blk_hdr)==FUN_VOL_BLK_HDR_SIZE,"compile-time assertion failed");
uintptr_t blkhdr_get_f1addr_meta(struct fun_vol_blk_hdr *blkhdr, uint32_t crctype);
uint64_t blkhdr_get_crc_calculated(struct fun_vol_blk_hdr *blkhdr, uint32_t crctype);
uint16_t *blkhdr_get_compressed_len_ptr(struct fun_vol_blk_hdr *blkhdr, uint32_t crctype);
uint16_t blkhdr_get_compressed_len(struct fun_vol_blk_hdr *blkhdr, uint32_t crctype);
enum fun_vol_data_op_status_flags {VOL_DATA_OP_READ_BEFORE_WRITE =1<<0, VOL_DATA_OP_INTERNAL_IO =1<<4, VOL_DATA_OP_UPDATE_FLAGS_IN_STATUS_REL_PTR =1<<5, VOL_DATA_OP_DISABLE_CRYPTO =1<<6, VOL_DATA_OP_DISABLE_COMPRESS =1<<7,};
struct fun_vol_acc_op {void *mbuf; void *mbuf_ptr; size_t mbuf_size; void *acc_ptr; struct fun_mbuf *acc_mbuf; struct fun_ptr_and_size *in_vectors; struct fun_ptr_and_size *out_vectors; size_t *out_buf_capacity_arr; uint16_t num_vectors; uint64_t slba; uint16_t *status_p; uint16_t status; uint8_t *status_flags_p; struct fun_vol_data_op *vol_op; struct fun_vol_blk_hdr *blkhdr; size_t allocated_size; size_t acc_size; zip_result_t *zip_status; struct vol_zip_flow *zip_f; struct vol_xts_flow *xts_f; uint64_t xtweak[2];bool encrypt; bool compress; bool crc; bool is_crypto_done_required; struct fun_mbuf **alloced_multi_mbufs; bool release_alloced_multi_mbufs;};
struct fun_vol_data_op {uint64_t slba; uint64_t nlb; union{struct fun_vol_blk_hdr *blkhdr; uint8_t *meta;};union {struct{uint8_t opcode; uint8_t buf_type; uint8_t num_vectors; uint8_t status_flags; uint16_t status; uint16_t skip_write_map;};uint64_t dummy;};uint64_t snap_id; union {struct fun_mbuf *buf; struct fun_mbuf_list *iovec; struct fun_ptr_and_size *vectors;};uint16_t *failure_status; struct opstats_noperf opstat;
};
static_assert(sizeof(struct fun_vol_data_op)<=FUN_VOL_DATA_OP_SIZE,"fun_vol_data_op size threshold");
struct svol_rebuild_status {fun_uuid_t uuid; enum svol_rebuild_state state; uint8_t completion_pct; uint64_t num_reads_failed; uint64_t num_writes_failed;};
struct svol_scrub_status {uint64_t scrub_blkhdr_mismatch; uint64_t scrub_data_mismatch; uint64_t scrub_size_mismatch; uint64_t scrub_blkhdr_match; uint64_t scrub_data_match; uint64_t scrub_success; uint64_t scrub_read_err; uint8_t completion_pct;};
struct vol_status_data {enum vol_state state; union{struct{struct svol_rebuild_status svols[0];}rebuild; struct svol_scrub_status scrub_status;};
};
struct vol_status_req {fun_uuid_t uuid; enum vol_type type; enum vol_status_cmd subcmd; void *handle; union{struct{uint8_t numsvols;}repvol; struct {uint8_t numsvols;}ecvol;};int status; struct vol_status_data resp;
};
struct vol_get_config_data {union{struct{fun_uuid_t svol_uuids[MAX_SVOLS_PER_PVG];uint32_t num_svols; fun_uuid_t pv_uuids[MAX_PVS_PER_PVG];uint32_t num_pvs; uint32_t num_pvg_exts; uint32_t free_pvg_exts;}partvg; struct {uint64_t num_vols; struct{fun_uuid_t uuid; uint64_t size;}vol[MAX_NVMEM_VOLS];}nvmemvol;};
};
struct vol_get_config_req {fun_uuid_t uuid; enum vol_type type; enum vol_get_config_cmd subcmd; void *handle; union{struct{uint8_t numsvols;}partvg; struct {uint64_t max_vols;}nvmemvol;};int status; struct vol_get_config_data resp;
};
enum vol_set_config_cmd {VOL_SETCONFIG_NONE =0, VOL_SETCONFIG_EC_ROTATION_UNIT =1,};
struct vol_set_config_req {fun_uuid_t uuid; void *handle; enum vol_set_config_cmd subcmd; uint64_t arg; int status;};
struct vol_size {uint64_t nlb; uint64_t block_size; uint64_t max_io_size_in_blocks; uint64_t blocks_used; uint64_t pbytes_used; uint64_t pblock_hwm; uint32_t flags; uint8_t blkhdr_version; uint8_t maxsnapspace_pct; uint16_t opt_io_boundary; struct fun_vol_blkhdr_type blkhdr_type; enum vol_type remote_vol_type; enum nvme_ns_flags ns_flags; uint32_t blkhdr_mem_sz;};
struct vol_flow;
void *vol_flow_get_handle(struct vol_flow *);
void vol_increment_stats_generation_count(struct vol_flow *);
struct vol_stats {uint64_t flvm_vol_size_blocks; uint64_t flvm_vol_util_blocks; uint64_t flvm_block_size; uint64_t fault_injection; enum vol_type type; enum vol_state state; faddr_t vol_f_vp; faddr_t filter_io_f_vp; struct{uint64_t num_reads; uint64_t num_writes; uint64_t read_bytes; uint64_t write_bytes; uint64_t read_total_latency; uint64_t read_avg_latency; uint64_t read_min_latency; uint64_t read_max_latency; uint64_t write_total_latency; uint64_t write_avg_latency; uint64_t write_min_latency; uint64_t write_max_latency; uint64_t reads_pending; uint64_t writes_pending; uint32_t min_read_only_iops; uint32_t max_read_only_iops; uint32_t min_write_iops; uint32_t max_write_iops; uint64_t num_int_reads; uint64_t read_int_bytes; uint64_t read_int_total_latency; uint64_t read_int_avg_latency; uint64_t read_int_min_latency; uint64_t read_int_max_latency; uint64_t num_int_writes; uint64_t write_int_bytes; uint64_t write_int_total_latency; uint64_t write_int_avg_latency; uint64_t write_int_min_latency; uint64_t write_int_max_latency; uint64_t req_arrival_rate; uint64_t read_data_corruptions; uint64_t read_crc_corruptions; uint64_t read_slba_corruptions; uint64_t write_data_corruptions; uint64_t write_crc_corruptions; uint64_t reads_sent; uint64_t writes_sent; }common; union {struct{struct{uint64_t num_reads; uint64_t num_writes;}ls; struct {uint64_t num_reads; uint64_t num_writes;}lbs; uint64_t num_ses_allocated; uint64_t se_size; uint64_t num_extents; uint64_t extent_size; fun_uuid_t drive_uuid;}blt; struct {uint64_t recovery; uint64_t rmw; uint64_t multiblk_reads; uint64_t write_outstanding; uint64_t ec_req_outstanding; uint64_t plex_read_fail; uint64_t plex_write_fail; uint64_t read_fail; uint64_t write_fail; uint64_t transient_write_fail; uint64_t unused_start_lba; uint64_t rebuild_boundary; uint64_t super_writes_failed; uint64_t enospc_err; faddr_t read_vp; uint64_t num_pvols; fun_uuid_t pvols[MAX_PVOLS];}ecvol; struct {uint64_t num_replica; fun_uuid_t pvols[MAX_PVOLS];}repvol; struct {uint8_t drive_id; faddr_t done_vp;}nvmevol; struct {uint64_t read_failures; uint64_t write_failures; uint64_t reads_done; uint64_t writes_done; size_t md_size; uint32_t remote_port; uint32_t remote_ip; uint32_t ctrlr_id; uint32_t remote_nsid; uint8_t remote_vol_type; uint8_t connections; uint8_t mp_policy; uint8_t blkhdr_version; uint16_t opt_io_boundary; uint32_t ns_flags; uint32_t max_io_size; uint8_t subsys_nqn[NQN_MAX_LENGTH];uint8_t host_nqn[NQN_MAX_LENGTH];fun_uuid_t nguid;}rds; struct {uint64_t read_fail; uint64_t write_fail; uint64_t sblk_reads; uint64_t sblk_writes; uint64_t sblk_read_fail; uint64_t sblk_write_fail; uint64_t reads_before_write; uint64_t cache_reads; uint64_t rmwbuf_cache_reads; uint64_t compact_blks; uint64_t compact_bytes; uint64_t rmw_blks; uint64_t rmw_bytes; uint32_t total_chunks; uint32_t ct_hwm; uint32_t ct_heap_min_chunks; uint32_t ct_heap_min_freeblks; uint32_t ct_heap_max_chunks; uint32_t ct_heap_max_freeblks; uint32_t ct_active_heaplen; uint32_t ct_active_root_freepblks; uint32_t ct_inactive_heaplen; uint32_t ct_inactive_root_freepblks; uint32_t ct_total_freepblks; uint64_t ct_heap_ops; uint32_t chunk_size; uint32_t dirty_blks; uint64_t bhdr_reads; uint64_t bhdr_hits; uint64_t bhdr_direct; uint64_t chunk_wait; uint64_t chunk_wait_latency_usec; uint64_t chunk_flush; uint64_t chunk_flush_latency_usec; uint64_t chunk_compact; uint64_t chunk_compact_latency_usec; uint64_t chunk_relocate_latency_usec; uint64_t chunk_rmw; uint64_t chunk_rmw_latency_usec; uint64_t chunk_init_latency_usec; uint64_t chunk_active_latency_usec; uint64_t chunk_frag; uint64_t remount_latency_usec; uint64_t bmt_update; uint64_t bmt_update_latency_usec; uint64_t bmt_sblks; uint64_t bmtlog_write; uint64_t bmtlog_latency; uint64_t bmtjnl_tran; uint64_t bmtjnl_full_count; uint64_t bmtjnl_wait_done; uint64_t ctlog_flush; uint64_t snap_create_req; uint64_t snap_delete_req; uint64_t snap_available; uint64_t maxsnapspace_pct; uint64_t snap_ready; uint64_t snap_reinit_pct; uint64_t snap_reads; uint64_t snapbmt_reads; uint64_t snapbmt_read_total_latency_usec; uint64_t snapbmt_writes; uint64_t snapbmt_write_total_latency_usec; fun_uuid_t svol_uuid; fun_uuid_t jvol_uuid; faddr_t bgvp; faddr_t cpvp;}lsv; struct {uint32_t stripe_unit;}stripevol; struct {uint64_t num_extents; uint64_t num_free_extents; uint64_t extent_size; uint32_t num_svols; uint32_t num_pvs; uint32_t num_pv_creates; uint32_t num_pv_deletes; uint32_t num_pv_mounts; uint32_t num_pv_unmounts; uint32_t num_pv_create_fails; uint64_t last_pv_admin_op_ts; fun_uuid_t md_vol_uuid;}partvg; struct {uint64_t num_extents; uint64_t extent_size; uint64_t pv_blocks_used; uint64_t pv_pbytes_used; uint32_t snap_blocks_used; uint32_t snap_pbytes_used; uint32_t snap_usage_pct; uint32_t max_snap_space_pct; uint32_t flags; fun_uuid_t pvg_uuid;}partvol; struct {fun_uuid_t base_uuid;}snapvol;};
};
typedef uint64_t snap_id_t;
struct vol_snap_create_req {fun_uuid_t snap_uuid; struct vol_exts_info exts; snap_id_t snap_id; int *status;};
struct vol_snap_delete_req {fun_uuid_t snap_uuid; bool internal; int *status;};
struct vol_snap_mount_req {fun_uuid_t snap_uuid; snap_id_t snap_id; int *status;};
struct vol_snap_list_req {struct vol_exts_info exts; fun_uuid_t *uuid; size_t max; int status; size_t pushed; size_t total;};
struct vol_interceptor_op {struct fun_vol_data_op *orig_op; struct fun_vol_data_op *mirror_op; struct vol_flow *vol_f; void *handle; int status;};
typedef void(*vol_interceptor_push_f)(struct channel *,struct vol_interceptor_op *);
struct vol_interceptor_ctx {void *handle; vol_interceptor_push_f push_fn;};
enum interceptor_op_type {INTERCEPTOR_ADD =1, INTERCEPTOR_DELETE =2,};
struct vol_interceptor_admin_req {enum interceptor_op_type type; void *handle; struct vol_flow *vol_f; struct vol_flush_req *flush_req; vol_interceptor_push_f push_fn; int status;};
const char *vol_status_code_to_string(int status);
struct vol_size vol_get_size(struct vol_flow *vol_f);
void vol_get_blocks_used_push(struct channel *channel, struct vol_flow *vol_f, uint64_t *blocks_used);
void vol_get_num_pvols(void *handle, enum vol_type type, uint64_t *num_pvols);
void volume_op_cost_get(enum vol_cost_idx indx, struct vol_qos *qos, uint64_t *read_cost, uint64_t *write_cost);
faddr_t vol_vp_get_by_cookie(enum vol_type type, enum vol_cost_idx indx, uint64_t placement_cookie, struct vol_qos *qos);
faddr_t vol_vp_get_by_affinity(enum vol_type type, enum vol_cost_idx indx, faddr_t affinity_vp, struct vol_qos *qos);
void vol_vp_put(faddr_t vp, enum vol_cost_idx indx, int typ, struct vol_qos *qos);
void vol_vp_put_by_cookie(faddr_t vp, enum vol_cost_idx indx, uint64_t cookie, int typ, struct vol_qos *iops);
void vol_create_call_push(struct channel *,const fun_uuid_t, int voltype, uint64_t size, uint32_t block_size, bool no_mount, struct vol_create_req *cr, struct vol_admin_op *op);
void rebuild_state_to_string(enum svol_rebuild_state state, char *str, int bufsize);
void vol_state_to_string(enum vol_state state, char *str, int bufsize);
void vol_admin_open_push(struct channel *,struct vol_open_req *req);
void vol_admin_close_push(struct channel *channel, struct vol_flow *vol_f);
void vol_admin_unmap_push(struct channel *channel, struct vol_flow *vol_f, struct vol_unmap_req *req);
bool vol_close_pending(struct vol_flow *vol_f);
void vol_admin_flush_push(struct channel *channel, struct vol_flow *vol_f, struct vol_flush_req *freq);
void vol_admin_interceptor_push(struct channel *channel, struct vol_interceptor_admin_req *req);
void vol_write_push_direct(struct channel *channel, struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_relocate_push(struct channel *,struct vol_relocate_plex_req *);
void vol_scrub_push(struct channel *,struct vol_scrub_req *);
void vol_debug(void);
void vol_print(struct vol_flow *vol_f);
void vol_admin_create_push(struct channel *,struct vol_create_req *);
void vol_admin_delete_push(struct channel *,struct vol_delete_req *);
void deep_copy_vol_crypto(struct vol_crypto *dest, struct vol_crypto *src);
void deep_copy_vol_clone(struct vol_clone *,struct vol_clone *);
void deep_copy_vol_dedup(struct vol_dedup *,struct vol_dedup *);
void deep_copy_vol_snap(struct vol_snap *,struct vol_snap *);
void deep_copy_vol_qos(struct vol_qos *dest, struct vol_qos *src);
struct vol_qos divide_vol_qos(struct vol_qos *qos, uint8_t divisor);
void set_default_vol_qos(struct vol_qos *dest, uint64_t block_size);
static inline enum vol_type
vol_type_str_to_enum(const char *type_str)
 {int i; for(i =1; i <VOL_TYPE_LAST; i++){if(!strcmp(type_str, vol_type_str[i])){break;}}return i;
}
void vol_submit_read_call_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_submit_write_call_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_submit_op_call_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_submit_op_call_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_submit_read_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_submit_write_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_submit_read_with_failure_ptr_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void vol_submit_write_with_failure_ptr_push(struct channel *,struct vol_flow *vol_f, struct fun_vol_data_op *op);
void
vol_submit_read_send(struct channel *channel, struct vol_flow *vol_f, struct fun_vol_data_op *op);
void
vol_submit_read_with_failure_ptr_send(struct channel *channel, struct vol_flow *vol_f, struct fun_vol_data_op *op);
void
vol_submit_write_send(struct channel *channel, struct vol_flow *vol_f, struct fun_vol_data_op *op);
void
vol_submit_write_with_failure_ptr_send(struct channel *channel, struct vol_flow *vol_f, struct fun_vol_data_op *op);
void deep_copy_vol_compress(struct vol_compression *dest, struct vol_compression *src);
struct fun_admin_vol_req *metaflow_admin_vol_alloca_req(struct channel *channel, struct metaflow *mf, unsigned int common_flags, void *common_cookie);
struct vol_create_req *metaflow_admin_vol_init_req_push(struct channel *channel, struct metaflow *mf, struct fun_admin_vol_req *vol_req, unsigned int flags, unsigned int id);
struct fun_admin_vol_req *metaflow_admin_vol_destroy_req_alloca(struct channel *channel, struct metaflow *mf, unsigned int common_flags, void *common_cookie);
void metaflow_admin_vol_destroy_req_init_push(struct channel *channel, struct metaflow *mf, struct fun_admin_vol_req *vol_req, unsigned int id);
void vol_sprintf_bridge_uuid_parent_path(OUT char *,size_t, enum vol_type);
void vol_sprintf_bridge_uuid_path(OUT char *,size_t, enum vol_type, const fun_uuid_t);
void vol_sprintf_bridge_filter_path(OUT char *,size_t, enum vol_type, const fun_uuid_t, const char *filter, uint8_t filterq_index);
void vol_sprintf_bridge_custom_path(OUT char *buffer, size_t buf_len, enum vol_type type, fun_uuid_t uuid, const char *path);
void vol_sprintf_bridge_stats_path(OUT char *,size_t, enum vol_type, const fun_uuid_t);
void vol_sprintf_bridge_drives_path(OUT char *,size_t, const fun_uuid_t, uint32_t drive_id, enum drive_state);
void vol_sprintf_bridge_status_path(OUT char *,size_t);
bool vol_items_printable(void);
void vol_get_stats(struct vol_dir_bridge_ctx *ctx, struct vol_stats *stats);
const char *
get_vol_type_str(enum vol_type vt);
void vol_create_snap_push(struct channel *,struct vol_flow *base_vol_f, struct vol_snap_create_req *req);
void vol_delete_snap_push(struct channel *,struct vol_flow *base_vol_f, struct vol_snap_delete_req *req);
void vol_mount_snap_push(struct channel *,struct vol_flow *base_vol_f, struct vol_snap_mount_req *req);
void vol_get_changed_blocks_push(struct channel *,struct vol_flow *vol_f, struct vol_snap_changed_blocks_info *info);
void vol_get_snap_size(struct channel *,struct vol_flow *base_vol_f, const fun_uuid_t snap_uuid, struct vol_size *vs);
void vol_get_snap_usage(struct channel *,struct vol_flow *base_vol_f, struct vol_exts_info *exts, struct vol_size *vs);
void vol_get_snap_list(struct channel *,struct vol_flow *base_vol_f, struct vol_snap_list_req *req);
void
vol_flow_set_qos(struct vol_flow *flow, struct vol_qos *qos);
struct vol_qos *
vol_flow_get_qos(struct vol_flow *flow);
void vol_get_alloc_blks_push(struct channel *,struct vol_flow *vol_f, struct vol_alloc_blks_info *info);
void vol_admin_add_path_push(struct channel *channel, struct vol_path_req *vreq);
void vol_admin_remove_path_push(struct channel *channel, struct vol_path_req *vreq);
void vol_admin_config_fault_push(struct channel *channel, struct vol_fault_inject_req *vreq);
void vol_hold_writes(struct vol_flow *vol_f);
void vol_release_writes(struct vol_flow *vol_f);
void vol_hold_ios(struct vol_flow *vol_f);
void vol_io_wakeup(struct vol_flow *vol_f);
uint32_t vol_get_blocked_reads(struct vol_flow *vol_f);
uint32_t vol_get_blocked_writes(struct vol_flow *vol_f);
int vol_start_io_timer(struct vol_flow *vol_f, fun_time_t start_time, fun_time_t timeout);
int vol_stop_io_timer(struct vol_flow *vol_f);
int vol_inject_fault(struct channel *channel, struct vol_fault_config *fc, enum vol_fault_op_type op);
void vol_admin_get_changes_push(struct channel *channel, struct vol_get_changes_req *vreq);
void vol_admin_get_usage_push(struct channel *channel, struct vol_flow *vol_f, struct vol_exts_info *exts, OUT struct vol_size *vs);
bool vol_built_on_lsv(enum vol_type type);
void vol_admin_get_alloc_blks_push(struct channel *channel, struct vol_get_alloc_blks_req *vreq);
void vol_alloc_lba_locks_push(struct channel *channel, struct vol_flow *vol_f);
void vol_lba_lock_push(struct channel *channel, struct vol_flow *vol_f, uint64_t lba);
void vol_lba_unlock_push(struct channel *channel, struct vol_flow *vol_f, uint64_t lba);
void vol_free_lba_locks_push(struct channel *channel, struct vol_flow *vol_f);

--------------

storage/include/nvme.h: 

typedef uint16_t nvme_ctrlr_id_t;
enum {NVME_CC_SHN_NO_NOTIF =0, NVME_CC_SHN_NORMAL =1, NVME_CC_SHN_ABRUPT =2,};
typedef uint16_t nvme_status_t;
extern char const *subnqn_g;
extern char const *hostnqn_g;
extern char const *hostid_g;
enum nvme_ctrlr_state {NVME_CTRLR_STATE_INIT =0, NVME_CTRLR_STATE_STARTING, NVME_CTRLR_STATE_QUIESCED, NVME_CTRLR_STATE_FAILED, NVME_CTRLR_STATE_UNPLUGING, NVME_CTRLR_STATE_READY, NVME_CTRLR_STATE_QUIESCING, NVME_CTRLR_STATE_ONLINE,};
enum nvme_ctrlr_type {NVME_BLOCK_CTRLR =0, NVME_KV_CTRLR =1,};
enum nvme_transport_type {NVME_TRANSPORT_PCIE =0, NVME_TRANSPORT_RDMA =1, NVME_TRANSPORT_TCP =3, NVME_TRANSPORT_RDS =253, NVME_TRANSPORT_MAX =255,};
enum {NVME_SQ0TDBL =0x1000, NVME_CQ0HDBL =0x1004,};
enum nvme_nvm_ops {NVME_FLUSH =0x00, NVME_WRITE =0x01, NVME_READ =0x02, NVME_WRITE_UNCORR =0x04, NVME_COMPARE =0x05, NVME_WRITE_ZEROES =0x08, NVME_DSM =0x09, NVME_RSV_REG =0x0d, NVME_RSV_REP =0x0e, NVME_RSV_ACQ =0x11, NVME_RSV_REL =0x15, NVME_KV_STORE =0x81, NVME_KV_RETRIEVE =0x90, NVME_KV_DELETE =0xA1, NVME_KV_ITER_REQ =0xB1, NVME_KV_ITER_READ =0xB2, NVME_KV_EXIST =0xB3, NVME_KV_LIST =0xB4, NVME_NVM_LAST};
enum nvme_adm_ops {NVME_DEL_SQ =0x00, NVME_CREATE_SQ =0x01, NVME_GET_LOG =0x02, NVME_DEL_CQ =0x04, NVME_CREATE_CQ =0x05, NVME_IDTFY =0x06, NVME_ABORT =0x08, NVME_SET_FEAT =0x09, NVME_GET_FEAT =0x0a, NVME_ASYNC_REQ =0x0c, NVME_NS_MGMT =0x0d, NVME_FW_COMMIT =0x10, NVME_FW_DOWNLOAD =0x11, NVME_NS_ATTACH =0x15, NVME_KEEP_ALIVE =0x18, NVME_FABRICS =0x7f, NVME_FMT_NVM =0x80, NVME_SEC_SEND =0x81, NVME_SEC_RECV =0x82, NVME_SANITIZE =0x84, NVME_VS_API_NO_DATA =0xc0, NVME_VS_API_SEND =0xc1, NVME_VS_API_RECV =0xc2, NVME_VS_API_BIDIR =0xc3, NVME_VS_API_FWDL_START =0xc5, NVME_VS_CHANGED_BLOCKS =0xc6, NVME_VS_GET_NS_BLKHDR =0xc7, NVME_VS_SET_NS_FLAGS =0xc8, NVME_VS_ALLOC_BLOCKS =0xc9, NVME_VS_SET_CTRLR_FLAGS =0xca, NVME_VS_GET_ALLOC_BLKS =0xcb, NVME_ADM_LAST,};
enum nvme_sct {NVME_SCT_GEN =0x0, NVME_SCT_CS =0x1, NVME_SCT_ME =0x2, NVME_SCT_PATH =0x3, NVME_SCT_VS =0x7, NVME_SCT_LAST=0xFF,};
enum nvme_gen_sc {NVME_SC_SUCCESS =0x00, NVME_SC_INVAL_OP =0x01, NVME_SC_INVAL_FLD =0x02, NVME_SC_CMD_ID_CONFLICT =0x03, NVME_SC_DATA_XFER_ERR =0x04, NVME_SC_ABORT_PWR_LOSS =0x05, NVME_SC_INT_DEV_ERR =0x06, NVME_SC_ABORT_BY_REQ =0x07, NVME_SC_ABORT_SQ_DEL =0x08, NVME_SC_ABORT_FAIL_FUSED =0x09, NVME_SC_ABORT_MISS_FUSED =0x0a, NVME_SC_INVAL_NS_OR_FMT =0x0b, NVME_SC_CMD_SEQ_ERR =0x0c, NVME_SC_INVAL_SGL_SEG_DESC =0x0d, NVME_SC_INVAL_NUM_SGL_DESCS =0x0e, NVME_SC_INVAL_DATA_SGL_LEN =0x0f, NVME_SC_INVAL_META_SGL_LEN =0x10, NVME_SC_INVAL_SGL_DESC_TYPE =0x11, NVME_SC_INVAL_CTRLR_MEM_BUF =0x12, NVME_SC_INVAL_PRP_OFF =0x13, NVME_SC_ATOMIC_WRUNIT_XEDED =0x14, NVME_SC_INVAL_SGL_OFF =0x16, NVME_SC_INVAL_SGL_SUBTYPE =0x17, NVME_SC_HOSTID_INCONST_FMT =0x18, NVME_SC_XPIRED_KEEP_ALIVE =0x19, NVME_SC_INVAL_KEEP_ALIVE =0x1a, NVME_SC_NS_WRITE_PROTECTED =0x20, NVME_SC_CMD_INTERRUPTED =0x21, NVME_SC_TRANSPORT_TRANSIENT_ERR =0x22, NVME_SC_LBA_OUT_OF_RANGE =0x80, NVME_SC_CAP_XEDED =0x81, NVME_SC_NS_NOT_RDY =0x82, NVME_SC_RSV_CONFLICT =0x83, NVME_SC_FMT_IN_PROG =0x84, NVME_SC_TIMEOUT =0xC0, NVME_SC_FABRICSH_ERR =0xC1, NVME_GEN_LAST =0xFF,};
enum nvme_kv_sc {NVME_SC_KV_RESP_OK =0x00, NVME_SC_KV_RESP_NONE, NVME_SC_KV_RESP_FULL, NVME_SC_KV_RESP_BADLEN, NVME_SC_KV_RESP_BADINDIRECT, NVME_SC_KV_RESP_BADKEY, NVME_SC_KV_RESP_BADCMD, NVME_SC_KV_RESP_BADKVTYPE, NVME_SC_KV_RESP_NOTFOUND, NVME_SC_IKV_RESP_BADKEYLEN, NVME_SC_MKV_RESP_BADKEYLEN, NVME_SC_MKV_RESP_PUTEXISTING, NVME_SC_KV_INT_FOUND, NVME_SC_KV_INT_REACHFREE, NVME_SC_KV_INT_FREETOMB, NVME_SC_KV_INT_REPROBE, NVME_SC_KV_INT_REHASH, NVME_SC_KV_INT_NOREHASH};
enum nvme_cs_sc {NVME_SC_INVAL_CQ =0x00, NVME_SC_INVAL_QID =0x01, NVME_SC_INVAL_QSIZE =0x02, NVME_SC_ABORT_LMT_XEDED =0x03, NVME_SC_ASYNC_LMT_XEDED =0x05, NVME_SC_INVAL_FW_SLOT =0x06, NVME_SC_INVAL_FW_IMAGE =0x07, NVME_SC_INVAL_INTR_VEC =0x08, NVME_SC_INVAL_LOG_PAGE =0x09, NVME_SC_INVAL_FMT =0x0a, NVME_SC_FW_REQ_CONV_RST =0x0b, NVME_SC_INVAL_Q_DEL =0x0c, NVME_SC_FEAT_ID_UNSAVEABLE =0x0d, NVME_SC_FEAT_UNCHANGEABLE =0x0e, NVME_SC_FEAT_NOT_NS_SPECIFIC =0x0f, NVME_SC_FW_REQ_NVM_RST =0x10, NVME_SC_FW_REQ_RST =0x11, NVME_SC_FW_REQ_MAXTIME_VIOL =0x12, NVME_SC_FW_ACTI_PROHIBIT =0x13, NVME_SC_OVERLAP_RANGE =0x14, NVME_SC_NS_INSUFF_CAP =0x15, NVME_SC_NS_ID_UNAVAIL =0x16, NVME_SC_NS_ALRDY_ATTACHED =0x18, NVME_SC_NS_IS_PRIVATE =0x19, NVME_SC_NS_NOT_ATTACHED =0x1a, NVME_SC_TP_UNSUPP =0x1b, NVME_SC_INVAL_CTRLR_LIST =0x1c, NVME_SC_CONFLICT_ATTRS =0x80, NVME_SC_INVAL_PR_INFO =0x81, NVME_SC_WRITE_TO_RO_PAGE =0x82, NVME_SC_INVAL_KEY_SIZE =0x90, NVME_SC_INVAL_KSID =0x91, NVME_SC_INVAL_VAL_SIZE =0x92, NVME_SC_KEY_DOES_NOT_EXIST =0x93, NVME_SC_UNRECOVERED_ERROR =0x94, NVME_SC_KEY_EXISTS =0x95, NVME_SC_DEV_CAPACITY_EXCEEDED =0x96, NVME_CS_LAST =0xFF,};
enum nvme_me_sc {NVME_SC_WRITE_FAULTS =0x80, NVME_SC_UNRECOVERED_RD_ERR =0x81, NVME_SC_GUARD_ERR =0x82, NVME_SC_APPTAG_ERR =0x83, NVME_SC_REFTAG_ERR =0x84, NVME_SC_COMP_FAIL =0x85, NVME_SC_ACCESS_DENIED =0x86, NVME_SC_DEALLOC_OR_UNWR_BLOCK =0x87, NVME_ME_LAST =0xFF,};
enum nvme_path_sc {NVME_SC_INT_PATH_ERR =0x00, NVME_SC_ASYM_NS_ACCESS_PER_LOSS =0x01, NVME_SC_ASYM_NS_ACCESS_INACCESSIBLE =0x02, NVME_SC_ASYM_NS_ACCESS_TRANSITION =0x03, NVME_SC_CTRLR_PATH_ERR =0x60, NVME_SC_HOST_PATH_ERR =0x70, NVME_SC_CMD_ABORTED_BY_HOST =0x71, NVME_SC_LAST =0xFF,};
enum nvme_vs_sc {NVME_SC_GEN_INVALID_PARAMS =0x01, NVME_SC_GEN_MISSING_PARAMS =0x02, NVME_SC_GEN_RESRC_MAX_LIMIT_REACHED =0x03, NVME_SC_GEN_OP_NOT_SUPPORTED =0x04, NVME_SC_GEN_FEATURE_NOT_SUPPORTED =0x05, NVME_SC_GEN_MEM_ALLOC_FAILURE =0x06, NVME_SC_GEN_BLK_SIZE_UNSUPPORTED =0x07, NVME_SC_GEN_BLT_SIZE_UNSUPPORTED =0x08, NVME_SC_GEN_INTERNAL_ERROR =0x09, NVME_SC_CTRLR_NOT_FOUND =0x21, NVME_SC_CTRLR_ALRDY_CREATED =0x22, NVME_SC_CTRLR_HAS_NS_CANT_DELETE =0x23, NVME_SC_CTRLR_VOL_ALRDY_ATTACHED =0x24, NVME_SC_VOL_NOT_FOUND =0x31, NVME_SC_VOL_ALRDY_CREATED_OR_MOUNTED =0x32, NVME_SC_VOL_IS_OPEN_CANT_PERFORM_REQ =0x33, NVME_SC_VOL_DURABLE_PLEX_DUPLICATE =0x34, NVME_SC_VOL_DURABLE_PLEX_INVALID_SIZE =0x35, NVME_SC_VOL_DURABLE_PLEX_OPEN_FAILED =0x36, NVME_SC_DRIVE_NOT_FOUND =0x51, NVME_SC_DRIVE_IS_FULL =0x52, NVME_SC_DRIVE_NOT_ONLINE =0x53, NVME_SC_DRIVE_NOT_FORMATTED =0x54, NVME_SC_SUPER_BLOCK_IO_FAILED =0x61, NVME_SC_SUPER_BLOCK_CRC_MISMATCH =0x62, NVME_VS_LAST =0xFF,};
enum nvme_sgl_desc_type {NVME_SGL_TYPE_DATA_BLOCK =0x0, NVME_SGL_TYPE_BIT_BUCKET =0x1, NVME_SGL_TYPE_SEG =0x2, NVME_SGL_TYPE_LAST_SEG =0x3, NVME_SGL_TYPE_KEYED_DATA_BLOCK =0x4, NVME_SGL_TYPE_TRANSPORT_BLOCK =0x5, NVME_SGL_TYPE_VENDOR =0xF,};
enum nvme_sgl_desc_subtype {NVME_SGL_SUBTYPE_ADDRESS =0x0, NVME_SGL_SUBTYPE_OFFSET =0x1, NVME_SGL_SUBTYPE_TCP_TRANSPORT =0xA, NVME_SGL_SUBTYPE_INVALIDATE =0x0F,};
enum nvme_psdt_value {NVME_PSDT_PRP =0x0, NVME_PSDT_SGL_MPTR_CONTIG =0x1, NVME_PSDT_SGL_MPTR_SGL =0x2, NVME_PSDT_RESERVED =0x3};
enum nvme_psdt_value_shifted {NVME_PSDT_PRP_SHIFTED =0x0<<NVME_PSDT_S, NVME_PSDT_SGL_MPTR_CONTIG_SHIFTED =0x1<<NVME_PSDT_S, NVME_PSDT_SGL_MPTR_SGL_SHIFTED =0x2<<NVME_PSDT_S, NVME_PSDT_RESERVED_SHIFTED =0x3<<NVME_PSDT_S};
struct nvme_sgl {uint64_t addr; union{struct{uint8_t reserved[7];uint8_t type_subtype;};struct {uint32_t len; uint8_t reserved[3];uint8_t type_subtype;}unkeyed; struct {uint8_t len[NVME_SGL_KEYED_LEN_LEN];uint8_t key[NVME_SGL_KEYED_KEY_LEN];uint8_t type_subtype;}keyed; uint64_t len_key_type_subtype;};
};
static_assert(sizeof(struct nvme_sgl)==16,"Incorrect size of nvme_sgl");
struct nvme_cmd_cmn {union{struct{uint8_t opcode; uint8_t fuse_psdt; uint16_t cid;};uint32_t cdw0;};uint32_t nsid; union {uint64_t rsvd; struct{uint8_t vs_ver; uint8_t vs_subop; uint16_t vs_hndlr_id; union{uint32_t arg0; uint32_t offset;};};};uint64_t mptr; union {struct{uint64_t prp1; uint64_t prp2;};struct nvme_sgl sgl;};
};
struct nvme_del_sq {struct nvme_cmd_cmn cmn; uint16_t qid; uint16_t res1; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_create_sq {struct nvme_cmd_cmn cmn; uint16_t qid; uint16_t qsize; uint16_t pc_qprio; uint16_t cqid; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_create_cq {struct nvme_cmd_cmn cmn; uint16_t qid; uint16_t qsize; uint16_t pc_ien; uint16_t iv; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_smart_log {uint8_t crit_warning; uint8_t composite_temp[2];uint8_t avail_spare; uint8_t avail_spare_thr; uint8_t percent_used; uint8_t endurance_grp_crit_warn_summary; uint8_t rsvd1[25];uint64_t data_units_read[2];uint64_t data_units_written[2];uint64_t host_reads[2];uint64_t host_writes[2];uint64_t ctrlr_busy_time[2];uint64_t power_cycles[2];uint64_t power_on_hours[2];uint64_t unsafe_shutdowns[2];uint64_t media_errors[2];uint64_t num_err_info_entries[2];uint32_t wctemp; uint32_t cctemp; uint16_t temp_sensors[8];uint32_t thermal_mgmt_temp1_transition_cnt; uint32_t thermal_mgmt_temp2_transition_cnt; uint32_t total_time_for_thermal_mgmt_temp1; uint32_t total_time_for_thermal_mgmt_temp2; uint8_t rsvd2[280];};
static_assert(sizeof(struct nvme_smart_log)==512,"nvme_smart_log size is different from expected");
struct nvme_err_log {uint64_t error_count; uint16_t sqid; uint16_t cmdid; uint16_t status_field; uint16_t parm_error_location; uint64_t lba; uint32_t nsid; uint8_t vs; uint8_t trtype; uint8_t resv[2];uint64_t cs; uint16_t trtype_specific_info; uint8_t resv2[22];};
static_assert(sizeof(struct nvme_err_log)==64,"nvme_err_log size is different from expected");
struct nvme_fw_slot_info_log {uint8_t afi; uint8_t rsvd1[7];uint64_t frs[7];uint8_t rsvd64[448];};
static_assert(sizeof(struct nvme_fw_slot_info_log)==512,"nvme_fw_slot_info_log size is different from expected");
enum nvme_log_page_id {NVME_LOG_ERROR =0x1, NVME_LOG_SMART =0x2, NVME_LOG_FW_SLOT =0x3, NVME_LOG_CHANGED_NS_LIST =0x4, NVME_LOG_CMDS_SUPPORTED=0x5, NVME_LOG_DEVICE_SELF_TEST =0x6, NVME_LOG_HOST_INIT_TELEMETRY =0x7, NVME_LOG_CTRLR_INIT_TELEMETRY=0x8, NVME_LOG_ENDURANCE_GRP_INFO =0x9, NVME_LOG_PREDICTABLE_LAT_NVM_SET =0xA, NVME_LOG_PREDICTABLE_LAT_EVT_AGGR =0xB, NVME_LOG_ASYM_NS_ACCESS =0xC, NVME_LOG_PERSISTENT_EVENT_LOG =0xD, NVME_LOG_LBA_STATUS_INFO =0xE, NVME_LOG_ENDURANCE_GRP =0xF, NVME_LOG_DISCOVERY =0x70, NVME_LOG_VS_PAGE_START =0xC0, NVME_LOG_STORAGE_EVENTS =NVME_LOG_VS_PAGE_START, NVME_LOG_VS_PAGES_MAX,};
struct nvme_get_log {struct nvme_cmd_cmn cmn; uint8_t page_id; uint8_t lsp_rae; uint16_t numdl; uint16_t numdu; uint16_t lsi; uint32_t lpol; uint32_t lpou; uint32_t cdw14; uint32_t cdw15;};
NVME_FLD_SET_GET(nvme_get_log, lsp_rae, rae, NVME_CDW10_RAE_M, NVME_CDW10_RAE_S)
NVME_FLD_SET_GET(nvme_get_log, lsp_rae, lsp, NVME_CDW10_LSP_M, NVME_CDW10_LSP_S)
enum {NVME_IDTFY_NS_ACTIVE_DATA =0, NVME_IDTFY_CTRLR_DATA =1, NVME_IDTFY_NS_ACTIVE_LIST =2, NVME_IDTFY_NS_ID_DESC_LIST =3, NVME_IDTFY_NS_ALLOC_LIST =0x10, NVME_IDTFY_NS_ALLOC_DATA =0x11, NVME_IDTFY_NS_CTRLR_LIST =0x12, NVME_IDTFY_CTRLR_LIST =0x13,};
struct nvme_idtfy {struct nvme_cmd_cmn cmn; uint8_t cns; uint8_t res1; uint16_t cntid; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_ns_id_desc {uint8_t nidt; uint8_t nidl; uint16_t reserved;};
enum {NVME_NIDT_EUI64 =0x01, NVME_NIDT_NGUID =0x02, NVME_NIDT_UUID =0x03,};
enum {NVME_ONCS_COMPARE =1<<0, NVME_ONCS_WR_UNCORR =1<<1, NVME_ONCS_DSM =1<<2, NVME_ONCS_WR_ZERO =1<<3, NVME_ONCS_SAVE =1<<4, NVME_ONCS_RSRV =1<<5,};
enum {NVME_OAES_NS_CHANGED =1<<8, NVME_OAES_FW_ACTIVATION =1<<9, NVME_OAES_ANA_CHANGED =1<<11,};
enum {NVME_OACS_SECURITY =1<<0, NVME_OACS_FORMAT =1<<1, NVME_OACS_FW_UPD =1<<2, NVME_OACS_NS_MGMT =1<<3,};
enum {NVME_LPA_SMART_PER_NS =1<<0, NVME_LPA_CMD_EFFECTS =1<<1, NVME_LPA_GETLOG_EXTENDED =1<<2,};
enum {NVME_FUSES_COMPARE_WRITE =1<<0,};
enum {NVME_SGLS_NVM_DB_NO_ALIGN_GRAN_REQ =1<<0, NVME_SGLS_NVM_DB_DWORD_ALIGN_GRAN_REQ =1<<1, NVME_SGLS_KEYED_DBD =1<<2, NVME_SGLS_BBD =1<<16, NVME_SGLS_MD_BYTE_ALIGN_CONT_PHY_BUF =1<<17, NVME_SGLS_LARGE_LEN =1<<18, NVME_SGLS_MPTR_AS_SGLSEG =1<<19, NVME_SGLS_ADDR_AS_OFFSET =1<<20, NVME_SGLS_TRANSPORT_DBD =1<<21,};
enum {NVME_MC_CONTIG =1<<0, NVME_MC_SEPARATE =1<<1,};
enum {NVME_DPC_TYPE1 =1<<0, NVME_DPC_TYPE2 =1<<1, NVME_DPC_TYPE3 =1<<2, NVME_DPC_FIRST_8B =1<<3, NVME_DPC_LAST_8B =1<<4,};
enum {NVME_DPS_TYPE_MASK =0x7, NVME_DPS_DIS =0, NVME_DPS_TYPE1 =1, NVME_DPS_TYPE2 =2, NVME_DPS_TYPE3 =3, NVME_DPS_FIRST_OR_LAST =1<<3,};
enum nvme_cmic {NVME_CMIC_MULTI_SUBSYS_PORT =1<<0, NVME_CMIC_MULTI_CTRLR =1<<1, NVME_CMIC_ANA_REPORTING =1<<3,};
enum nvme_anacap {NVME_ANACAP_OPTIMIZED_REPORTING =1<<0, NVME_ANACAP_NON_OPTIMIZED_REPORTING =1<<1, NVME_ANACAP_INACCESSIBLE_REPORTING =1<<2, NVME_ANACAP_PERSISTENT_LOSS_REPORTING =1<<3, NVME_ANACAP_CHANGE_STATE_REPORTING =1<<4, NVME_ANACAP_GRPID_DOES_NOT_CHANGE =1<<6, NVME_ANACAP_NONZERO_GRPID_IN_NSMGMT =1<<7,};
struct log_page_header_t {uint8_t log_page_id; uint64_t magic; uint32_t version; uint32_t num_entries; uint8_t buf[0];};
enum nvme_ctrlr_types {CTRLR_TYPE_NOT_REPORTED =0, CTRLR_TYPE_IO_CTRLR, CRTRL_DISC_CTRLR, CTRLR_TYPE_DISC,};
enum nvme_ctrlr_vwc_support {NVME_VWC_ALL_NS_NOT_SUPPORTED =2, NVME_VWC_ALL_NS_SUPPORTED =3,};
struct nvme_ctrlr_data {uint16_t vid; uint16_t ssvid; uint8_t sn[NVME_CTRLR_DATA_SN_LEN];uint8_t mn[NVME_CTRLR_DATA_MN_LEN];uint8_t fr[NVME_CTRLR_DATA_FR_LEN];uint8_t rab; uint8_t ieee[NVME_CTRLR_DATA_IEEE_LEN];uint8_t cmic; uint8_t mdts; uint16_t cntlid; uint32_t ver; uint32_t rtd3r; uint32_t rtd3e; uint32_t oaes; uint32_t ctratt; uint16_t rrls; uint8_t rsvd110[9];uint8_t cntrltype; fun_uuid_t fguid; uint16_t crdt1; uint16_t crdt2; uint16_t crdt3; uint8_t rsvd255[122];uint16_t oacs; uint8_t acl; uint8_t aerl; uint8_t frmw; uint8_t lpa; uint8_t elpe; uint8_t npss; uint8_t avscc; uint8_t apsta; uint16_t wctemp; uint16_t cctemp; uint16_t mtfa; uint32_t hmpre; uint32_t hmmin; uint64_t tnvmcap_lo; uint64_t tnvmcap_hi; uint64_t unvmcap_lo; uint64_t unvmcap_hi; uint32_t rpmbs; uint16_t edstt; uint8_t dsto; uint8_t fwug; uint16_t kas; uint16_t hctma; uint16_t mntmt; uint16_t mxtmt; uint32_t sanicap; uint32_t hmminds; uint16_t hmmaxd; uint16_t nsetidmax; uint16_t endgidmax; uint8_t anatt; uint8_t anacap; uint32_t anagrpmax; uint32_t nanagrpid; uint32_t pels; uint8_t rsvd511[156];uint8_t sqes; uint8_t cqes; uint16_t maxcmd; uint32_t nn; uint16_t oncs; uint16_t fuses; uint8_t fna; uint8_t vwc; uint16_t awun; uint16_t awupf; uint8_t nvscc; uint8_t nwpc; uint16_t acwu; uint8_t rsvd535[2];uint32_t sgls; uint32_t mnan; uint8_t rsvd767[224];uint8_t subnqn[NVME_CTRLR_DATA_SUBNQN_LEN];uint8_t rsvd1791[768];uint32_t ioccsz; uint32_t iorcsz; uint16_t icdoff; uint8_t fcatt; uint8_t msdbd; uint16_t ofcs; uint8_t rsvd2047[242];uint8_t psd[NVME_CTRLR_DATA_PSD_LEN];uint8_t vs[NVME_CTRLR_DATA_VS_LEN];};
static_assert(sizeof(struct nvme_ctrlr_data)==4096,"Incorrect size");
struct nvme_lbaf {uint16_t ms; uint8_t lbads; uint8_t rp;};
NVME_SET_GET(flbas_fmt, NVME_FLBAS_FMT_M, NVME_FLBAS_FMT_S)
NVME_SET_GET(flbas_md, NVME_FLBAS_MD_M, NVME_FLBAS_MD_S)
enum nvme_ns_feat {NVME_NS_FEAT_THINP =1<<0, NVME_NS_FEAT_NSABP =1<<1, NVME_NS_FEAT_DAE =1<<2, NVME_NS_FEAT_UIDREUSE =1<<3, NVME_NS_FEAT_IO_OPTPERF =1<<4,};
struct nvme_ns_data {uint64_t nsze; uint64_t ncap; uint64_t nuse; uint8_t nsfeat; uint8_t nlbaf; uint8_t flbas;  uint8_t mc; uint8_t dpc; uint8_t dps; uint8_t nmic; uint8_t rescap; uint8_t fpi; uint8_t dlfeat; uint16_t nawun; uint16_t nawupf; uint16_t nacwu; uint16_t nabsn; uint16_t nabo; uint16_t nabspf; uint16_t noiob; uint64_t nvmcap_lo; uint64_t nvmcap_hi; uint16_t npwg; uint16_t npwa; uint16_t npdg; uint16_t npda; uint16_t nows; uint8_t res103[18];uint32_t anagrpid; uint8_t res98[3];uint8_t nsattr; uint16_t nvmsetid; uint16_t endgid; union{struct{uint64_t nguid_lo; uint64_t nguid_hi;};fun_uuid_t nguid;};uint64_t eui64; struct nvme_lbaf lbafs[NVME_NS_DATA_NUM_LBAFS];uint8_t res383[192];uint8_t vs[3712-sizeof(fun_uuid_t)];fun_uuid_t vol_uuid;
};
static_assert(sizeof(struct nvme_ns_data)==4096,"Incorrect size");
enum {NVME_FEAT_TEMP_TYPE_OVER =0, NVME_FEAT_TEMP_TYPE_UNDER =1,};
enum {NVME_FEAT_TEMP_SEL_COMPOSITE =0, NVME_FEAT_TEMP_SEL_SENSOR1 =1, NVME_FEAT_TEMP_SEL_SENSOR2 =2, NVME_FEAT_TEMP_SEL_SENSOR3 =3, NVME_FEAT_TEMP_SEL_SENSOR4 =4, NVME_FEAT_TEMP_SEL_SENSOR5 =5, NVME_FEAT_TEMP_SEL_SENSOR6 =6, NVME_FEAT_TEMP_SEL_SENSOR7 =7, NVME_FEAT_TEMP_SEL_SENSOR8 =8, NVME_FEAT_TEMP_SEL_ALL =15,};
enum {NVME_FEAT_ARB =1, NVME_FEAT_PWR_MGMT =2, NVME_FEAT_LBA_RANGE_TYPE =3, NVME_FEAT_TEMP_THRESH =4, NVME_FEAT_ERR_RECOVERY =5, NVME_FEAT_VOLATILE_WR_CACHE =6, NVME_FEAT_NUM_QUEUES =7, NVME_FEAT_INTR_COALESCING =8, NVME_FEAT_INTR_VEC_CONF =9, NVME_FEAT_WR_ATOMICITY =0x0a, NVME_FEAT_ASYNC_EV_CONF =0x0b, NVME_FEAT_AUTO_PS_TRANS =0x0c, NVME_FEAT_HOST_MEM_BUF =0x0d, NVME_FEAT_TIME_STAMP =0x0e, NVME_FEAT_KEEP_ALIVE_TIMER =0x0f, NVME_FEAT_HOST_CONTROL_THERM_MGMT =0x10, NVME_FEAT_NONOP_PS_CFG =0x11, NVME_FEAT_HOST_BEHAVIOR =0x16, NVME_FEAT_SW_PROGRESS_MARKER =0x80, NVME_FEAT_HOST_ID =0x81, NVME_FEAT_RSV_NOTIF_MASK =0x82, NVME_FEAT_RSV_PERSIST =0x83,};
struct nvme_feat_host_behav {uint8_t acre; uint8_t reserved[511];};
static_assert(sizeof(struct nvme_feat_host_behav)==512,"Incorrect size of nvme_feat_host_behav");
struct nvme_feat {struct nvme_cmd_cmn cmn; uint32_t feat_id; union{uint32_t nsqr_ncqr; uint32_t aggr_time_thr; uint32_t arb; uint32_t temp_thr; uint32_t pwr_mgmt; uint32_t err_recov; uint32_t int_vec_cfg; uint32_t wr_atomic_norm; uint32_t async_ev_cfg; uint32_t keep_alive;};uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;
};
struct nvme_async_evt_req {struct nvme_cmd_cmn cmn; uint32_t cdw10; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
enum {NVME_NS_MGMT_SEL_CREATE =0, NVME_NS_MGMT_SEL_DELETE =1,};
struct nvme_ns_mgmt {struct nvme_cmd_cmn cmn; uint32_t sel; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
enum {NVME_NS_ATTACH_SEL_ATTACH =0, NVME_NS_ATTACH_SEL_DETACH =1,};
struct nvme_ctrlr_list {uint16_t num_ctrlrs; uint16_t ctrlrids[];};
struct nvme_ns_attach {struct nvme_cmd_cmn cmn; uint32_t sel; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_abort {struct nvme_cmd_cmn cmn; uint16_t sqid; uint16_t cmdid; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_changed_blocks {struct nvme_cmd_cmn cmn; uint32_t slba_lo; uint16_t slba_hi; uint16_t nlb; fun_uuid_t uuid2;};
enum {NVME_VS_API_FLVM_HNDLR_ID =0, NVME_VS_API_RCNVME_HNDLR_ID =1, NVME_VS_API_DPC_HNDLR_ID =2,};
enum {NVME_VS_API_SUBOP_RCNVME_TEST =255};
enum {NVME_NO_XFER =0, NVME_H2C_XFER =1, NVME_C2H_XFER =2, NVME_BIDIR_XFER =3,};
struct nvme_vs_api_hdr {uint32_t version; uint16_t json_cmd_status; uint16_t rsvd1; uint32_t data_len; uint32_t rsvd2;};
static_assert(sizeof(struct nvme_vs_api_hdr)==16,"Incorrect size of nvme_vs_api_hdr");
struct nvme_vs_api {struct nvme_cmd_cmn cmn; union{uint64_t arg1; struct{union{uint32_t cdw10; uint32_t key; uint32_t ns_flags; uint32_t ctrlr_flags;};union {uint32_t cdw11; uint32_t fwfile_sz;};};uint64_t slba;};union {uint64_t arg2; struct{uint32_t cdw12; uint32_t cdw13;};uint64_t nlb;};union {uint64_t arg3; struct{uint32_t cdw14; uint32_t cdw15;};};
};
struct nvme_vs_api_data {uint8_t ver:4; uint8_t dir:2; uint8_t rsvd:2; uint8_t subop; union{uint32_t arg0; uint32_t offset;};uint64_t arg1; uint64_t arg2; uint64_t arg3; void *nvme_cmd; size_t page_size; nvme_status_t status; fun_time_t start_time;
};
enum nvme_log_page_cse_flags {NVME_LOG_PAGE_CSE_CSUPP =1<<0, NVME_LOG_PAGE_CSE_LBCC =1<<1, NVME_LOG_PAGE_CSE_NCC =1<<2, NVME_LOG_PAGE_CSE_NIC =1<<3, NVME_LOG_PAGE_CSE_CCC =1<<4,};
struct nvme_log_page_cse_entry {uint32_t cse_entry;};
struct nvme_rw {struct nvme_cmd_cmn cmn; uint64_t slba; uint16_t nlb; uint16_t ctrl; uint32_t dsm; uint32_t ilbrt; union{struct{uint16_t lbat; uint16_t lbatm;};uint32_t cdw15;};
};
struct nvme_write_zeros {struct nvme_cmd_cmn cmn; uint64_t slba; uint16_t nlb; uint16_t ctrl; uint32_t cdw13; uint32_t ilbrt; union{struct{uint16_t lbat; uint16_t lbatm;};uint32_t cdw15;};
};
NVME_FLD_SET_GET(nvme_write_zeros, ctrl, deallocate, NVME_CDW12_WZ_DEALLOC_M, NVME_CDW12_WZ_DEALLOC_S)
struct nvme_fmt_nvm {struct nvme_cmd_cmn cmn; uint32_t cdw10; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
NVME_FLD_SET_GET(nvme_fmt_nvm, cdw10, lba_format, NVME_CDW10_LBA_FORMAT_M, NVME_CDW10_LBA_FORMAT_S)
NVME_FLD_SET_GET(nvme_fmt_nvm, cdw10, md_set, NVME_CDW10_MD_SET_M, NVME_CDW10_MD_SET_S)
NVME_FLD_SET_GET(nvme_fmt_nvm, cdw10, prot_info, NVME_CDW10_PROT_INFO_M, NVME_CDW10_PROT_INFO_S)
NVME_FLD_SET_GET(nvme_fmt_nvm, cdw10, prot_info_loc, NVME_CDW10_PROT_INFO_LOC_M, NVME_CDW10_PROT_INFO_LOC_S)
NVME_FLD_SET_GET(nvme_fmt_nvm, cdw10, sec_erase, NVME_CDW10_SEC_ERASE_SET_M, NVME_CDW10_SEC_ERASE_SET_S)
struct nvme_flush {struct nvme_cmd_cmn cmn; uint32_t cdw10; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_dsm_range {uint32_t cattr; uint32_t nlb; uint64_t slba;};
struct nvme_dsm {struct nvme_cmd_cmn cmn; uint8_t num_ranges; uint8_t rsvd1[3];uint8_t attributes; uint8_t rsvd2[3];uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
NVME_FLD_SET_GET(nvme_dsm, attributes, idr, NVME_DSM_ATTR_IDR_M, NVME_DSM_ATTR_IDR_S)
NVME_FLD_SET_GET(nvme_dsm, attributes, idw, NVME_DSM_ATTR_IDW_M, NVME_DSM_ATTR_IDW_S)
NVME_FLD_SET_GET(nvme_dsm, attributes, ad, NVME_DSM_ATTR_AD_M, NVME_DSM_ATTR_AD_S)
enum nvme_kv_option {KV_OPTION_UPDATE_ONLY =1<<5, KV_OPTION_NO_OVERWRITE =1<<6, KV_OPTION_COMPRESS =1<<7,};
struct _nvme_kv {uint32_t hbs; uint8_t key_len; uint8_t option; uint16_t rsvd1; union{struct{char key[16];};struct {uint64_t key_prp; uint64_t rsvd2;};};
};
struct nvme_kv_store {struct nvme_cmd_cmn cmn; struct _nvme_kv kv;};
struct nvme_kv_retrieve {struct nvme_cmd_cmn cmn; struct _nvme_kv kv;};
struct nvme_kv_delete {struct nvme_cmd_cmn cmn; struct _nvme_kv kv;};
struct nvme_kv_iter_req {struct nvme_cmd_cmn cmn; uint32_t zero; uint8_t iter_handle; uint8_t option; uint16_t rsvd2; uint32_t iter_val; uint32_t iter_bitmask; uint32_t cdw14; uint32_t cdw15;};
struct nvme_kv_iter_read {struct nvme_cmd_cmn cmn; uint32_t val_len; uint8_t iter_handle; uint8_t option; uint16_t rsvd2; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
struct nvme_kv_exist {struct nvme_cmd_cmn cmn; struct _nvme_kv kv;};
struct nvme_kv_list {struct nvme_cmd_cmn cmn; uint32_t hbs; uint8_t key_len; uint8_t rsvd1[3];uint8_t key[16];};
struct nvme_fw_download {struct nvme_cmd_cmn cmn; uint32_t num_dwords; uint32_t offset; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
enum nvme_fw_commit_actions {NVME_FW_IMAGE_REPLACE_AND_NOT_ACTIVATED =0, NVME_FW_IMAGE_REPLACE_AND_ACTIVATED_ON_CTRLR_RESET =1, NVME_FW_IMAGE_EXISTING_ACTIVAGED_ON_CTRLR_RESET =2, NVME_FW_IMAGE_REPLACE_AND_ACTIVATE =3, NVME_FW_IMAGE_REPLACE_BP =6, NVME_FW_IMAGE_MARK_BP_ACTIVE =7,};
struct nvme_fw_commit {struct nvme_cmd_cmn cmn; uint8_t fs_ca; uint8_t rsvd[2];uint8_t bpid; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};
NVME_FLD_SET_GET(nvme_fw_commit, fs_ca, fs, NVME_CDW10_FS_M, NVME_CDW10_FS_S)
NVME_FLD_SET_GET(nvme_fw_commit, fs_ca, ca, NVME_CDW10_CA_M, NVME_CDW10_CA_S)
NVME_FLD_SET_GET(nvme_fw_commit, bpid, bpid, NVME_CDW10_BPID_M, NVME_CDW10_BPID_S)
struct nvme_cmd {union{struct{struct nvme_cmd_cmn cmn; uint32_t cdw10; uint32_t cdw11; uint32_t cdw12; uint32_t cdw13; uint32_t cdw14; uint32_t cdw15;};struct nvme_async_evt_req async; struct nvme_idtfy idtfy; struct nvme_vs_api vs; struct nvme_abort abort; struct nvme_ns_mgmt nsmgmt; struct nvme_ns_attach nsattach; struct nvme_get_log getlog; struct nvme_feat feat; struct nvme_fmt_nvm fmt; struct nvme_create_sq csq; struct nvme_del_sq dsq; struct nvme_create_cq ccq; struct nvme_del_cq dcq; struct nvme_rw rw; struct nvme_write_zeros wz; struct nvme_dsm dsm; struct nvme_flush flush; struct nvme_fw_download fw_dl; struct nvme_fw_commit fw_commit; struct nvme_kv_store kv_store; struct nvme_kv_retrieve kv_retrieve; struct nvme_kv_delete kv_delete; struct nvme_kv_exist kv_exist; struct nvme_kv_list kv_list; struct nvme_kv_iter_req kv_iter_req; struct nvme_kv_iter_read kv_iter_read; struct nvme_changed_blocks chg_blocks;};
};
static_assert(NVME_CMD_SIZE ==64,"Incorrect size of nvme_cmd");
static inline bool
nvme_is_write(struct nvme_cmd *cmd)
 {return(cmd->cmn.opcode ==NVME_WRITE);}
static inline bool
nvme_is_read(struct nvme_cmd *cmd)
 {return(cmd->cmn.opcode ==NVME_READ);}
static inline bool
nvme_is_compare(struct nvme_cmd *cmd)
 {return(cmd->cmn.opcode ==NVME_COMPARE);}
static inline bool
nvme_is_write_zeroes(struct nvme_cmd *cmd)
 {return(cmd->cmn.opcode ==NVME_WRITE_ZEROES);}
static inline bool
nvme_is_changed_blocks(struct nvme_cmd *cmd)
 {return(cmd->cmn.opcode ==NVME_VS_CHANGED_BLOCKS);}
static inline bool
nvme_is_get_alloc_blks(struct nvme_cmd *cmd)
 {return(cmd->cmn.opcode ==NVME_VS_GET_ALLOC_BLKS);}
enum {NVME_CQE_RETRY =0, NVME_CQE_DO_NOT_RETRY =1,};
static_assert(NVME_QDEPTH_PCIE <=NVME_MAX_QDEPTH,"PCIe max queue size can't be more than MQES");
static_assert(FABRICS_QDEPTH_TCP <=NVME_MAX_QDEPTH,"Fabrics target max queue size can't be more than MQES");
static inline uint16_t
nvme_gen_status_crd(uint8_t sc, uint8_t crd)
{return(uint16_t)(NVME_STATUS_SC_SET(sc)|NVME_STATUS_SCT_SET(NVME_SCT_GEN)|NVME_CRD_P(crd));
}
static inline uint16_t
nvme_gen_status_sc_sct_crd(uint8_t sc, uint8_t sct, uint8_t crd)
{return(uint16_t)(NVME_STATUS_SC_SET(sc)|NVME_STATUS_SCT_SET(sct)|NVME_CRD_P(crd));
}
static inline uint16_t
nvme_cs_status_crd(uint8_t sc, uint8_t crd)
{return(uint16_t)(NVME_STATUS_SC_SET(sc)|NVME_STATUS_SCT_SET(NVME_SCT_CS)|NVME_CRD_P(crd));
}
static inline uint16_t
nvme_gen_status(uint8_t sc)
{return nvme_gen_status_crd(sc, 0);
}
static inline uint16_t
nvme_gen_status_sc_sct(uint8_t sc, uint8_t sct)
{return nvme_gen_status_sc_sct_crd(sc, sct, 0);
}
static inline uint16_t
nvme_cs_status(uint8_t sc)
{return nvme_cs_status_crd(sc, 0);
}
static inline void
nvme_set_status_phase(uint16_t *status, uint8_t phase)
{*status &=(~(NVME_STATUS_P_M <<NVME_STATUS_P_S));*status |=NVME_STATUS_P_SET(phase);
}
static inline uint16_t
nvme_cs_status_noretry(uint8_t sc)
{return(uint16_t)(nvme_cs_status(sc)|NVME_STATUS_DNR_SET(NVME_CQE_DO_NOT_RETRY));
}
static inline uint16_t
nvme_gen_status_noretry(uint8_t sc)
{return(uint16_t)(nvme_gen_status(sc)|NVME_STATUS_DNR_SET(NVME_CQE_DO_NOT_RETRY));
}
enum {NVME_CQE_ASYNC_EVT_ERROR =0, NVME_CQE_ASYNC_EVT_SMART =1, NVME_CQE_ASYNC_EVT_NOTICE =2, NVME_CQE_ASYNC_EVT_IO_CS_STS =6, NVME_CQE_ASYNC_EVT_IO_VS =7, NVME_CQE_ASYNC_EVENT_TYPE_MAX,};
enum nvme_error_async_event_status {NVME_CQE_ASYNC_EVENT_INFO_WR_INVAL_DB_REG =0, NVME_CQE_ASYNC_EVENT_INFO_INVAL_DB_VAL =1, NVME_CQE_ASYNC_EVENT_INFO_DIAG_FAIL =2, NVME_CQE_ASYNC_EVENT_INFO_PERSIST_INT_ERR =3, NVME_CQE_ASYNC_EVENT_INFO_TRANS_INT_ERR =4, NVME_CQE_ASYNC_EVENT_INFO_FW_IMG_LOAD_ERR =5,};
enum nvme_smart_async_event_status {NVME_CQE_ASYNC_EVENT_INFO_NVM_SUBSYS_RELIABILITY =0, NVME_CQE_ASYNC_EVENT_INFO_TEMP_THRESH =1, NVME_CQE_ASYNC_EVENT_INFO_SPARE_BELOW_THRESH =2,};
enum nvme_notice_async_event_status {NVME_CQE_ASYNC_EVENT_INFO_NS_ATTR_CHANGED =0, NVME_CQE_ASYNC_EVENT_INFO_FW_ACT_START =1, NVME_CQE_ASYNC_EVENT_INFO_TELEMETRY_LOG_CHANGED =2, NVME_CQE_ASYNC_EVENT_INFO_ANA_CHANGE =3, NVME_CQE_ASYNC_EVENT_INFO_PREDICT_LAT_EV_AGGR_LOG_CHANGE =4, NVME_CQE_ASYNC_EVENT_INFO_LBA_STATUS_INFO_ALERT =5, NVME_CQE_ASYNC_EVENT_INFO_ENDUR_GRP_EV_AGGR_LOG_CHANGE =6,};
enum nvme_cmd_specific_async_event_status {NVME_CQE_ASYNC_EVENT_INFO_RESER_LOG_PG_AVAIL =0, NVME_CQE_ASYNC_EVENT_INFO_SANIT_OP_COMP =1, NVME_CQE_ASYNC_EVENT_INFO_SANIT_OP_COMP_W_UNEXP_DEALLOC =2,};
struct nvme_cpl {union{uint32_t cdw0; struct{uint32_t nsqa_ncqa;};struct {uint8_t rsvd2; uint8_t log_page_id; uint8_t async_evt_info; uint8_t async_evt_type;};struct {uint8_t blkhdr_version; uint8_t crctype; uint8_t vol_type; uint8_t lba_shift_native;};struct {uint8_t rsvd1[3];uint8_t status_flags;};struct {uint32_t blocks_done;};struct {uint8_t rsvd4[3];uint8_t abort_status;};};uint32_t rsvd3; union {struct{uint16_t sqhd; uint16_t sqid;};uint32_t cdw2;};union {struct{uint16_t cid; uint16_t status;};uint32_t cdw3;};
};
static_assert(NVME_CPL_SIZE ==16,"Incorrect size");
NVME_FLD_SET_GET(nvme_cpl, nsqa_ncqa, nsqa, NVME_CPL_NSQA_M, NVME_CPL_NSQA_S)
NVME_FLD_SET_GET(nvme_cpl, nsqa_ncqa, ncqa, NVME_CPL_NCQA_M, NVME_CPL_NCQA_S)
NVME_FLD_SET_GET(nvme_cpl, abort_status, aborted, NVME_CPL_ABORT_STATUS_M, NVME_CPL_ABORT_STATUS_S)
enum {NVME_CSS_NVM =1<<0,};
struct nvme_buffer {uint8_t *buf; size_t size;};
enum nvme_op_type {NVME_OP_WRITE =0x1, NVME_OP_READ =0x2, NVME_OP_COMPARE =0x5, NVME_OP_WRITE_ZEROES =0x8, NVME_OP_DEALLOCATE =0x9,};
enum nvme_ns_flags {NVME_NS_ENCRYPTION_ENABLE =1<<0, NVME_NS_COMPRESSION_ENABLE =1<<1, NVME_NS_FLAGS_NS_MGMT =1<<2, NVME_NS_SNAPSHOT_ENABLE =1<<3, NVME_NS_CLONE_ENABLE =1<<4, NVME_NS_QOS_ENABLE =1<<5, NVME_NS_READ_ONLY_ENABLE =1<<6, NVME_NS_USER_CREATED_ENABLE =1<<7, NVME_NS_DEDUP_ENABLE =1<<8, NVME_NS_RETRY_IOS =1<<9, NVME_NS_ENABLE_METADATA =1<<10, NVME_NS_FLUSH_AFTER_CLOSE =1<<11, NVME_NS_MBUF_VECTOR_ENABLE =1<<12,};
struct nvme_ns_create_vs_data {uint16_t version; uint32_t flags; uint8_t volume_type; union{uint8_t num_pvols; uint8_t preferred_id;};uint8_t pvol_type; uint8_t min_replicas_insync; uint8_t retry_on_error; uint8_t ndata; uint8_t nparity; uint64_t pvol_id[MAX_PVOLS];uint32_t remote_addr; uint8_t sblk_group; struct vol_crypto_nvme_vs crypto; struct vol_compression compress; struct vol_clone clone; struct vol_dedup dedup;
};
NVME_CMD_FLD_SET_GET(cmn, opcode, op6b, NVME_OP6B_M, NVME_OP6B_S)
NVME_CMD_FLD_SET_GET(cmn, opcode, dir, NVME_DIR_M, NVME_DIR_S)
NVME_CMD_FLD_SET_GET(cmn, fuse_psdt, fuse, NVME_FUSE_M, NVME_FUSE_S)
NVME_CMD_FLD_SET_GET(cmn, fuse_psdt, psdt, NVME_PSDT_M, NVME_PSDT_S)
NVME_CMD_FLD_SET_GET(csq, pc_qprio, csq_pc, NVME_PC_M, NVME_PC_S)
NVME_CMD_FLD_SET_GET(cmn.sgl, type_subtype, sgl_subtype, NVME_SGL_SUBTYPE_M, NVME_SGL_SUBTYPE_S)
NVME_CMD_FLD_SET_GET(cmn.sgl, type_subtype, sgl_type, NVME_SGL_TYPE_M, NVME_SGL_TYPE_S)
NVME_FLD_SET_GET(nvme_sgl, type_subtype, type, NVME_SGL_TYPE_M, NVME_SGL_TYPE_S)
NVME_FLD_SET_GET(nvme_sgl, type_subtype, subtype, NVME_SGL_TYPE_M, NVME_SGL_TYPE_S)
static inline void
nvme_set_sgl_unkeyed(struct nvme_cmd *cmd, uint64_t addr, size_t len)
 {struct nvme_sgl *sgl = &cmd->cmn.sgl; nvme_cmd_sgl_type_set(cmd, NVME_SGL_TYPE_DATA_BLOCK);sgl->addr =addr; sgl->unkeyed.len =len;}
NVME_CMD_FLD_SET_GET(nsattach, sel, nsattach_sel, NVME_NSATTACH_SEL_M, NVME_NSATTACH_SEL_S)
NVME_CMD_FLD_SET_GET(feat, feat_id, feat_id, NVME_FEAT_ID_M, NVME_FEAT_ID_S)
NVME_CMD_FLD_SET_GET(feat, feat_id, feat_sel, NVME_FEAT_SEL_M, NVME_FEAT_SEL_S)
NVME_CMD_FLD_SET_GET(feat, nsqr_ncqr, feat_nsqr, NVME_FEAT_NSQR_M, NVME_FEAT_NSQR_S)
NVME_CMD_FLD_SET_GET(feat, nsqr_ncqr, feat_ncqr, NVME_FEAT_NCQR_M, NVME_FEAT_NCQR_S)
NVME_SET_GET(feat_nsqr, NVME_FEAT_NSQR_M, NVME_FEAT_NSQR_S)
NVME_SET_GET(feat_ncqr, NVME_FEAT_NCQR_M, NVME_FEAT_NCQR_S)
NVME_CMD_FLD_SET_GET(feat, aggr_time_thr, feat_aggr_thr, NVME_FEAT_AGGR_THR_M, NVME_FEAT_AGGR_THR_S)
NVME_CMD_FLD_SET_GET(feat, aggr_time_thr, feat_aggr_time, NVME_FEAT_AGGR_TIME_M, NVME_FEAT_AGGR_TIME_S)
NVME_SET_GET(feat_aggr_thr, NVME_FEAT_AGGR_THR_M, NVME_FEAT_AGGR_THR_S)
NVME_SET_GET(feat_aggr_time, NVME_FEAT_AGGR_TIME_M, NVME_FEAT_AGGR_TIME_S)
NVME_CMD_FLD_SET_GET(feat, temp_thr, feat_temp_thr, NVME_FEAT_TEMP_THR_M, NVME_FEAT_TEMP_THR_S)
NVME_CMD_FLD_SET_GET(feat, temp_thr, feat_temp_sel, NVME_FEAT_TEMP_SEL_M, NVME_FEAT_TEMP_SEL_S)
NVME_CMD_FLD_SET_GET(feat, temp_thr, feat_temp_type, NVME_FEAT_TEMP_TYPE_M, NVME_FEAT_TEMP_TYPE_S)
NVME_SET_GET(feat_temp_thr, NVME_FEAT_TEMP_THR_M, NVME_FEAT_TEMP_THR_S)
NVME_SET_GET(feat_temp_sel, NVME_FEAT_TEMP_SEL_M, NVME_FEAT_TEMP_SEL_S)
NVME_SET_GET(feat_temp_type, NVME_FEAT_TEMP_TYPE_M, NVME_FEAT_TEMP_TYPE_S)
NVME_CMD_FLD_SET_GET(feat, arb, feat_arb_burst, NVME_FEAT_ARB_BURST_M, NVME_FEAT_ARB_BURST_S)
NVME_CMD_FLD_SET_GET(feat, arb, feat_arb_lpw, NVME_FEAT_ARB_LPW_M, NVME_FEAT_ARB_LPW_S)
NVME_CMD_FLD_SET_GET(feat, arb, feat_arb_mpw, NVME_FEAT_ARB_MPW_M, NVME_FEAT_ARB_MPW_S)
NVME_CMD_FLD_SET_GET(feat, arb, feat_arb_hpw, NVME_FEAT_ARB_HPW_M, NVME_FEAT_ARB_HPW_S)
NVME_SET_GET(feat_arb_burst, NVME_FEAT_ARB_BURST_M, NVME_FEAT_ARB_BURST_S)
NVME_SET_GET(feat_arb_lpw, NVME_FEAT_ARB_LPW_M, NVME_FEAT_ARB_LPW_S)
NVME_SET_GET(feat_arb_mpw, NVME_FEAT_ARB_MPW_M, NVME_FEAT_ARB_MPW_S)
NVME_SET_GET(feat_arb_hpw, NVME_FEAT_ARB_HPW_M, NVME_FEAT_ARB_HPW_S)
NVME_CMD_FLD_SET_GET(feat, pwr_mgmt, feat_pwr_mgmt_ps, NVME_FEAT_PWR_PS_M, NVME_FEAT_PWR_PS_S)
NVME_CMD_FLD_SET_GET(feat, pwr_mgmt, feat_pwr_mgmt_wh, NVME_FEAT_PWR_WH_M, NVME_FEAT_PWR_WH_S)
NVME_SET_GET(feat_pwr_mgmt_ps, NVME_FEAT_PWR_PS_M, NVME_FEAT_PWR_PS_S)
NVME_SET_GET(feat_pwr_mgmt_wh, NVME_FEAT_PWR_WH_M, NVME_FEAT_PWR_WH_S)
NVME_CMD_FLD_SET_GET(feat, err_recov, feat_err_recov_tler, NVME_FEAT_ERR_RECOV_TLER_M, NVME_FEAT_ERR_RECOV_TLER_S)
NVME_CMD_FLD_SET_GET(feat, err_recov, feat_err_recov_dulbe, NVME_FEAT_ERR_RECOV_DULBE_M, NVME_FEAT_ERR_RECOV_DULBE_S)
NVME_SET_GET(feat_err_recov_tler, NVME_FEAT_ERR_RECOV_TLER_M, NVME_FEAT_ERR_RECOV_TLER_S)
NVME_SET_GET(feat_err_recov_dulbe, NVME_FEAT_ERR_RECOV_DULBE_M, NVME_FEAT_ERR_RECOV_DULBE_S)
NVME_CMD_FLD_SET_GET(feat, int_vec_cfg, feat_int_vec_cfg_iv, NVME_FEAT_INT_VEC_CFG_IV_M, NVME_FEAT_INT_VEC_CFG_IV_S)
NVME_CMD_FLD_SET_GET(feat, int_vec_cfg, feat_int_vec_cfg_cd, NVME_FEAT_INT_VEC_CFG_CD_M, NVME_FEAT_INT_VEC_CFG_CD_S)
NVME_SET_GET(feat_int_vec_cfg_iv, NVME_FEAT_INT_VEC_CFG_IV_M, NVME_FEAT_INT_VEC_CFG_IV_S)
NVME_SET_GET(feat_int_vec_cfg_cd, NVME_FEAT_INT_VEC_CFG_CD_M, NVME_FEAT_INT_VEC_CFG_CD_S)
NVME_CMD_FLD_SET_GET(feat, wr_atomic_norm, feat_wr_atomic_norm_dn, NVME_FEAT_WR_ATOM_NORM_DN_M, NVME_FEAT_WR_ATOM_NORM_DN_S)
NVME_SET_GET(feat_wr_atomic_norm_dn, NVME_FEAT_WR_ATOM_NORM_DN_M, NVME_FEAT_WR_ATOM_NORM_DN_S)
NVME_CMD_FLD_SET_GET(feat, keep_alive, feat_kato, NVME_FEAT_KATO_M, NVME_FEAT_KATO_S)
NVME_SET_GET(feat_kato, NVME_FEAT_KATO_M, NVME_FEAT_KATO_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_smart_spare_cap, NVME_FEAT_ASYNC_EV_CFG_SMART_SPARE_CAP_M, NVME_FEAT_ASYNC_EV_CFG_SMART_SPARE_CAP_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_smart_temp_thresh, NVME_FEAT_ASYNC_EV_CFG_SMART_TEMP_THRESH_M, NVME_FEAT_ASYNC_EV_CFG_SMART_TEMP_THRESH_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_smart_reliab_deg, NVME_FEAT_ASYNC_EV_CFG_SMART_REL_DEG_M, NVME_FEAT_ASYNC_EV_CFG_SMART_REL_DEG_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_smart_media_ro, NVME_FEAT_ASYNC_EV_CFG_SMART_MEDIA_RO_M, NVME_FEAT_ASYNC_EV_CFG_SMART_MEDIA_RO_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_smart_volat_backup, NVME_FEAT_ASYNC_EV_CFG_SMART_VOL_BACKUP_M, NVME_FEAT_ASYNC_EV_CFG_SMART_VOL_BACKUP_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_smart_persist_mem, NVME_FEAT_ASYNC_EV_CFG_SMART_PERSIST_MEM_M, NVME_FEAT_ASYNC_EV_CFG_SMART_PERSIST_MEM_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_ns_attr, NVME_FEAT_ASYNC_EV_CFG_NS_ATTR_M, NVME_FEAT_ASYNC_EV_CFG_NS_ATTR_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_fw_act, NVME_FEAT_ASYNC_EV_CFG_FW_ACT_M, NVME_FEAT_ASYNC_EV_CFG_FW_ACT_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_tel_log, NVME_FEAT_ASYNC_EV_CFG_TEL_LOG_M, NVME_FEAT_ASYNC_EV_CFG_TEL_LOG_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_ana_chg, NVME_FEAT_ASYNC_EV_CFG_ANA_CHG_M, NVME_FEAT_ASYNC_EV_CFG_ANA_CHG_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_pred_lat, NVME_FEAT_ASYNC_EV_CFG_PRED_LAT_M, NVME_FEAT_ASYNC_EV_CFG_PRED_LAT_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_lba_stat, NVME_FEAT_ASYNC_EV_CFG_LBA_STAT_M, NVME_FEAT_ASYNC_EV_CFG_LBA_STAT_S)
NVME_CMD_FLD_SET_GET(feat, async_ev_cfg, feat_async_ev_cfg_end_grp, NVME_FEAT_ASYNC_EV_CFG_END_GRP_M, NVME_FEAT_ASYNC_EV_CFG_END_GRP_S)
NVME_SET_GET(feat_async_ev_cfg_smart_spare_cap, NVME_FEAT_ASYNC_EV_CFG_SMART_SPARE_CAP_M, NVME_FEAT_ASYNC_EV_CFG_SMART_SPARE_CAP_S)
NVME_SET_GET(feat_async_ev_cfg_smart_temp_thresh, NVME_FEAT_ASYNC_EV_CFG_SMART_TEMP_THRESH_M, NVME_FEAT_ASYNC_EV_CFG_SMART_TEMP_THRESH_S)
NVME_SET_GET(feat_async_ev_cfg_smart_reliab_deg, NVME_FEAT_ASYNC_EV_CFG_SMART_REL_DEG_M, NVME_FEAT_ASYNC_EV_CFG_SMART_REL_DEG_S)
NVME_SET_GET(feat_async_ev_cfg_smart_media_ro, NVME_FEAT_ASYNC_EV_CFG_SMART_MEDIA_RO_M, NVME_FEAT_ASYNC_EV_CFG_SMART_MEDIA_RO_S)
NVME_SET_GET(feat_async_ev_cfg_smart_volat_backup, NVME_FEAT_ASYNC_EV_CFG_SMART_VOL_BACKUP_M, NVME_FEAT_ASYNC_EV_CFG_SMART_VOL_BACKUP_S)
NVME_SET_GET(feat_async_ev_cfg_smart_persist_mem, NVME_FEAT_ASYNC_EV_CFG_SMART_PERSIST_MEM_M, NVME_FEAT_ASYNC_EV_CFG_SMART_PERSIST_MEM_S)
NVME_SET_GET(feat_async_ev_cfg_ns_attr, NVME_FEAT_ASYNC_EV_CFG_NS_ATTR_M, NVME_FEAT_ASYNC_EV_CFG_NS_ATTR_S)
NVME_SET_GET(feat_async_ev_cfg_fw_act, NVME_FEAT_ASYNC_EV_CFG_FW_ACT_M, NVME_FEAT_ASYNC_EV_CFG_FW_ACT_S)
NVME_SET_GET(feat_async_ev_cfg_tel_log, NVME_FEAT_ASYNC_EV_CFG_TEL_LOG_M, NVME_FEAT_ASYNC_EV_CFG_TEL_LOG_S)
NVME_SET_GET(feat_async_ev_cfg_ana_chg, NVME_FEAT_ASYNC_EV_CFG_ANA_CHG_M, NVME_FEAT_ASYNC_EV_CFG_ANA_CHG_S)
NVME_SET_GET(feat_async_ev_cfg_pred_lat, NVME_FEAT_ASYNC_EV_CFG_PRED_LAT_M, NVME_FEAT_ASYNC_EV_CFG_PRED_LAT_S)
NVME_SET_GET(feat_async_ev_cfg_lba_stat, NVME_FEAT_ASYNC_EV_CFG_LBA_STAT_M, NVME_FEAT_ASYNC_EV_CFG_LBA_STAT_S)
NVME_SET_GET(feat_async_ev_cfg_end_grp, NVME_FEAT_ASYNC_EV_CFG_END_GRP_M, NVME_FEAT_ASYNC_EV_CFG_END_GRP_S)
struct nvme_ana_group_desc {uint32_t ana_grpid; uint32_t num_ns; uint64_t change_cnt; uint8_t state; uint8_t rsvd[15];uint32_t nsids[0];};
struct nvme_ana_rsp_hdr {uint64_t change_cnt; uint16_t num_ana_grps; uint16_t rsvd10[3];};
struct fabrics_ip {uint32_t remote_ip; uint32_t port;};
typedef enum secure_channel_type {SECURE_CHANNEL_NONE =0, SECURE_CHANNEL_TLS_PSK =1, SECURE_CHANNEL_TLS_CERT =2}secure_channel_type_t;
struct fabrics_conn_info {uint8_t subsys_nqn[NQN_MAX_LENGTH];uint8_t host_nqn[NQN_MAX_LENGTH];uint8_t host_id[NVME_HOSTID_LENGTH];nvme_ctrlr_id_t ctrlr_id; uint8_t transport; secure_channel_type_t sc_type; uint8_t sc_id[SECURE_ID_MAX_LENGTH];uint8_t *sc_key; uint16_t sc_keylen;};
struct fabrics_conn_params {struct fabrics_ip ip; struct fabrics_conn_info conn;};
struct nvme_subsys_ctrlr {fun_uuid_t ctrlr_uuid; nvme_ctrlr_id_t ctrlr_id; struct hu_fn_flow *hu_fn_f; STAILQ_ENTRY(nvme_subsys_ctrlr)next;};
struct nvme_subsys {uint8_t subsys_nqn[NQN_MAX_LENGTH];STAILQ_HEAD(,nvme_subsys_ctrlr)ctrlr_list;};
struct nvme_crd_info {uint16_t current_crd_stage; fun_time_t current_crd_stage_start;};
char const *nvme_idtfy_cns_str(uint8_t cns);
void nvme_print_io_cmd(struct nvme_cmd *cmd, uint8_t log_level);
void nvme_print_io_cmd_with_status(struct nvme_cmd *cmd, nvme_status_t status);
void nvme_print_adm_cmd_cmn(struct nvme_cmd *cmd);
void nvme_print_adm_cmd(struct nvme_cmd *cmd);
void nvme_print_cpl(struct nvme_cpl *cpl, const char *caller);
void nvme_print_status(struct flow *f, nvme_status_t status, const char*caller);
nvme_status_t nvme_nsid_zero_chk(uint32_t nsid);
nvme_status_t nvme_nsid_valid_chk(uint32_t nsid, uint32_t num_ns);
nvme_status_t nvme_nsid_special_chk(uint32_t nsid);
nvme_status_t nvme_qid_chk(uint16_t qid, uint16_t max_qid);
nvme_status_t nvme_qsize_chk(uint16_t qsize, uint16_t mqes);
nvme_status_t nvme_pc_chk(uint8_t pc, bool cqr);
nvme_status_t nvme_prp1_nonzero_chk(uint64_t prp1);
nvme_status_t nvme_ctrlrid_chk(nvme_ctrlr_id_t ctrlr_id);
nvme_status_t nvme_prp1_psdt_chk(uint64_t prp1, uint8_t psdt);
nvme_status_t nvme_sq_chk(struct nvme_cmd *cmd, uint16_t max_qid, bool cqr, uint16_t mqes, uint32_t cc_iosqes, uint8_t ctrlr_sqes);
nvme_status_t nvme_cq_chk(struct nvme_cmd *cmd, uint16_t max_qid, bool cqr, uint16_t mqes, uint32_t cc_iocqes, uint8_t ctrlr_cqes);
nvme_status_t nvme_idtfy_chk(struct nvme_cmd *cmd, uint32_t num_ns, nvme_ctrlr_id_t ctrlr_id);
nvme_status_t nvme_ns_data_chk(struct nvme_ns_data *ns_data, uint64_t max_ns_size, uint64_t max_ns_cap, struct nvme_lbaf *lbafs, uint8_t dpc, uint8_t nmic, uint8_t nlbaf);
nvme_status_t nvme_ns_attach_chk(struct nvme_ns_attach *cmd, uint32_t num_ns);
nvme_status_t nvme_ctrlr_list_chk(struct nvme_ctrlr_list *ctrlr_list);
nvme_status_t nvme_sgl_chk(struct nvme_cmd *cmd);
void nvme_create_sq_cmd(struct nvme_cmd *cmd, uint64_t addr, uint16_t qid, uint16_t qsize, uint16_t cqid, uint16_t cid);
void nvmeof_create_sq_cmd(struct nvme_cmd *cmd, uint16_t qid, uint16_t qsize, uint16_t cqid, uint16_t cid);
void nvme_create_sq_cmd_rc(struct nvme_cmd *cmd, uint64_t addr, uint16_t qid, uint16_t qsize, uint16_t cqid, uint16_t cid);
void nvme_create_sq_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint16_t qid, uint16_t qsize, uint16_t cqid, uint16_t cid);
void nvme_create_cq_cmd(struct nvme_cmd *cmd, uint64_t addr, uint16_t qid, uint16_t qsize, uint16_t iv, uint16_t cid);
void nvmeof_create_cq_cmd(struct nvme_cmd *cmd, uint16_t qid, uint16_t qsize, uint16_t cqid, uint16_t cid);
void nvme_create_cq_cmd_rc(struct nvme_cmd *cmd, uint64_t addr, uint16_t qid, uint16_t qsize, uint16_t iv, uint16_t cid);
void nvme_create_cq_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint16_t qid, uint16_t qsize, uint16_t iv, uint16_t cid);
void nvme_delete_sq_cmd(struct nvme_cmd *cmd, uint16_t qid, uint16_t cid);
void nvme_delete_sq_cmd_le(struct nvme_cmd *cmd, uint16_t qid, uint16_t cid);
void nvme_delete_cq_cmd(struct nvme_cmd *cmd, uint16_t qid, uint16_t cid);
void nvme_delete_cq_cmd_le(struct nvme_cmd *cmd, uint16_t qid, uint16_t cid);
void nvme_idtfy_cmd(struct nvme_cmd *cmd, uint64_t addr, uint8_t cns, uint32_t nsid, uint16_t cid);
void nvme_idtfy_cmd_rc(struct nvme_cmd *cmd, uint64_t addr, uint8_t cns, uint32_t nsid, uint16_t cid);
void nvme_idtfy_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint8_t cns, uint32_t nsid, uint16_t cid);
void nvme_set_feat_cmd(struct nvme_cmd *cmd, uint8_t id, uint16_t num_queues, uint16_t cid);
void nvme_set_feat_num_queues_cmd_le(struct nvme_cmd *cmd, uint8_t id, uint16_t num_queues, uint16_t cid);
void nvme_set_feat_cmd_le(struct nvme_cmd *cmd, uint8_t id, uint16_t cid);
void nvme_abort_cmd_le(struct nvme_cmd *cmd, uint16_t cmd_cid, uint16_t cmd_qid, uint16_t cid);
void nvme_set_feat_cmd_async_ev_cfg_smart_temp(struct nvme_cmd *cmd, uint8_t id, uint16_t cid);
void nvme_set_feat_cmd_temp_thresh(struct nvme_cmd *cmd, uint8_t id, uint16_t cid, uint32_t thr_type, uint32_t temp_sel, uint16_t temp_val);
void nvme_async_cmd_le(struct nvme_cmd *cmd, uint16_t cid);
void nvme_async_cmd(struct nvme_cmd *cmd);
void nvme_ns_mgmt_create_cmd(struct nvme_cmd *cmd, uint64_t addr, uint16_t cid);
void nvme_ns_mgmt_create_cmd_rc(struct nvme_cmd *cmd, uint64_t addr, uint16_t cid);
void nvme_ns_mgmt_create_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint16_t cid);
void nvme_ns_mgmt_delete_cmd(struct nvme_cmd *cmd, uint32_t nsid, uint16_t cid);
void nvme_ns_mgmt_delete_cmd_le(struct nvme_cmd *cmd, uint32_t nsid, uint16_t cid);
void nvme_ns_attach_cmd(struct nvme_cmd *cmd, uint64_t addr, uint32_t nsid, uint16_t cid);
void nvme_ns_attach_cmd_rc(struct nvme_cmd *cmd, uint64_t addr, uint32_t nsid, uint16_t cid);
void nvme_ns_attach_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint32_t nsid, uint16_t cid);
void nvmeof_ns_attach_cmd_le(struct nvme_cmd *cmd, uint32_t nsid, uint16_t cid);
void nvme_ns_detach_cmd(struct nvme_cmd *cmd, uint64_t addr, uint32_t nsid, uint16_t cid);
void nvme_ns_detach_cmd_rc(struct nvme_cmd *cmd, uint64_t addr, uint32_t nsid, uint16_t cid);
void nvme_ns_detach_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint32_t nsid, uint16_t cid);
void nvme_get_log_page_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint16_t data_len, uint8_t page_id, uint16_t cid);
void nvme_get_log_cmd(struct nvme_cmd *cmd, uint64_t addr, uint32_t nsid, uint32_t data_len, uint8_t page_id, bool rae, uint8_t lsp, uint16_t lsi, uint64_t lpo, uint8_t uuid_ix);
void nvme_vs_api_cmd(struct nvme_cmd *cmd, uint64_t addr, uint8_t vs_hndlr_id, uint8_t dir, uint8_t subop, uint32_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint16_t cid);
void nvme_vs_api_cmd_le(struct nvme_cmd *cmd, uint64_t addr, uint8_t vs_hndlr_id, uint8_t dir, uint8_t subop, uint32_t offset, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint16_t cid);
void nvme_format_cmd(struct nvme_cmd *cmd, uint32_t nsid, uint8_t lba_format, uint8_t md_set, uint8_t prot_info, uint8_t protect_info_loc, uint8_t sec_er_set);
void nvme_flush_cmd(struct nvme_cmd *cmd, uint32_t nsid);
void nvme_wr_zeros_cmd(struct nvme_cmd *cmd, uint64_t offset, uint32_t len, uint32_t nsid, uint32_t lba_shift, uint8_t deallocate);
void nvme_deallocate_cmd(struct nvme_cmd *cmd, uint32_t nsid, uint8_t num_ranges, uint64_t addr);
void nvme_rw_cmd(struct nvme_rw *cmd, uint64_t offset, uint32_t len, uint64_t addr, void *prp_list0, void *prp_list1, uint8_t opcode, uint32_t nsid, uint32_t lba_shift, uint32_t cid);
void nvme_rw_cmd_le(struct nvme_rw *cmd, uint64_t offset, uint32_t len, uint64_t addr, void *prp_list0, void *prp_list1, uint8_t opcode, uint32_t nsid, uint32_t lba_shift, uint32_t cid);
static inline int
nvme_nprps_u(uint32_t unaligned, uint64_t len, uint32_t page_shift, uint32_t page_size)
 {uint32_t nprps =len >>page_shift; uint32_t modulo =len &(page_size -1);if(modulo ||unaligned){nprps +=1+((modulo +unaligned -1)>>page_shift);}return nprps;
}
static inline int
nvme_nprps(uint64_t data, uint64_t len, uint32_t page_shift, uint32_t page_size)
{uint32_t unaligned =data &(page_size -1);return nvme_nprps_u(unaligned, len, page_shift, page_size);
}
void nvme_cmd_set_data_sgl(struct nvme_cmd *cmd, uint64_t addr, size_t size);
void nvmeof_cmd_set_data_sgl(struct nvme_cmd *cmd, uint64_t addr, size_t size);
void nvme_cmd_set_data_sgl_le(struct nvme_cmd *cmd, uint64_t addr, size_t size);
void
nvmeof_cmd_set_data_sgl_le(struct nvme_cmd *cmd, uint64_t addr, size_t size);
void
nvme_kv_cmd_set_key_prp_le(struct nvme_cmd *cmd, uint64_t key_prp);
void
nvmeof_kv_cmd_set_key_prp_le(struct nvme_cmd *cmd, uint64_t key_prp);
void nvme_cmd_set_last_seg_sgl(struct nvme_cmd *cmd, uint64_t addr, size_t size);
int nvme_setup_prp_list_le(uint64_t data, uint32_t nprps, uint32_t page_shift, uint64_t *prp_list0, uint64_t *prp_list1);
int nvme_setup_prp_list_le_rc(uint64_t data, uint32_t nprps, uint32_t page_shift, uint64_t *prp_list0, uint64_t *prp_list1, uint64_t prp_list1_rpa);
int build_prp_list(struct nvme_rw *cmd, uint64_t data, uint64_t len, uint32_t page_shift, uint64_t *prp_list0, uint64_t *prp_list1);
struct fun_value_str {uint16_t value; const char *str;};
char const *fun_get_str(struct fun_value_str const *strings, uint16_t value);
static inline void
nvme_cmd_cmn_setup_le(struct nvme_cmd *cmd, uint8_t opcode, uint32_t nsid, uint32_t cid)
 {cmd->cmn.opcode =opcode; cmd->cmn.fuse_psdt =NVME_PSDT_SGL_MPTR_CONTIG_SHIFTED; cmd->cmn.nsid =htole32(nsid);cmd->cmn.cid =htole16(cid);}
static inline void
nvme_rw_cmd_setup_le(struct nvme_rw *cmd, uint64_t slba, uint32_t nlb, uint8_t opcode, uint32_t nsid, uint32_t cid)
 {nvme_cmd_cmn_setup_le((struct nvme_cmd *)cmd, opcode, nsid, cid);cmd->slba =htole64(slba);cmd->nlb =htole16(nlb);cmd->cmn.fuse_psdt =NVME_PSDT_SGL_MPTR_CONTIG_SHIFTED;}
void nvme_cmd_async_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_async_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_idtfy_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_idtfy_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_vs_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_vs_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_abort_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_abort_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_nsmgmt_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_nsmgmt_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_nsattach_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_nsattach_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_getlog_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_getlog_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_feat_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_feat_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_fmt_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_fmt_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_csq_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_csq_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_dsq_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_dsq_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_ccq_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_ccq_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_dcq_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_dcq_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_rw_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_rw_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvmeof_rw_cmd_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from, uint16_t cid_be);
void nvme_cmd_dsm_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_dsm_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_flush_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_flush_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_wr_zeros_cpy_letoh(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_wr_zeros_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_cmd_changed_blks_cpy_letoh(struct nvme_cmd *dst, struct nvme_cmd *src);
void nvme_cmd_changed_blks_cpy_htole(struct nvme_cmd *dst, struct nvme_cmd *src);
void nvme_nsdata_cpy_letoh(struct nvme_ns_data *to, struct nvme_ns_data *from);
void nvme_nsdata_cpy_htole(struct nvme_ns_data *to, struct nvme_ns_data *from);
void nvme_ctrlrdata_cpy_letoh(struct nvme_ctrlr_data *to, struct nvme_ctrlr_data *from);
void nvme_ctrlrdata_cpy_htole(struct nvme_ctrlr_data *to, struct nvme_ctrlr_data *from);
void nvme_nslist_cpy_letoh(uint32_t *to, uint32_t *from);
void nvme_nslist_cpy_htole(uint32_t *to, uint32_t *from);
void nvme_ctrlrlist_cpy_htole(uint16_t *to, uint16_t *from, uint16_t num_ctrlr);
void nvme_cpl_letoh(struct nvme_cpl *to, struct nvme_cpl *from);
void nvme_cpl_htole(struct nvme_cpl *to, struct nvme_cpl *from);
uint16_t nvme_adm_cmd_cpy_letoh(struct nvme_cmd *cmd, struct nvme_cmd *in_cmd);
uint16_t nvme_nvm_cmd_cpy_letoh(struct nvme_cmd *cmd, struct nvme_cmd *in_cmd);
void nvme_adm_cmd_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_nvm_cmd_cpy_htole(struct nvme_cmd *to, struct nvme_cmd *from);
void nvme_dump_lbaf(struct nvme_ns_data *ns_data);
uint8_t nvme_find_flbas(struct nvme_ns_data *ns_data, uint32_t lba_shift);
static inline bool
is_queue_full(uint32_t head, uint32_t tail, uint32_t qsize)
 {assert_msg(IS_POWER_OF_2(qsize),"invalid qsize %u",qsize);assert_msg(tail <=qsize,"tail %u, qsize %u",tail, qsize);assert_msg(head <=qsize,"head %u, qsize %u",head, qsize);return(((tail +1)&(qsize -1))==head);}
static inline bool
is_qfull(uint32_t head, uint32_t tail, uint32_t qsize)
{assert_msg(tail <=qsize,"tail %u, qsize %u",tail, qsize);assert_msg(head <=qsize,"head %u, qsize %u",head, qsize);return(((tail +1)%qsize)==head);
}
static inline int
get_npending(uint32_t head, uint32_t tail, uint32_t qsize)
{assert_msg(tail <=qsize,"tail %u, qsize %u",tail, qsize);assert_msg(head <=qsize,"head %u, qsize %u",head, qsize);int diff =tail -head; return((head <=tail)?diff :(diff +qsize));
}
void nvme_ctrlrdata_print(struct nvme_ctrlr_data *d);
void
nvme_cmd_cmn_cpy_letoh(struct nvme_cmd *dst, struct nvme_cmd *src);
void nvme_kv_store_le(struct nvme_cmd *cmd, uint32_t val_len, uint8_t *val, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid, void *prp_list0, void *prp_list1);
void nvme_kv_store_sgl_le(struct nvme_cmd *cmd, uint32_t val_len, uint8_t *val, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid);
void nvme_kv_retrieve_le(struct nvme_cmd *cmd, uint32_t val_len, uint8_t *val, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid, void *prp_list0, void *prp_list1);
void nvme_kv_retrieve_sgl_le(struct nvme_cmd *cmd, uint32_t val_len, uint8_t *val, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid);
void nvme_kv_delete_le(struct nvme_cmd *cmd, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid);
void nvme_kv_exist_le(struct nvme_cmd *cmd, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid);
void nvme_kv_list_le(struct nvme_cmd *cmd, uint32_t list_len, uint8_t *list_buf, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid, void *prp_list0, void *prp_list1);
void nvme_kv_list_sgl_le(struct nvme_cmd *cmd, uint32_t list_len, uint8_t *list_buf, uint8_t key_len, uint8_t *key, uint32_t nsid, uint32_t cid);
void nvme_print_kv_cmd(struct nvme_cmd *cmd);
const char *nvme_get_io_str(uint8_t opcode);
void nvme_err_log_entry_cpy_letoh(struct nvme_err_log *to, struct nvme_err_log *from);
void nvme_smart_log_cpy_letoh(struct nvme_smart_log *to, struct nvme_smart_log *from);
uint32_t
nvme_get_log_data_size(struct nvme_cmd *cmd);
uint32_t nvme_get_feat_data_size(struct nvme_cmd *cmd);
void nvme_fw_download_cmd(struct nvme_cmd *cmd, uint64_t addr, uint32_t len, uint32_t offset);
void nvme_fw_commit_cmd(struct nvme_cmd *cmd, uint8_t fs, uint8_t ca, uint8_t bpid);
bool nvme_fabrics_chk_property_valid(uint32_t reg_addr);
uint32_t nvme_fabrics_get_data_len(struct nvme_cmd *cmd);
void nvme_cmd_ns_flags_cpy_letoh(struct nvme_cmd *dst, struct nvme_cmd *src);
uint16_t nvme_calc_crd_setting(struct nvme_crd_info *crd_info);
void nvme_reset_crd_setting(struct nvme_crd_info *crd_info);

--------------

storage/include/rmmu_intf.h: 

static inline void *
rpa_to_vaptr_common(void *cookie, uint64_t addr, enum rmmu_dir *dir)
 {uint64_t pa; struct pci_func *func =cookie; uint32_t reg_id; pa =pci_func_rmmu_translate_from_pcie_to_f1(func, addr, 0,&reg_id, dir);return pa_to_xkphys_ptr(pa);}
static inline void *
rpa_to_vaptr(void *cookie, uint64_t addr)
{enum rmmu_dir dir; void *ret; ret =rpa_to_vaptr_common(cookie, addr, &dir);assert(dir !=RMMU_DIR_NO_ACCESS);return ret;
}
static inline void *
rpa_to_vaptr_rc_to_ep(void *cookie, uint64_t addr)
 {enum rmmu_dir dir; void *ret; ret =rpa_to_vaptr_common(cookie, addr, &dir);assert(dir &RMMU_DIR_FROM_RC);return ret;}
static inline void *
rpa_to_vaptr_ep_to_rc(void *cookie, uint64_t addr)
{enum rmmu_dir dir; void *ret; ret =rpa_to_vaptr_common(cookie, addr, &dir);assert(dir &RMMU_DIR_TO_RC);return ret;
}
enum fun_ret storage_rmmu_map(struct pci_func *func, uint64_t f1_addr, uint64_t len, enum rmmu_dir direction, uint32_t *reg_id, uint64_t *pcie_addr_out);
void storage_rmmu_unmap(struct pci_func *func, uint32_t reg_id, uint64_t f1_addr, uint64_t pcie_addr);

--------------

storage/include/storage_wp.h: 

extern struct workerpool *nu_storage_wp;
enum vp_selection_policy {BEST_FIT, BEST_FIT_REVERSE, BEST_FIT_ALTERNATE, RANDOM, BEST_FIT_THRESHOLD_BASED,};
enum vol_type_extended {RSV_TYPES_EXTENDED(GEN_RSV_TYPE_EXTENDED_ENUM)};
extern const char *vp_load_str[VP_LOAD_NUMTYPES];
typedef void(*vp_op_to_cost_fn)(uint32_t indx, struct vol_qos *qos, uint64_t *read_cost, uint64_t *write_cost);
void *rdsock_pool_client_init(vp_op_to_cost_fn get_cost_f, enum vp_selection_policy policy);
void *nvmeof_crypto_pool_client_init(vp_op_to_cost_fn get_cost_f, enum vp_selection_policy policy);
void *nvmeof_pool_client_init(vp_op_to_cost_fn get_cost_f, enum vp_selection_policy policy);
void *nvmeof_rdma_pool_client_init(vp_op_to_cost_fn get_cost_f, enum vp_selection_policy policy);
void *loadgen_pool_client_init(enum vp_selection_policy policy, bool use_storage_pool);
void *nss_pool_client_init(vp_op_to_cost_fn get_cost_f, enum vp_selection_policy policy);
void *storage_pool_client_init(struct workerpool **wp_list, uint8_t num_wp, vp_op_to_cost_fn get_cost_f, enum vp_selection_policy policy);
void storage_pool_client_set_treshold(void *handle, uint64_t small_cycle_treshold);
faddr_t storage_vp_get(void *handle, uint32_t cost_tabidx, uint64_t cookie, faddr_t affinity_vp, int typ, struct vol_qos *qos);
faddr_t storage_vp_get_diff_affinity_core(void *handle, uint32_t cost_tabidx, uint64_t cookie, faddr_t affinity_vp, int typ, struct vol_qos *qos);
void storage_vp_put(void *handle, faddr_t vp, uint32_t cost_tabidx, int typ, struct vol_qos *qos);
void storage_vp_put_by_cookie(void *handle, faddr_t vp, uint32_t const_tabidx, uint64_t cookie, int typ, struct vol_qos *qos);
bool vp_update_load(void *handle, faddr_t vp, uint32_t cost_tabidx, int typ, struct vol_qos *cur_qos, struct vol_qos *new_qos);
void storage_wp_uninstall_params_bridge_push(struct channel *channel);
void storage_pool_client_register(void *handle);
void storage_pool_test_client_register(void *handle);
void storage_vp_print_pool_load(void *handle, uint64_t *minl, uint64_t *maxl);
bool storage_pool_is_clean(void *);
void free_storage_pool_client(void *handle);
uint64_t storage_wp_test_get_load_in_cycles_persec(void *handle, uint32_t cost_tabidx, struct vol_qos *qos);
struct fun_json *storage_wp_test_retrieve_placement_info();
void storage_wp_qos_vps_init(void *handle);
uint32_t storage_pool_get_num_vps(void *handle);
uint32_t storage_wp_get_fabrics_pool_num_vps();

--------------

storage/include/storage_wu_types.h: 

struct hu_fn_flow;
struct nvme_vs_api_data;
typedef void(*epnvme_api_fn)(struct channel *channel, struct hu_fn_flow *hu_fn_f, void *inbuf, void *outbuf, struct nvme_vs_api_data *api_data);
typedef uint64_t ec_map_t;

--------------

storage/include/vol_crypto.h: 

static_assert((XTS_TWEAK_EUI64_LEN +XTS_TWEAK_LBA_LEN)==XTS_TWEAK_LEN,"tweak length must be 16B");
struct vol_crypto {uint8_t *key; uint16_t keylen; uint8_t xtweak[VOL_CRYPTO_MAX_TWEAK_LEN];uint16_t xtweaklen;};
void vol_crypto_set_default(struct vol_crypto *crypto);

--------------

storage/include/vol_ec_compute_api.h: 

void vol_ec_start_compute_push(struct channel *channel, struct flow *flow, struct ec_operate *ec_params, uint8_t *datap, uint8_t *parityp, void *engine_handle, uint16_t stridelen, ec_map_t avail_map);
void vol_ec_engine_cfg_init_push(struct channel *channel, struct flow *flow, faddr_t vp, void **engine_handle_ptr, uint8_t ndata, uint8_t nparity);
void vol_ec_engine_cfg_deinit_push(struct channel *channel, void *engine_handle);

--------------

storage/include/vol_filter_param.h: 

struct vol_crypto_nvme_vs {uint8_t key[VOL_CRYPTO_MAX_KEY_LEN];uint16_t keylen; uint8_t xtweak[VOL_CRYPTO_MAX_TWEAK_LEN];uint16_t xtweaklen;};
struct vol_compression {int compress_type; int uncompress_type; int effort;};
struct vol_clone {fun_uuid_t base_uuid; uint32_t hydration_flag;};
struct vol_dedup {fun_uuid_t pool_uuid;};
struct vol_snap {fun_uuid_t base_uuid;};
struct vol_qos {uint32_t min_read_only_iops; uint32_t max_read_only_iops; uint32_t min_write_iops; uint32_t max_write_iops; uint64_t block_size;};

--------------

storage/include/vol_xts_api.h: 

struct vol_xts_flow {ALIGNED(FLOW_ALIGN_SIZE)struct flow _flow; struct fun_crypto_ctx crypto_ctx; size_t block_size; bool blkhdr_enabled; uint8_t crypto_op; uint64_t requests; uint64_t requests_succeeded; uint64_t requests_failed; uint64_t unwritten_reads; uint64_t xtweak1; struct vol_qos *qos; bool is_dest_vp_owned; void *stats_bridge;};
void vol_xts_encrypt_from_acc_ptr_to_buf_and_free_acc_ptr_push(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);
void vol_xts_encrypt_from_buf_to_buf_push(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);
void vol_xts_encrypt_vector_push(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);
void vol_xts_aes_vector(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);
void vol_xts_decrypt_from_buf_to_buf_push(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);
void vol_xts_decrypt_from_buf_to_acc_ptr_push(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);
void vol_xts_decrypt_vector_push(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);
int vol_xts_delete_handle_push(struct channel *channel, struct flow *flow, struct vol_xts_flow **xts_f_p);
int _vol_xts_create_handle_push(struct channel *channel, struct flow *flow, struct vol_crypto *crypto, uint8_t crypto_op, uint8_t blkhdr_enabled, struct vol_qos *qos, struct vol_xts_flow **xts_f_p, faddr_t dest_vp);
int vol_xts_create_handle_push(struct channel *channel, struct flow *flow, struct vol_crypto *crypto, uint8_t crypto_op, uint8_t blkhdr_enabled, struct vol_qos *qos, struct vol_xts_flow **xts_f_p);
bool vol_xts_is_blkhdr_enabled(struct vol_flow *vol_f);
void vol_xts_decrypt_and_decompress_push(struct channel *channel, struct vol_xts_flow *xts_f, struct fun_vol_acc_op *acc);

--------------

storage/include/vol_zip_api.h: 

struct vol_zip_flow {ALIGNED(FLOW_ALIGN_SIZE)struct flow _flow; size_t block_size; zip_effort_t effort; uint64_t compress_requests; uint64_t compress_requests_failed; uint64_t compress_requests_succeeded; uint64_t compress_requests_uncompressible; uint64_t total_compressed_bytes; uint64_t decompress_requests; uint64_t decompress_requests_failed; uint64_t decompress_requests_succeeded; uint64_t decompress_unwritten_reads; struct vol_qos *qos; bool is_dest_vp_owned; void *stats_bridge;};
void vol_zip_compress_from_buf_to_acc_ptr_push(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_compress_from_buf_to_acc_mbuf_push(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_compress_vector_push(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_compress_vectors(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_decompress_from_acc_ptr_to_buf_and_free_acc_ptr_push(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_decompress_from_buf_to_acc_mbuf_push(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_compress_to_acc_ptr_and_encrypt_push(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_decompress_vector_push(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
void vol_zip_decompress_vectors(struct channel *channel, struct vol_zip_flow *zip_f, struct fun_vol_acc_op *acc);
int vol_zip_delete_handle_push(struct channel *channel, struct flow *flow, struct vol_zip_flow **zip_f_p);
int _vol_zip_create_handle_push(struct channel *channel, struct flow *flow, uint8_t effort, uint32_t block_size, struct vol_zip_flow **zip_f_p, struct vol_qos *qos, faddr_t dest_vp);
int vol_zip_create_handle_push(struct channel *channel, struct flow *flow, uint8_t effort, uint32_t block_size, struct vol_zip_flow **zip_f_p, struct vol_qos *qos);

--------------

storage/nvmeof/fabrics.h: 

static_assert(MAX_NVMEOF_QUEUES >=2,"Mininum 2 queues are needed");
static_assert(MAX_NVMEOF_HOST_QUEUES >=2,"Mininum 2 queues are needed");
typedef enum {FABRICS_TCP_STATUS_WITH_C2H =(1<<0),}fabrics_ctrlr_flags_t;
typedef enum {FABRICS_CLIENT, FABRICS_SERVER, FABRICS_LISTENER}fabrics_role_t;
struct fabrics_tr_params;
struct nvmeof_flow;
struct nvmeof_flow;
struct fabrics_tr_params;
typedef void(*fabricst_tr_rw_done_t)(struct frame **frame, struct nvmeof_flow *nvmeof_f, struct fabrics_tr_params *params);
struct fabrics_tr_params {void *handle; void *in; void *out; void *cmd; void *in_hdr; void *in_msg; uint64_t slba; uint16_t md_size; struct{uint16_t nlb; uint16_t abort_status;};uint8_t buf_type; uint8_t num_vectors; uint8_t conn_type; uint8_t ext_md; bool in_use; uint64_t pdu_num; uint16_t qid; uint16_t int_cid; uint16_t status; void *out_hdr; void *out_msg; struct fun_mbuf **outbuf_p; union {uint32_t hdr_len; uint32_t wz_io_len;};union {uint32_t in_msglen; uint32_t wz_done;};uint32_t in_datalen; uint32_t rw_data_len; struct flow *callee_f; void *epnvme_cmd; fun_time_t cmd_start_time; fun_time_t read_mbuf_alloc_start_time; void *in_data; union {struct{struct fun_mbuf *inbuf; struct fun_ptr_and_size *inmeta;};struct fun_ptr_and_size *in_vectors;};void *out_data; uint32_t out_data_len; struct opstats opstat; uint16_t ipo; uint8_t iattr; uint8_t lock_flags; bool refbuf_alloc; union {uint64_t reg_val; void *ctx_ptr; struct frame *pending_io_frame;};TAILQ_ENTRY(fabrics_tr_params)queue;
 faddr_t cid_vp;
};
enum fabrics_conn_type {FABRICS_CMD_CONN =0, FABRICS_ADM_CMD_CONN =1, FABRICS_NVM_CMD_CONN =2,};
enum nvmeof_conn_state {NVMEOF_CONN_STATE_INIT =0, NVMEOF_CONN_STATE_LISTEN, NVMEOF_CONN_STATE_OPENING, NVMEOF_CONN_STATE_ACCEPTING, NVMEOF_CONN_STATE_CONNECTING, NVMEOF_CONN_STATE_CONNECTING_R2T_SENT, NVMEOF_CONN_STATE_CONNECTED, NVMEOF_CONN_STATE_DISCONNECTING, NVMEOF_CONN_STATE_REMOTE_CLOSED, NVMEOF_CONN_STATE_CLOSING, NVMEOF_CONN_STATE_FAILED, NVMEOF_CONN_STATE_MAX,};
struct fabricst_cmd {struct nvme_cmd cmd; bool valid; bool logged; bool resp_sent; bool is_aborted; fun_time_t start_time; struct frame *frame; uint16_t cid; uint8_t opcode;};
enum fabrics_role_type {NVMEOF_CLIENT =0x00, NVMEOF_SERVER =0x01,};
enum fabrics_qstate {QUEUE_NORMAL =0x00, QUEUE_BLOCKED =0x01,};
struct fabrics_connect_params {uint16_t recfmt; uint16_t qid; uint16_t sqsize; uint8_t cattr; uint32_t kato;};
struct nvmeof_ns_props {enum nvme_ns_flags ns_flags; uint32_t lba_size; uint8_t nlbaf; uint8_t flbas; uint8_t crctype; struct nvme_lbaf lbafs[NVME_NS_DATA_NUM_LBAFS];};
struct nvmeof_nsdata {struct nvmeof_ns_props ns_props[MAX_NVMEOF_HOST_NS];};
struct nvmeof_ns {void *state_update_ctx; uint8_t ana_state;};
struct nvmeof_shared_vp_info
 {bool shareable_flow_exists; faddr_t fabrics_vp; vol_qos_handle_t vol_qos_handle;};
struct nvmeof_flow {ALIGNED(FLOW_ALIGN_SIZE)struct flow rxflow; ALIGNED(FLOW_ALIGN_SIZE)struct flow txflow; struct fabricsh_fsm fsm; uint32_t max_io_size; uint32_t ctrlr_flags; struct nvmeof_nsdata *ns_data; void *handle; uint8_t qstate; uint8_t transport; uint8_t conn_type; uint16_t qsize; uint16_t cid_mask; uint16_t cid_shift; uint16_t outstanding_cmds; BITMAP(cid_bm, NVME_MAX_QDEPTH);struct{uint16_t cid_gen; void *params; struct fun_mbuf *inbuf; fun_time_t start_time;}params[NVME_MAX_QDEPTH];uint8_t *blk_hdrs; struct fun_ptr_and_size *ptrs; uint64_t pdu_counter; uint64_t reads; uint64_t writes; uint64_t writes_done; uint64_t reads_done; uint64_t writes_success; uint64_t reads_success; uint64_t compares; uint64_t compares_done; uint64_t compares_success; uint64_t compares_failed; uint64_t write_zeroes; uint64_t write_zeroes_done; uint64_t write_zeroes_success; struct opperf readperf; struct opperf writeperf; uint32_t max_blks_per_io; uint16_t req_queued; uint16_t max_req_queued; uint32_t f_magic; uint8_t role; uint8_t conn_state; uint8_t act_conn_state; uint8_t icreq_dgst; uint8_t mdts; uint32_t vol_type; void *buf; struct fabrics_ip ip; uint16_t qid; uint16_t sqhd; uint16_t qtail; struct fabricst_cmd *cmds; struct hu_fn_flow *hu_fn_f; struct metaflow *mf; struct fabrics_conn_info *conn; struct fabrics_connect_params connect_params; uint16_t icreq_recfmt; uint8_t icreq_hpda; uint32_t icreq_maxr2t; uint16_t unblock_threshold; uint16_t icresp_cpda; uint32_t icresp_maxdata; void *ctxt; fabricst_tr_rw_done_t read_done_fn; fabricst_tr_rw_done_t write_done_fn; timerid_t q_timer; struct timer_arg q_timer_cookie; long_timer_t ka_timer; uint32_t kato; int socketid; uint16_t host_port; uint32_t blocks; uint32_t unblocks; uint8_t num_keep_alive_sent; struct vol_qos qos; uint64_t ios_timedout; uint64_t send_done_delayed; uint64_t ios_failed_no_connect; uint64_t ios_failed; struct fun_props_bridge *stats_bridge; struct fun_props_bridge *info_bridge; bool close_pending; bool disconnect_pending; bool close_deferred; struct frame *close_frame; TAILQ_HEAD(pending_io_q, frame_q)pending_io_q; uint16_t icreq_cid; bool migrating; struct nvmeof_shared_vp_info shared_vp_info; struct rdsock_port_id port_id; uint32_t error_status; uint32_t dnr_status; uint32_t no_crd_status; struct fabricsh_ops *ops; ALIGNED(FLOW_ALIGN_SIZE)struct flow cm_flow; void *conn_context; uint32_t rdma_qp_id; uint32_t rdma_cm_id; uint32_t stags[NVME_MAX_QDEPTH];uint32_t *recv_buffers; struct fabrics_tr_params *params_ptr; struct nss_params *nss_params_ptr; uint64_t total_read_mbuf_alloc_time; uint64_t total_read_recv_time; uint64_t total_read_process_time; uint64_t pdus_recvd; uint64_t resp_sent; uint64_t vec_c2h_sent; uint64_t send_done; fun_time_t last_ka_received; struct frame *first_fused_command_frame; struct fabrics_tr_params *first_fused_command_params; struct frame *second_fused_command_frame; struct fabrics_tr_params *second_fused_command_params; TAILQ_HEAD(fuse_pending_io_q, fabrics_tr_params)fuse_pending_io_q;
}__attribute__((aligned(DB_FLOW_ALIGN_SIZE)));
static inline bool
fabrics_get_internal_cid(struct nvmeof_flow *nvmeof_f, uint16_t *cid)
 {unsigned int bit; bool ok =bitmap_find_available(&nvmeof_f->cid_bm, &bit);if(!ok ||(bit >=NVME_MAX_QDEPTH)){assert(0);return false;}*cid =bit; return true;
}
enum fabrics_cmd_type {FABRICS_PROPERTY_SET =0x00, FABRICS_CONNECT =0x01, FABRICS_PROPERTY_GET =0x04, FABRICS_AUTH_SEND =0x05, FABRICS_AUTH_RECV =0x06, FABRICS_VS_START =0xC0,};
struct fabrics_cmd_cmn {uint8_t opcode; uint8_t rsvd1; uint16_t cid; uint8_t fctype; uint8_t rsvd;};
struct fabrics_cmd {struct fabrics_cmd_cmn cmn; uint8_t rsvd1[58];};
static_assert(FABRICS_CMD_SIZE ==64,"Incorrect size of fabrics_cmd");
struct fabrics_capsule_cmd {struct fabrics_cmd_cmn cmn; uint8_t rsvd2[34];uint8_t fabrics_specific[24];};
static_assert(sizeof(struct fabrics_capsule_cmd)==FABRICS_CMD_SIZE,"Incorrect size of fabrics_capsule_cmd");
struct fabrics_auth_recv_cmd {struct fabrics_cmd_cmn cmn; uint8_t rsvd1[18];struct nvme_sgl sgl1; uint8_t rsvd2; uint8_t spsp0; uint8_t spsp1; uint8_t secp; uint32_t al; uint8_t rsvd4[16];};
static_assert(sizeof(struct fabrics_auth_recv_cmd)==FABRICS_CMD_SIZE,"Incorrect size of fabrics_ath_rev_cmd");
struct fabrics_auth_send_cmd {struct fabrics_cmd_cmn cmn; uint8_t rsvd1[18];struct nvme_sgl sgl1; uint8_t rsvd2; uint8_t spsp0; uint8_t spsp1; uint8_t secp; uint32_t tl; uint8_t rsvd4[16];};
static_assert(sizeof(struct fabrics_auth_send_cmd)==FABRICS_CMD_SIZE,"Incorrect size of fabrics_auth_send_cmd");
struct fabrics_connect_data {uint8_t hostid[16];uint16_t cntlid; uint8_t rsvd1[238];uint8_t subnqn[256];uint8_t hostnqn[256];uint8_t rsvd2[256];};
static_assert(sizeof(struct fabrics_connect_data)==1024,"Incorrect size of fabrics_connect_data");
struct fabrics_connect_cmd {struct fabrics_cmd_cmn cmn; uint8_t rsvd1[18];struct nvme_sgl sgl; uint16_t recfmt; uint16_t qid; uint16_t sqsize; uint8_t cattr; uint8_t rsvd2; uint32_t kato; uint8_t rsvd4[12];};
static_assert(sizeof(struct fabrics_connect_cmd)==FABRICS_CMD_SIZE,"Incorrect size of fabrics_connect_cmd");
struct fabrics_resp {uint64_t cmd_specific; union{struct{uint16_t sqhd; uint16_t rsvd2;};uint32_t cdw2;};union {struct{uint16_t cid; uint16_t status;};uint32_t cdw3;};
};
static_assert(FABRICS_RESP_SIZE ==16,"Incorrect size of fabrics_resp");
enum nvmeof_iattr {NVMEOF_IATTR_SQE =0, NVMEOF_IATTR_DATA =1,};
struct fabrics_connect_resp {union{struct{uint16_t cntlid; uint16_t authreq;};struct {uint16_t ipo; uint8_t iattr; uint8_t rsvd1;};uint32_t raw;};uint32_t rsvd2; uint16_t sqhd; uint16_t rsvd3; uint16_t cid; uint16_t status;
};
static_assert(sizeof(struct fabrics_connect_resp)==FABRICS_RESP_SIZE,"Incorrect size of fabrics_connect_resp");
enum fabrics_prop_size_type {FABRICS_PROPERTY_ATTRIB_SIZE_4 =0, FABRICS_PROPERTY_ATTRIB_SIZE_8 =1,};
struct fabrics_prop_get_cmd {struct fabrics_cmd_cmn cmn; uint8_t rsvd1[34];uint8_t attrib; uint8_t rsvd3[3];uint32_t offset; uint8_t rsvd4[16];};
static_assert(sizeof(struct fabrics_prop_get_cmd)==FABRICS_CMD_SIZE,"Incorrect size of fabrics_prop_get_cmd");
struct fabrics_prop_get_resp {union{uint64_t u64; struct{uint32_t low; uint32_t high;};}val; uint16_t sqhd; uint16_t rsvd1; uint16_t cid; uint16_t status;
};
static_assert(sizeof(struct fabrics_prop_get_resp)==FABRICS_RESP_SIZE,"Incorrect size of fabrics_prop_get_resp");
struct fabrics_prop_set_cmd {struct fabrics_cmd_cmn cmn; uint8_t rsvd1[34];uint8_t attrib; uint8_t rsvd3[3];uint32_t offset; union{uint64_t u64; struct{uint32_t low; uint32_t high;};}val; uint8_t rsvd4[8];
};
static_assert(sizeof(struct fabrics_prop_set_cmd)==FABRICS_CMD_SIZE,"Incorrect size of fabrics_prop_set_cmd");
enum fabrics_status_code {FABRICS_SC_CONN_INCOMPAT_FMT =0x80, FABRICS_SC_CONN_CTRLR_BUSY =0x81, FABRICS_SC_CONN_INVAL_PARAMS =0x82, FABRICS_SC_CONN_RESTART_DISC =0x83, FABRICS_SC_CONN_INVAL_HOST =0x84, FABRICS_SC_DISC_LOG_RESTART =0x90, FABRICS_SC_AUTH_REQD =0x91,};
enum fabrics_secure_channel {SECURE_CHANNEL_NOT_SPECIFIED =0x0, SECURE_CHANNEL_REQUIRED =0x1, SECURE_CHANNEL_NOT_REQUIRED =0x2,};
enum fabrics_addr_family {FABRICS_ADDR_FAMILY_AF_INET_IPV4 =1, FABRICS_ADDR_FAMILY_AF_INET_IPV6 =2, FABRICS_ADDR_FAMILY_AF_INET_IB =3, FABRICS_ADDR_FAMILY_LOOPBACK =254,};
enum fabrics_subtype {FABRICS_SUBTYPE_NVM =0x0, FABRICS_SUBTYPE_DISCOVERY =0x1,};
struct fabrics_subsystem {uint32_t id; char subnqn[NQN_MAX_LENGTH];enum fabrics_subtype subtype; TAILQ_HEAD(,fabrics_session)sessions; uint32_t num_hosts; TAILQ_HEAD(,fabrics_host)hosts; TAILQ_ENTRY(fabrics_subsytem)entries;};
struct fabrics_disc_log_page_entry {uint8_t transport; uint8_t adrfam; uint8_t subtype; struct{uint8_t secure_channel:2; uint8_t rsvd:6;}treq; uint16_t portid; uint16_t cntlid; uint16_t asqsz; uint8_t rsvd1[22];char trsvcid[FABRICS_TR_SVCID_MAX_LEN];uint8_t rsvd2[192];char subnqn[256];char traddr[FABRICS_TR_ADDR_MAX_LEN];uint8_t tsas[256];
};
struct disc_log_page {uint64_t gen_ctr; uint64_t num_rec; uint16_t rec_fmt; uint8_t rsvd1[1006];struct fabrics_disc_log_page_entry entries[0];};
struct nvme_rdma_cm_req {uint16_t recfmt; uint16_t qid; uint16_t hrqsize; uint16_t hsqsize; uint16_t cntlid; uint8_t rsvd[22];};
struct nvme_rdma_cm_reply {uint16_t recfmt; uint16_t crqsize; uint8_t rsvd[28];};
static inline void
fabrics_common(struct fabrics_cmd *cmd, uint32_t fctype, uint32_t cid)
 {cmd->cmn.opcode =NVME_FABRICS; cmd->cmn.cid =htole16(cid);cmd->cmn.fctype =fctype;}
typedef struct fabrics_disc_log_page_entry fabrics_rds_transport_info;
struct fabrics_rds_transport {const char *trname; uint16_t max_qdepth; fabrics_rds_transport_info tr_info;};
void *nvme_cmd_and_md_zalloca(struct frame **frame, unsigned int cmd_size);
int fabrics_init(struct channel *channel, uint32_t local_addr);
void fabrics_fini(void);
void fabrics_connect_data_letoh(struct fabrics_connect_data *to, struct fabrics_connect_data *from);
struct fabrics_tr_params *
fabrics_tr_alloc_params(struct frame **frame, struct nvmeof_flow *nvmeof_f, void *in, uint16_t cid, uint32_t max_msg_sz, enum nvme_transport_type transport);
void nvmeof_pool_init(void);
faddr_t nvmeof_vp_get(uint32_t id, struct vol_qos *qos);
faddr_t nvmeof_vp_get_by_affinity(uint32_t id, struct vol_qos *qos, faddr_t affinity_vp, enum nvme_transport_type transport);
void nvmeof_vp_put(faddr_t vp, struct vol_qos *iops, enum nvme_transport_type transport);
bool nvmeof_vp_update_load(faddr_t vp, struct vol_qos *cur_qos, struct vol_qos *new_qos);
void nvmeof_install_props_bridge_push(struct channel *channel, struct nvmeof_flow *nvmeof_f);
void nvmeof_uninstall_props_bridge_push(struct channel *channel, struct nvmeof_flow *nvmeof_f);
const char *fabrics_transport_str(enum nvme_transport_type transport);
void fabrics_print_conn_info(struct fabrics_conn_info *conn_info, uint8_t log_level);
fun_map_callbacks_t fun_map_fabrics_conn_info_callbacks(void);
fun_map_callbacks_t fun_map_fabrics_target_conn_info_callbacks(void);
void fabrics_save_connect_params_letoh(struct fabrics_connect_params *connect_params, struct fabrics_connect_cmd *cmd);
void fabrics_normalize_qos(struct vol_qos *qos, uint32_t conn);
bool fabrics_can_update_qos(struct vol_qos *cur_qos, struct vol_qos *new_qos);
uint32_t fabricsh_get_resp_len(struct nvmeof_flow *nvmeof_f, struct nvme_cmd *cmd);
static inline void
fabrics_connect_invalid_params(struct fabrics_tr_params *params, uint16_t ipo, uint8_t iattr)
 {params->status =nvme_cs_status(FABRICS_SC_CONN_INVAL_PARAMS);params->ipo =ipo; params->iattr =iattr;}
bool fabrics_stats_enabled(void);
void fabrics_enable_stats(bool enable);

--------------

storage/nvmeof/host/fabricsh_fsm.h: 

struct fabricsh_params;
struct fabricsh_impl;
struct fabricsh_fsm_state {void(*state_fn)(struct channel *channel, struct flow *flow, uint16_t event, struct fabricsh_params *params);uint16_t state; const char *desc;};
struct fabricsh_fsm {struct fabricsh_fsm_state *state_tbl; uint16_t cur_state; uint16_t max_states;};
enum fabricsh_nvmeof_states {NVMEOF_STATE_INIT =1, NVMEOF_STATE_OPENING, NVMEOF_STATE_CLOSE_DURING_OPEN, NVMEOF_STATE_ERROR, NVMEOF_STATE_CONNECTED, NVMEOF_STATE_REMOTE_CLOSED, NVMEOF_STATE_DISCONNECTING, NVMEOF_STATE_CLOSE_WAIT, NVMEOF_STATE_MAX,};
enum fabricsh_fh_user_states {FH_USER_STATE_INIT =1, FH_USER_STATE_OPENING, FH_USER_STATE_CONNECTED, FH_USER_STATE_CLOSING, FH_USER_STATE_RECOVERY_CLOSING, FH_USER_STATE_RECOVERY_OPENING, FH_USER_STATE_CONN_ERROR, FH_USER_STATE_RECOVERY_CLOSE_DONE_WAIT, FH_USER_STATE_RECOVERY_WAIT, FH_USER_STATE_MAX,};
struct fabricsh_impl;
struct fabricsh_params;
void fabricsh_fh_user_fsm_initialize(struct fabricsh_impl *fh);
void fabricsh_fh_user_start_open(struct channel *channel, struct fabricsh_params *params);
void fabricsh_fh_user_start_close(struct channel *channel, struct fabricsh_params *params);

--------------

storage/nvmeof/target/fabricst_tr.h: 

struct epnvme_async_evt_ctx;
enum fabrics_ctrlr_state {FABRICS_CTRLR_STATE_INIT =0, FABRICS_CTRLR_STATE_DISCONNECT, FABRICS_CTRLR_STATE_REMOTE_CLOSING,};
struct fabrics_ctrlr_ctxt {struct fabrics_conn_info conn_info; struct hu_fn_flow *hu_fn_f; struct fabrics_ip ip; uint32_t ref_cnt; int32_t active_connections; faddr_t ctxt_vp; uint8_t state; uint8_t close_done_pushed; uint8_t vol_type; struct nvmeof_flow **nvmeof_f; uint16_t num_io_queues; uint32_t num_shapers; struct vol_qos qos; uint32_t ctrlr_flags; fun_uuid_t ctrlr_uuid; fun_uuid_t base_vol_uuid; bool qos_enabled; struct frame *connect_frame; uint16_t shared_ctrlr_id; faddr_t l2_shaper_vp; bool in_use; uint32_t lba_size; uint32_t host_lba_size; int pending_aborts; STAILQ_ENTRY(fabrics_ctrlr_ctxt)next;};
struct fabricst_conn_group
 {struct fabrics_conn_info conn_info; struct fabrics_ctrlr_ctxt*ctxt_arr[MAX_CONTROLLER_PER_GROUP];uint8_t num_controllers;};
struct fabricst_tr_open_req {struct fabrics_ctrlr_ctxt ctrlr; bool enable_connection; uint16_t status;};
enum fabrics_ip_ctxt_state {FABRICS_IP_CTXT_STATE_INIT =0, FABRICS_IP_CTXT_STATE_ONLINE, FABRICS_IP_CTXT_STATE_DISCONNECT,};
struct fabrics_ip_ctxt {struct fabrics_ip ip; void *listener; uint8_t transport; uint8_t state; uint32_t ref_cnt; faddr_t ctxt_vp;};
struct fabricst_shared_resrcs
 {uint16_t ref_cnt; faddr_t fabrics_vp; struct vol_qos_params shaper_create_config; struct vol_qos qos;};
struct fabricst_tr_global {bool inited; struct fun_map *fabricst_ctrlr_map; struct fun_set *fabricst_ip_map; struct fun_set *fabricst_vol_map; faddr_t fabricst_tr_vp; bool enable_l2_shaper; struct rltable *fabricst_vol_map_lock; struct fun_map *fabricst_psk_map;};
struct fabricst_tr_open_params {fun_uuid_t ctrlr_uuid; int32_t status;};
struct fabricst_vol_info {struct vol_qos qos; uint16_t max_io_queues; uint32_t num_shapers; struct fabricst_shared_resrcs *shared_resrcs; fun_uuid_t base_vol_uuid; uint16_t num_controllers; STAILQ_HEAD(,fabrics_ctrlr_ctxt)ctrlr_ctxt_list; struct qosl_shaper_info l2_shaper; uint64_t shared_ctrlr_id_generator;};
void fabricst_tr_open_push(struct channel *,struct fabricst_tr_open_req *oreq);
void fabricst_tr_close_push(struct channel *,struct fabricst_tr_open_req *oreq);
void fabricst_tr_get_ip_ctxt_push(struct channel *,struct fabrics_ip *ip, struct fabrics_ip_ctxt **ip_ctxt);
void fabricst_tr_get_ctrlr_ctxt_push(struct channel *,uint16_t qid, struct fabrics_conn_info *conn_info, struct fabrics_ctrlr_ctxt **ctrlr_ctxt);
void fabricst_tr_send_async_event_push(struct channel *,struct epnvme_async_evt_ctx *async_ctx);
void fabricst_tr_enable_connection_push(struct channel *,struct fabricst_tr_open_params *params);
void fabricst_tr_close_done_push(struct channel *,struct flow *flow, struct fabrics_ctrlr_ctxt *ctxt);
void fabricst_tr_check_for_close_push(struct channel *,struct hu_fn_epnvme_ctrlr *ctrlr, struct epnvme_delete_params *params);
void fabricst_add_ctrlr_ctxt_to_volmap_push(struct channel *,struct fabrics_ctrlr_ctxt *ctrlr_ctxt, uint16_t *status);
void fabricst_remove_ctrlr_ctxt_from_volmap_push(struct channel *,struct fabrics_ctrlr_ctxt *ctrlr_ctxt);
void fabricst_nvmeof_get_shareable_resrcs_push(struct channel *,struct fabrics_ctrlr_ctxt *ctrlr_ctxt, struct nvmeof_flow *nvmeof_f);
void fabricst_nvmeof_put_shareable_resrcs_push(struct channel *,struct fabrics_ctrlr_ctxt *ctrlr_ctxt, struct nvmeof_flow *nvmeof_f);
void fabricst_enable_l2_shaper_push(struct channel *,bool enable);
void fabricst_update_qos_credits_push(struct channel *,fun_uuid_t vol_uuid, struct vol_qos *new_qos);
int
fabricst_add_ctrlr_to_conn_group(struct fabrics_conn_info *conn_info, struct fabrics_ctrlr_ctxt *ctrlr_ctxt, struct fabricst_conn_group *new_conn_group);
int
fabricst_remove_ctrlr_from_conn_group(struct fabrics_conn_info *conn_info, struct fabrics_ctrlr_ctxt *ctrlr_ctxt);
struct fabrics_ctrlr_ctxt*
fabricst_reserve_ctrlr_from_conn_group(struct fabrics_conn_info *conn_info);
void
fabricst_release_ctrlr_to_conn_group(struct fabrics_conn_info *conn_info, struct fabrics_ctrlr_ctxt *ctrlr_ctxt);
struct fabrics_ctrlr_ctxt*
fabricst_get_reserved_ctrlr_id_from_conn_group(struct fabrics_conn_info *conn_info);
void
fabricst_tr_tls_psk_find_push(struct channel *channel, void *tls_psk);

--------------

storage/qos/vol_qos.h: 

typedef void(*vol_qos_callback_f)(uint64_t *context, uint32_t num_read, uint32_t num_write);
enum vol_qos_op_type
 {VOL_QOS_OP_INVALID =0, VOL_QOS_OP_WRITE =1, VOL_QOS_OP_READ =2, VOL_QOS_OP_LAST =3,};
typedef uint32_t vol_qos_handle_t;
struct vol_qos_params
 {uint32_t guanteed_credits; uint32_t peek_credits; uint32_t peek_credit_clip; uint32_t read_credits; uint32_t write_credits; uint16_t shaper_flags; faddr_t vp; enum qosl_shaper_mode mode; struct qosl_shaper_info *parent; vol_qos_handle_t vol_qos_handle; volDeqCb_t deq_callback; enum fun_ret status;};
struct vol_qos_delete_params
 {vol_qos_handle_t vol_qos_handle; faddr_t vp; enum fun_ret status;};
struct vol_qos_enqueue_params
 {vol_qos_handle_t vol_qos_handle; bool new_enqueue; uint32_t num_read; uint32_t num_write; vol_qos_callback_f callback; void *cb_context; bool send_immediate; enum fun_ret status;};
void vol_qos_create_push(struct channel *channel, struct vol_qos_params *req);
void vol_qos_create_exec_wu(struct vol_qos_params *req);
void vol_qos_update_push(struct channel *channel, struct vol_qos_params *update_params);
void vol_qos_update_exec_wu(struct vol_qos_params *req);
void vol_qos_delete_push(struct channel *channel, struct vol_qos_delete_params *req);
void vol_qos_delete_exec_wu(struct vol_qos_delete_params *req);
void vol_qos_init_vp(faddr_t vp);
uint32_t vol_qos_iops_to_credits(uint32_t read_iops, uint32_t write_iops, uint32_t read_credits, uint32_t write_credits);
uint32_t vol_qos_credits_to_credits_per_sec(uint32_t qos_credits);
void vol_qos_calculate_per_io_credits(uint32_t read_iops, uint32_t write_iops, uint32_t *read_credits, uint32_t *write_credits, uint16_t *shaper_flags);
uint32_t vol_qos_refresh_count_per_sec();

--------------

utils/common/approx_histo.h: 

typedef uint8_t approx_histo_bucket_t;
struct approx_interval {uint64_t min; uint64_t max; uint64_t value;};
uint64_t approx_linear_histo_incr(uint64_t histo, uint64_t min, uint64_t max, uint64_t x);
struct approx_interval approx_linear_histo_value(uint64_t histo, uint64_t min, uint64_t max, approx_histo_bucket_t b);
void approx_linear_histo_to_string(uint64_t histo, OUT char *buf, size_t len, uint64_t min, uint64_t max);
uint64_t approx_exponential_histo_incr(uint64_t histo, uint8_t log_min, uint64_t x);
struct approx_interval approx_exponential_histo_value(uint64_t histo, uint8_t log_min, approx_histo_bucket_t b);
void approx_exponential_histo_to_string(uint64_t histo, OUT char *buf, size_t len, uint8_t log_min);
typedef uint8_t uint6_t;
uint6_t approx_counter_incr(uint6_t);
uint64_t approx_counter_value(uint6_t);
uint64_t approx_histo_add(uint64_t histo1, uint64_t histo2);

--------------

utils/common/base64.h: 

int base64_encode(char *dest, size_t size, unsigned const char *src, size_t slen);
int base64_decode(unsigned char *dest, size_t size, const char *src);
int base64_decode_sized(unsigned char *dest, size_t dsize, const char *src, size_t ssize);
size_t base64_encsize(size_t);

--------------

utils/common/bitmap.h: 

struct bitmap;
typedef uint32_t bitmap_index_t;
size_t bitmap_alloc_size(bitmap_index_t nbits);
void bitmap_init(struct bitmap *,bitmap_index_t nbits);
void bitmap_finish_initialization(struct bitmap *,bitmap_index_t nbits);
bitmap_index_t bitmap_nbits(const struct bitmap *);
bitmap_index_t bitmap_nbits_available(const struct bitmap *);
bitmap_index_t bitmap_nbits_in_use(const struct bitmap *);
bool bitmap_is_full(const struct bitmap *);
bool bitmap_is_empty(const struct bitmap *);
typedef bool(*bitmap_predicate_f)(void *context, bitmap_index_t bit);
bool bitmap_is_available(const struct bitmap *,bitmap_index_t bit);
bool bitmap_find_available(struct bitmap *,OUT bitmap_index_t *bit);
void bitmap_mark_available(struct bitmap *,bitmap_index_t bit);
void bitmap_mark_available_if_in_use(struct bitmap *,bitmap_index_t bit);
bool bitmap_mark_in_use_if_available(struct bitmap *,bitmap_index_t bit);
bool bitmap_iterate(const struct bitmap *,INOUT bitmap_index_t *start, OUT bitmap_index_t *next);
bool bitmap_find_available_cond_mark_in_use(struct bitmap *,uint32_t scan_start_bit, uint32_t scan_end_bit, bitmap_predicate_f match_func, void *context, bitmap_index_t *bit);
void bitmap_dump(const struct bitmap *);
struct range_bitmap;
struct range_bitmap {uint16_t size; uint16_t alloc_hint; uint32_t freecount; uint8_t map[0];};
size_t range_bitmap_alloc_size(bitmap_index_t nbits);
struct range_bitmap *range_bitmap_init(struct range_bitmap *mem, bitmap_index_t nbits);
bool range_bitmap_find_and_alloc(struct range_bitmap *,bitmap_index_t count, unsigned int align, OUT bitmap_index_t *rstart);
void range_bitmap_free(struct range_bitmap *,bitmap_index_t start, bitmap_index_t count);
bool range_bitmap_is_available(const struct range_bitmap *,bitmap_index_t start, bitmap_index_t count);
bool range_bitmap_mark_in_use_if_available(struct range_bitmap *,bitmap_index_t start, bitmap_index_t count);
struct bitmap {unsigned int bm_mem_size8; bitmap_index_t bm_nbits; bitmap_index_t bm_nbits_available; unsigned int bm_mem_off8; uint64_t bm_mem[0];};
FUN_DEPRECATED enum fun_ret bitmap_bget(struct bitmap *bm, bitmap_index_t *bit);
FUN_DEPRECATED enum fun_ret bitmap_bget_avail(struct bitmap *bm, bitmap_index_t bit);
FUN_DEPRECATED enum fun_ret bitmap_bput(struct bitmap *bm, bitmap_index_t bit);
FUN_DEPRECATED enum fun_ret bitmap_bget_cond(struct bitmap *bm, uint32_t scan_start_bit, uint32_t scan_end_bit, bitmap_predicate_f match_func, void *context, OUT bitmap_index_t *bit);
FUN_DEPRECATED enum fun_ret range_bitmap_alloc(struct range_bitmap *,bitmap_index_t count, unsigned int align, OUT bitmap_index_t *rstart);
FUN_DEPRECATED enum fun_ret range_bitmap_bget(struct range_bitmap *rbitmap, bitmap_index_t start, bitmap_index_t count);

--------------

utils/common/cksum.h: 

union l_util {uint16_t s[2];uint32_t l;};
union q_util {uint16_t s[4];uint32_t l[2];uint64_t q;};
uint64_t in_cksumdata(const uint32_t *lw, int len);
uint16_t cksum(const void *ip, int len);

--------------

utils/common/crc.h: 

uint32_t crc32(uint32_t crc, const void *,size_t);
uint32_t crc32_swapped(uint32_t crc, const void *,size_t);
uint32_t crc32_dma_swapped(uint32_t crc, const void *,size_t);
uint32_t crc32c(uint32_t crc, const void *,size_t);
uint32_t crc32c_swapped(uint32_t crc, const void *,size_t);
uint16_t crc16(uint16_t crc, const void *,size_t);
uint16_t crc16_t10(uint16_t crc, const void *buf, size_t len);
uint16_t crc16_t10_swapped(uint16_t crc, const void *buf, size_t len);
uint16_t crc16_ccitt(uint16_t crc, const void *buffer, size_t len);
uint8_t crc5(uint8_t crc, const void *,size_t);
uint8_t crc5_f1(uint8_t crc, const void *,size_t);
uint64_t crc64(uint64_t crc, uint64_t poly, uint8_t const buffer[],size_t len);
uint64_t crc64_swapped(uint64_t crc, uint64_t poly, uint8_t const buffer[],size_t len);
uint32_t crc16_cksum(uint64_t seed, const void *data, uint16_t num_bytes);

--------------

utils/common/dbgrand.h: 

extern uint64_t dbgrand_seed;
void dbgrand_bootstrap(uint64_t boot_seed);
void dbgrand_vp_bootstrap(void);

--------------

utils/common/debug_utils.h: 

void print_trace(void);
void platform_debug_break(void);
extern uint64_t bootcmd_flags;
void wu_log(const char *fmt, ...);
struct nvme_tracing {int dbid; int prob;};
void poison(bool non_coh, void *ptr, size_t size, struct stack_frame caller);
void poison_multiple(bool non_coh, void **ptrs, uint32_t num, size_t size, struct stack_frame caller);

--------------

utils/common/enum_def.h: 


--------------

utils/common/ftr.h: 

typedef uint64_t ftr_param_t;
enum ftr_log_severity {FTR_EMERG =(1<<0),FTR_ALERT =(1<<1),FTR_CRIT =(1<<2),FTR_ERR =(1<<3),FTR_WARNING =(1<<4),FTR_NOTICE =(1<<5),FTR_INFO =(1<<6),FTR_DEBUG =(1<<7)};
struct ftr_entry {fun_time_t ftre_tsc; const char *ftre_fmt; ftr_param_t ftre_param[FTR_NUM_PARAM];};
static_assert(sizeof(struct ftr_entry)<=sizeof(struct cache_line),"FTR entry exceeds cacheline size");
enum {FTR_TRIGGER_STATE_TRACING, FTR_TRIGGER_STATE_TRIGGERED, FTR_TRIGGER_STATE_FROZEN};
struct ftr_buf_archive {TAILQ_HEAD(,ftr_buf)ftr_buf_head;};
struct ftr_buf {const char *ftrb_name; struct fun_props_bridge *ftrb_bridge; TAILQ_ENTRY(ftr_buf)ftrb_archive_entry; uint64_t ftrb_archive_cookie; faddr_t ftrb_owner; unsigned int ftrb_idx_mask; unsigned int ftrb_idx; unsigned int ftrb_freeze_idx; unsigned int ftrb_trigger_idx; uint8_t ftrb_trigger_state; uint16_t ftrb_filter; struct ftr_entry ftrb_entries[0]__attribute__((aligned(64)));};
static_assert(sizeof(struct ftr_buf)<=sizeof(struct cache_line),"FTR buf exceeds cacheline size");
NULLABLE CALLER_TO_RELEASE struct fun_json *ftr_buf_to_json(struct ftr_buf *);
void ftr_buf_dump(struct ftr_buf *);
void ftr_buf_dump_no_wdt(struct ftr_buf *);
void ftr_buf_init(struct ftr_buf *,const char *,unsigned int, faddr_t);
void ftr_buf_alloc_push(struct channel *,const char *,unsigned int, struct ftr_buf **);
NULLABLE struct ftr_buf *ftr_buf_alloc_forever(const char *,unsigned int);
NULLABLE struct ftr_buf *ftr_buf_alloc_threaded(const char *,unsigned int);
void ftr_buf_free_push(struct channel *,struct ftr_buf *);
void ftr_buf_free_threaded(struct ftr_buf *);
void ftr_buf_bridge_install_push(struct channel *,struct ftr_buf *,const char *);
void ftr_buf_bridge_uninstall_push(struct channel *,struct ftr_buf *);
NULLABLE struct ftr_entry *ftr_buf_peek_last_entry(struct ftr_buf *,char *,size_t);
void ftr_buf_set_filter_mask(struct ftr_buf *,uint8_t, uint8_t);
void ftr_buf_set_owner(struct ftr_buf *,faddr_t);
void ftr_buf_trigger(struct ftr_buf *,uint8_t, bool);
bool ftr_buf_is_triggered(struct ftr_buf *);
void ftr_buf_trigger_reset(struct ftr_buf *);
void ftr_buf_reset(struct ftr_buf *ftr);
void ftr_buf_archive_init(struct ftr_buf_archive *);
void ftr_buf_archive_insert(struct ftr_buf_archive *,struct ftr_buf *,uint64_t);
void ftr_buf_archive_remove(struct ftr_buf_archive *,struct ftr_buf *);
bool ftr_buf_archive_empty(struct ftr_buf_archive *);
NULLABLE struct ftr_buf *
ftr_buf_archive_search_cookie(struct ftr_buf_archive *,uint64_t);
uint64_t ftr_buf_get_archive_cookie(struct ftr_buf *);
void ftr_buf_start_and_count(struct ftr_buf *,OUT unsigned int *start, OUT unsigned int *count);
size_t ftr_buf_size_for_nentries(unsigned int nentries);

--------------

utils/common/fun_json_arg.h: 

bool fun_json_arg_exists(NULLABLE const struct fun_json *,const char *key);
bool fun_json_arg_value_string(NULLABLE const struct fun_json *,const char *cmdname, OUT const char **value);
bool fun_json_arg_key_exists(NULLABLE const struct fun_json *,const char *key);
bool fun_json_arg_value_uint(NULLABLE const struct fun_json *,const char *key, OUT uint64_t *);
uint64_t fun_json_arg_value_uint_default(NULLABLE const struct fun_json *,const char *cmdname, uint64_t dflt);
const char *fun_json_arg_value_string_default(NULLABLE const struct fun_json *,const char *key, const char *dflt);

--------------

utils/common/fun_map.h: 

struct fun_map;
typedef uintptr_t fun_map_key_t;
typedef uintptr_t fun_map_value_t;
typedef uint32_t fun_map_count_t;
typedef NULLABLE void *fun_map_context_t;
typedef uint64_t(*fun_map_hash_f)(fun_map_context_t, fun_map_key_t);
typedef bool(*fun_map_is_equal_f)(fun_map_context_t, fun_map_key_t, fun_map_key_t);
typedef int(*fun_map_compare_f)(fun_map_context_t, NULLABLE void *per_call, fun_map_key_t, fun_map_key_t);
typedef void(*fun_map_destroy_pair_f)(fun_map_context_t, fun_map_key_t, fun_map_value_t);
typedef uint8_t fun_map_callbacks_t;
fun_map_callbacks_t fun_map_register_callbacks(fun_map_hash_f h, fun_map_is_equal_f eq, fun_map_key_t outsider_key);
void fun_map_init(struct fun_map *,fun_map_context_t, fun_map_callbacks_t);
struct fun_map *fun_map_fixed_size(void *ptr, size_t size, fun_map_context_t, fun_map_callbacks_t cb);
size_t fun_map_memory_size_for_capacity(fun_map_count_t capa, uint8_t load_factor);
bool fun_map_contains(const struct fun_map *,fun_map_key_t);
fun_map_key_t fun_map_original(const struct fun_map *,fun_map_key_t, OUT fun_map_value_t *);
fun_map_value_t fun_map_get(const struct fun_map *,fun_map_key_t);
fun_map_count_t fun_map_count(const struct fun_map *);
fun_map_count_t fun_map_capacity(const struct fun_map *);
bool fun_map_is_fixed_size(const struct fun_map *);
fun_map_key_t fun_map_outsider_key(const struct fun_map *);
fun_map_context_t fun_map_context(const struct fun_map *);
uint64_t fun_map_iterator(const struct fun_map *);
bool fun_map_iterate(const struct fun_map *,INOUT uint64_t *opaque_iter, OUT fun_map_key_t *,OUT fun_map_value_t *);
typedef bool(*fun_map_each_f)(fun_map_context_t, NULLABLE void *per_call, fun_map_key_t, fun_map_value_t);
void fun_map_enumerate(const struct fun_map *,NULLABLE void *per_call, fun_map_each_f each);
bool fun_map_random_key_value(const struct fun_map *,OUT fun_map_key_t *,OUT fun_map_value_t *);
void fun_map_get_unsorted_keys(const struct fun_map *,INOUT fun_map_key_t *const keys);
void fun_map_get_sorted_keys(const struct fun_map *,INOUT fun_map_key_t *const keys, NULLABLE void *per_call, NULLABLE fun_map_compare_f);
void fun_map_get_sorted_keys_as_strings(const struct fun_map *map, INOUT const char *const *keys);
MUST_CHECK bool fun_map_should_grow_for(const struct fun_map *,fun_map_count_t wanted);
enum fun_map_add_return {fun_map_added =1, fun_map_no_need_to_add, fun_map_replaced, fun_map_cant_add};
MUST_CHECK enum fun_map_add_return fun_map_add_no_grow(struct fun_map *,fun_map_key_t k, fun_map_value_t, bool replace_ok);
bool fun_map_add_no_grow_multiple(struct fun_map *,fun_map_count_t, const fun_map_key_t *,fun_map_value_t *);
void fun_map_add_from_to_no_grow(const struct fun_map *source, struct fun_map *dest);
bool fun_map_remove(struct fun_map *,fun_map_key_t, NULLABLE OUT fun_map_key_t *,NULLABLE OUT fun_map_value_t *);
void fun_map_remove_all(struct fun_map *,NULLABLE fun_map_destroy_pair_f destroy);
typedef void *(*fun_map_calloc_f)(size_t);
typedef void(*fun_map_free_f)(void *,size_t);
bool fun_map_set_raw_capacity_with_callbacks(struct fun_map *map, fun_map_count_t new_capa, fun_map_calloc_f, fun_map_free_f);
enum fun_map_add_return fun_map_add_with_callbacks(struct fun_map *,fun_map_key_t, fun_map_value_t, bool replace_ok, fun_map_calloc_f, fun_map_free_f);
void fun_map_destroy_with_callback(NULLABLE struct fun_map *map, fun_map_destroy_pair_f destroy_each, fun_map_free_f);
bool fun_map_init_with_capacity(struct fun_map *,fun_map_context_t, fun_map_callbacks_t, fun_map_count_t wanted, fun_map_calloc_f callocf);
void fun_map_check_valid(const struct fun_map *);
void fun_map_dump_capacities(void);

--------------

utils/common/fun_math.h: 

int isnan(double);
int isinf(double);
double power10(int);
double sqrt(double);

--------------

utils/common/fun_misc.h: 

static inline size_t fragments_total_size(const struct fun_ptr_and_size *fragments, size_t num_fragments)
 {size_t sum =0; while(num_fragments--){sum +=(fragments++)->size;}return sum;
}
typedef bool(*binary_search_is_acceptable_f)(void *context, int index);
int binary_search_find_smallest_acceptable(int min, int max, void *context, bool verbose, binary_search_is_acceptable_f);
int fibonacci(int);
bool parse_macaddr_str(const char *macaddr_str, uint8_t *macaddr);

--------------

utils/common/fun_qsort_r.h: 


--------------

utils/common/fun_set.h: 

struct fun_set;
typedef NULLABLE void *fun_set_context_t;
typedef uint64_t(*fun_set_hash_f)(fun_set_context_t, uintptr_t);
typedef bool(*fun_set_is_equal_f)(fun_set_context_t, uintptr_t, uintptr_t);
typedef int(*fun_set_compare_f)(fun_set_context_t, NULLABLE void *per_call, uintptr_t, uintptr_t);
typedef void(*fun_set_destroy_item_f)(fun_set_context_t, uintptr_t);
typedef uint8_t fun_set_callbacks_t;
typedef uint32_t fun_set_count_t;
fun_set_callbacks_t fun_set_register_callbacks(fun_set_hash_f h, fun_set_is_equal_f eq, uintptr_t outsider);
void fun_set_init(struct fun_set *,fun_set_context_t, fun_set_callbacks_t);
struct fun_set *fun_set_fixed_size(void *m, size_t s, fun_set_context_t, fun_set_callbacks_t);
size_t fun_set_memory_size_for_capacity(fun_set_count_t capa, uint8_t load_factor);
uint64_t fun_set_string_hash(fun_set_context_t, uintptr_t);
bool fun_set_string_is_equal(fun_set_context_t, uintptr_t, uintptr_t);
bool fun_set_contains(const struct fun_set *,uintptr_t);
uintptr_t fun_set_original(const struct fun_set *,uintptr_t);
fun_set_count_t fun_set_count(const struct fun_set *);
fun_set_count_t fun_set_capacity(const struct fun_set *);
typedef bool(*fun_set_each_f)(fun_set_context_t, NULLABLE void *per_call, uintptr_t);
void fun_set_enumerate(const struct fun_set *,NULLABLE void *per_call, fun_set_each_f);
uint64_t fun_set_iterator(const struct fun_set *);
bool fun_set_iterate(const struct fun_set *,INOUT uint64_t *opaque_iter, OUT uintptr_t *);
uintptr_t fun_set_any(const struct fun_set *);
void fun_set_sorted_items(const struct fun_set *,INOUT uintptr_t *,NULLABLE void *per_call, NULLABLE fun_set_compare_f);
MUST_CHECK bool fun_set_should_grow_for(const struct fun_set *set, fun_set_count_t wanted);
enum fun_set_add_return {fun_set_added =1, fun_set_no_need_to_add, fun_set_cant_add};
MUST_CHECK enum fun_set_add_return fun_set_add_no_grow(struct fun_set *,uintptr_t);
bool fun_set_remove(struct fun_set *,uintptr_t);
bool fun_set_remove_and_original(struct fun_set *,uintptr_t, OUT uintptr_t *original);
void fun_set_remove_all(struct fun_set *,NULLABLE fun_set_destroy_item_f);
typedef void *(*fun_set_alloc_f)(size_t);
typedef void(*fun_set_free_f)(void *,size_t);
MUST_CHECK bool fun_set_set_capacity_with_callbacks(struct fun_set *,fun_set_count_t, fun_set_alloc_f, fun_set_free_f);
MUST_CHECK enum fun_set_add_return fun_set_add_with_callbacks(struct fun_set *,uintptr_t, fun_set_alloc_f, fun_set_free_f);
MUST_CHECK enum fun_set_add_return fun_set_add_multiple_with_callbacks(struct fun_set *set, const uintptr_t *items, fun_set_count_t num, fun_set_alloc_f alloc_cb, fun_set_free_f free_cb, OUT fun_set_count_t *num_added);
MUST_CHECK enum fun_set_add_return fun_set_union_in_place_with_callbacks(struct fun_set *,const struct fun_set *other, fun_set_alloc_f, fun_set_free_f, OUT fun_set_count_t *num_added);
void fun_set_destroy_with_callback(NULLABLE struct fun_set *set, NULLABLE fun_set_destroy_item_f destroy_each, fun_set_free_f);

--------------

utils/common/fun_strerror.h: 

const char *fun_strerror_r(enum fun_ret ret, char *buf, int len);
const char *fun_strerror(enum fun_ret ret);

--------------

utils/common/fun_vector.h: 

uint64_t fun_vector_min(const uint64_t *,uint32_t n, OUT uint32_t *best);
uint64_t fun_vector_max(const uint64_t *,uint32_t n, OUT uint32_t *best);
void fun_vector_add_in_place(uint64_t *dest, uint32_t n, const int64_t *source);
uint64_t fun_vector_sum(const uint64_t *,uint32_t n);
void fun_vector_and_in_place(uint64_t *,uint32_t n, const uint64_t *);
void fun_vector_or_in_place(uint64_t *,uint32_t n, const uint64_t *);
bool fun_vector_find(const uint64_t *,uint32_t n, uint64_t x, OUT uint32_t *index);
bool fun_vector_is_equal(const uint64_t *,const uint64_t *,uint32_t n);
bool fun_vector_all_same_value(const uint64_t *,uint32_t n, uint64_t value);
uint64_t fun_vector_popcount(const uint64_t *,uint32_t n);
void fun_vector_set(uint64_t *,uint32_t n, uint64_t pattern);

--------------

utils/common/fw_upgrade.h: 

struct channel;
void fw_upgrade_do_upgrade_push(struct channel *channel, uint32_t type, uint64_t mem_start, uint64_t mem_size, uint32_t *res, bool active_image, bool downgrade);
void fw_upgrade_do_upgrade_progress_push(struct channel *channel, uint32_t type, uint64_t mem_size, uint32_t *progress, uint32_t *result);
bool fw_upgrade_have_async_progress(uint32_t type);

--------------

utils/common/hw_workaround.h: 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

--------------

utils/common/int_utils.h: 

static inline uint8_t power_of_2_ge(uint64_t input)
{if(unlikely(input ==0)){return 0;}else if(unlikely((input &(input -1))==0)){return __builtin_ctzll(input);}else{return 64-__builtin_clzll(input);}
}
static inline uint8_t fun_log2(uint64_t size_pow2)
{assert(IS_POWER_OF_2(size_pow2));return __builtin_ctzll(size_pow2);
}
static inline uint64_t get_nchunks(uint64_t x, uint64_t y)
{return(x +y -1)/y;
}
static inline uint32_t hash_64b_to_32b(uint64_t x)
{uint32_t high =x >>32; uint32_t low =(x *2654435761)>>32; return high ^low;
}
static inline uint32_t reciprocal_scale(uint32_t val, uint32_t ep_ro)
{return(uint32_t)(((uint64_t)val *ep_ro)>>32);
}

--------------

utils/common/lock_utils.h: 

typedef volatile int fun_once_state_t;
void fun_once(INOUT fun_once_state_t *private_state, void *context, void(*fun)(void *));
void fun_increment_refcount(INOUT uint32_t *extra_refcount);
bool fun_decrement_refcount(INOUT uint32_t *extra_refcount);

--------------

utils/common/macros.h: 

extern const char *bytes_units[];

--------------

utils/common/mask_accessor.h: 


--------------

utils/common/modcfg.h: 

union modcfg_val {bool bool_val; uint8_t uint8_val; uint16_t uint16_val; uint32_t uint32_val; uint64_t uint64_val; int64_t int64_val; struct fun_json *json_val;};
union modcfg_ptrs {bool *bool_ptr; uint8_t *uint8_ptr; uint16_t *uint16_ptr; uint32_t *uint32_ptr; uint64_t *uint64_ptr; int64_t *int64_ptr; struct fun_json **json_ptr;};
enum modcfg_type {modcfg_type_bool, modcfg_type_int64, modcfg_type_uint8, modcfg_type_uint16, modcfg_type_uint32, modcfg_type_uint64, modcfg_type_json,};
enum modcfg_state {modcfg_state_uninit, modcfg_state_default, modcfg_state_modified,};
struct modcfg_entry;
typedef bool(*modcfg_validate_t)(struct modcfg_entry *ent, union modcfg_ptrs value);
typedef void(*modcfg_modified_t)(struct modcfg_entry *ent);
struct modcfg_entry {const char *name; const char *deprecated_name; const char *description; enum modcfg_state state; modcfg_validate_t validate_fn; modcfg_modified_t modified_fn; enum modcfg_type type; union modcfg_ptrs current; union modcfg_val min; union modcfg_val max; union modcfg_val dflt; struct fun_json *schema; const char *schema_str;};
void modcfg_register_dpc_cmds(void);
struct module;
void modcfg_reset_module(struct module *module);
extern uint32_t modcfg_test_int_callback_count;
extern uint32_t modcfg_test_update_count;

--------------

utils/common/mpht.h: 

struct mpht;
struct mpht_builder {struct mpht_item *items; struct mpht_bucket *buckets; size_t key_size; size_t len; size_t cap;};
int mpht_builder_init(struct mpht_builder *builder, size_t capacity, size_t key_size);
void mpht_builder_destroy(struct mpht_builder *builder);
int mpht_builder_add(struct mpht_builder *builder, const void *key, void *value);
struct mpht *mpht_new(struct mpht_builder *builder, int load);
void mpht_free(struct mpht *mpht);
void *mpht_lookup(const struct mpht *mpht, const void *key);

--------------

utils/common/opstats.h: 

struct opperf {fun_time_t start; fun_time_t end; uint64_t count; uint64_t bytes; uint64_t histo[OPSTATS_HISTO_MAX_BUCKETS];uint64_t histo_rem; fun_time_t min_latency; fun_time_t max_latency; fun_time_t total_latency;};
struct opperf_stats {uint64_t done_count; uint64_t min_latency; uint64_t avg_latency; uint64_t max_latency; uint64_t iops; uint64_t avg_bw_kbps; uint64_t bytes; uint64_t histo[OPSTATS_HISTO_MAX_BUCKETS];uint64_t histo_rem; };
static_assert((sizeof(struct opperf_stats)&(sizeof(uint64_t)-1))==0,"opperf_stats size should be a multiple of sizeof(uint64_t)");
static_assert((sizeof(struct opperf_stats)&(sizeof(uint64_t)-1))==0,"opperf_stats size should be a multiple of sizeof(uint64_t)");
void
opperf_init(struct opperf *perf);
void
opperf_add(struct opperf *perf, fun_time_t start, fun_time_t latency, uint32_t bytes);
void
opperf_summary(struct opperf *perf, const char *name);
void
opperf_summary_with_log_level(struct opperf *perf, const char *name, uint8_t level);
CALLER_TO_RELEASE struct fun_json*
opperf_summary_json(struct opperf *perf, const char *name);
void opstats_add_vp_info_to_json(faddr_t vp, const char *key, struct fun_json *json);
void
opperf_summarize_stats(struct opperf *perf, struct opperf_stats *stats);
struct opstats_noperf {fun_time_t start;};
struct opstats {fun_time_t start; struct opperf *perf;};
void opstats_init(struct opstats *stats, struct opperf *perf);
void opstats_startop(struct opstats *stats);
void opstats_endop(struct opstats *stats, uint32_t bytes);
void opstats_noperf_startop(struct opstats_noperf *stats);
void opstats_noperf_endop(struct opstats_noperf *stats, uint32_t bytes, struct opperf *perf);
void
opstats_start(struct opstats *stats, struct opperf *perf);
void
opperf_accumulate_stats(struct opperf_stats *acc_stats, struct opperf_stats *stats);
void
opperf_accumulate(struct opperf *acc_perf, struct opperf *perf);
void
opperf_print_stats(struct opperf_stats *stats, const char *name);
void
opperf_print_stats_with_level(struct opperf_stats *stats, const char *name, uint8_t level);

--------------

utils/common/queue.h: 

struct qm_trace {unsigned long lastline; unsigned long prevline; const char *lastfile; const char *prevfile;};

--------------

utils/common/ratelimit.h: 

struct ratelimit_global_once {bool done;};
bool ratelimit_global_once(struct ratelimit_global_once *);
struct ratelimit_global {spinlock_t lock; uint32_t count; uint32_t maxcount; fun_time_t period_len; fun_time_t period_start;};
enum ratelimit_check {RATELIMIT_CHECK_FIRST, RATELIMIT_CHECK_OK, RATELIMIT_CHECK_LAST, RATELIMIT_CHECK_DROP,};
enum ratelimit_check ratelimit_global_check(struct ratelimit_global *);
uint64_t ratelimit_global_period_remain(struct ratelimit_global *);

--------------

utils/common/string_utils.h: 

uint64_t fun_string_hash_with_length(const char *string, size_t len);
uint64_t fun_string_hash(const char *string);
uint64_t djb2_hash(unsigned char *string, size_t len);
int fun_string_first_prefix_match(const char *const *prefixes, int num_prefixes, const char *string);
bool pattern_match(const char *pattern, const char *candidate);
bool pattern_with_length_match(const char *pattern, size_t plen, const char *candidate);
bool pattern_match_ignore_case(const char *pattern, const char *candidate);
bool pattern_contains_meta_characters(const char *pattern);
bool pattern_with_length_contains_meta_characters(const char *pattern, size_t plen);
bool hex_to_nibble(char hex, OUT uint8_t *nibble);
bool hex_string_to_byte_array(const char *str, struct fun_ptr_and_size output, int str_len);
void _hex_dump(const void *buf, size_t size, const char *msg, size_t row_sz, size_t groupsize);
void byte_to_hex2(const uint8_t byte, OUT char *str);
void bytes2_to_hex4(const uint8_t *bytes, OUT char *str);
void bytes4_to_hex8(const uint8_t *bytes, OUT char *str);
void bytes6_to_hex12(const uint8_t *bytes, OUT char *str);
bool ipv4_address_scan(const char *string, OUT uint32_t *ip);
bool mac_address_scan(const char *string, OUT uint8_t mac[6]);
int string_to_index(const char *string, const char *const str_array[],uint32_t max);
size_t tally_strlen(size_t max, size_t so_far, size_t len_whbp);
uint32_t parse_string_as_uints(const char *string, OUT uint32_t vals[],uint32_t num_vals, uint32_t max_val);
uint64_t parse_size(const char *string, uint64_t default_when_failed);
int linear_time_memmatch(const void *s1, const void *s2, size_t n);
FUN_DEPRECATED bool str_to_byte_array(const char *str, struct fun_ptr_and_size output, int str_len);
FUN_DEPRECATED int str_to_enum(const char *str, const char *const str_array[],uint32_t max);
FUN_DEPRECATED NULLABLE char *strncasestr(const char *haystack, size_t hlen, const char *needle);

--------------

utils/common/syslog.h: 

enum syslog_severity {EMERG =0x0, ALERT =0x1, CRIT =0x2, ERR =0x3, WARNING =0x4, NOTICE =0x5, INFO =0x6, DEBUG =0x7, SYSLOG_MAX =0x8};
extern enum syslog_severity syslog_print_level;
typedef struct {const char *c_file; uint32_t c_line; const char *c_func; const char *c_fmt;}syslog_const_args_t;
 
 
struct hu_fn_flow;
void syslog(NULLABLE const struct flow *,enum syslog_severity, const struct module *module, const syslog_const_args_t *cargs, const char *fmt, ...);
static inline void __attribute__((format(printf, 1, 2)))
syslog_format_printf_checker(const char *fmt, ...)
 {}
void syslog_hex_dump(enum syslog_severity severity, const void *data, size_t size, const char *str);
void set_syslog_level(enum syslog_severity);
enum syslog_severity get_syslog_level(void);
int syslog_name_to_level(const char *level_name);
extern bool syslog_nocolor;
extern bool syslog_noratelimit;

--------------

utils/common/tbitmap.h: 

struct tbitmap_blk {uint64_t dwds[TBITMAP_DWORDS_PER_BLK];};
struct tbitmap {int num_levels; uint32_t level_offset[TBITMAP_MAX_LEVELS];uint32_t tree_base[2];struct tbitmap_blk *blks;};
size_t tbitmap_calc_size(uint32_t num_bits, uint32_t flags);
void tbitmap_init(struct tbitmap *tbm, void *mem, uint32_t num_bits, uint32_t flags, bool value);
void tbitmap_set_bit(struct tbitmap *tbm, uint32_t idx);
void tbitmap_clear_bit(struct tbitmap *tbm, uint32_t idx);
bool tbitmap_get_bit(struct tbitmap *tbm, uint32_t idx);
uint32_t tbitmap_find_first_clear(struct tbitmap *tbm);
uint32_t tbitmap_find_next_clear(struct tbitmap *tbm, uint32_t idx);
uint32_t tbitmap_find_first_set(struct tbitmap *tbm);
uint32_t tbitmap_find_next_set(struct tbitmap *tbm, uint32_t idx);

--------------

utils/common/toeplitz.h: 

uint32_t toeplitz_hash(const void *key, size_t keylen, const void *buf, size_t buflen, uint32_t seed);

--------------

utils/common/unique_string.h: 

NULLABLE const char *unique_string(const char *);
NULLABLE const char *try_unique_string(const char *);

--------------

utils/common/uuid.h: 

typedef struct fun_uuid {uint8_t uuid_bytes[UUID_LEN];}ALIGNED(8)fun_uuid_t;
void uuid_to_string(const fun_uuid_t, OUT char *string);
bool uuid_from_string(OUT NULLABLE fun_uuid_t *uuid_ptr, const char *string);
bool uuid_from_string16(OUT fun_uuid_t *,const char *);
fun_uuid_t uuid_random(void);
static inline fun_uuid_t uuid_null(void){fun_uuid_t uuid ={0};return uuid;
}
bool uuid_is_null(const fun_uuid_t);
bool uuid_compare(const fun_uuid_t, const fun_uuid_t);
uint64_t uuid_hash(const fun_uuid_t);
fun_map_callbacks_t fun_map_uuid_callbacks(void);
struct _uuid_string {char chars[UUID_STR_LEN];};
static inline struct _uuid_string _uuid_to_string(const fun_uuid_t u)
 {struct _uuid_string result; uuid_to_string(u, result.chars);return result;}
fun_uuid_t _uuid_from_bytes(UUID_AS_WU_PARAM_T);

--------------

utils/common/wsdepth.h: 

enum wsdepth_tag {WSDEPTH_TAGS(GEN_WSDTAG_TYPE_ENUM)};
struct frame;
void wsdepth_record_stack(enum wsdepth_tag tag, size_t depth, struct frame *base);
void wsdepth_log_report(void);
void wsdepth_log_tag(enum wsdepth_tag tag);
const char *wsdepth_tag_name(enum wsdepth_tag tag);

--------------

utils/common/xdata.h: 

bool xdata_get_file_info(void *xd, const char *file_name, OUT uint64_t *file_start, OUT size_t *file_size);
bool xdata_get_file(const char *file_name, OUT void **file_start_ptr, OUT size_t *file_size);
typedef bool(*xdata_enumerator_t)(void *cookie, const char *file_name, void *file_start, size_t file_size);
int xdata_enumerate(xdata_enumerator_t func, void *cookie);

--------------

utils/threaded/approx_histo_json.h: 

CALLER_TO_RELEASE NULLABLE struct fun_json *approx_linear_histo_to_json(uint64_t histo, uint64_t min, uint64_t max);
CALLER_TO_RELEASE NULLABLE struct fun_json *approx_exponential_histo_to_json(uint64_t histo, uint8_t log_min);

--------------

utils/threaded/csr_utils.h: 

int csr_read_words(uint64_t csr_addr, size_t num_words, OUT uint64_t *,void *reader);
int csr_write_words(uint64_t csr_addr, size_t num_words, uint64_t *,void *writer);
struct csr_spec_parts {const char *name; size_t instance_plus1; size_t index_plus1; NULLABLE const char *an_name; NULLABLE const char *an_path; size_t an_instance_plus1; NULLABLE const char *ring_name; size_t ring_instance_plus1; const char *field;};
bool csr_spec_to_parts(const struct fun_json *spec, OUT struct csr_spec_parts *parts, OUT struct fun_json **error);
struct csr_raw_spec {uint64_t addr; size_t num_words; uint16_t field_num_bits; uint16_t field_start;};
bool csr_metadata_lookup(const struct fun_json *metadata_db, const struct fun_json *spec, OUT struct csr_raw_spec *result, OUT struct fun_json **error);
void csr_append_matching_entries(const struct fun_json *entries, const struct csr_spec_parts *parts, struct fun_json *matches);
CALLER_TO_RELEASE struct fun_json *csr_raw_generate_peek_arguments(const struct csr_raw_spec *);
CALLER_TO_RELEASE struct fun_json *csr_raw_generate_poke_arguments(const struct csr_raw_spec *,FUN_JSON_XFER struct fun_json *value);
size_t word_buffer_shift_left_in_place(uint64_t *buffer, size_t num_words, size_t bit_offset);
size_t word_buffer_trim_in_place(uint64_t *buffer, size_t num_words, size_t bit_width);
void word_buffer_merge_in_place(uint64_t *buffer, size_t num_words, const uint64_t *new_words, size_t bit_width, size_t bit_offset);
bool word_buffer_fill(const struct fun_json *,OUT uint64_t *buffer, OUT struct fun_json **error);
bool fun_json_lookup_number_in_string(const struct fun_json *dict, const char *key, NULLABLE OUT uint64_t *value);

--------------

utils/threaded/fun_heap.h: 

typedef NULLABLE void *fun_heap_context_t;
typedef int(*fun_heap_compare_f)(fun_heap_context_t, const uintptr_t left, const uintptr_t right);
typedef void(*fun_heap_destroy_item_f)(fun_heap_context_t, uintptr_t);
NULLABLE struct fun_heap *fun_heap(fun_heap_context_t, NULLABLE fun_heap_compare_f, uintptr_t outsider);
uintptr_t fun_heap_minimum(const struct fun_heap *);
size_t fun_heap_count(const struct fun_heap *);
typedef bool(*fun_heap_each_f)(fun_heap_context_t, NULLABLE void *per_call, uintptr_t);
void fun_heap_enumerate(const struct fun_heap *,NULLABLE void *per_call, fun_heap_each_f);
void fun_heap_enumerate_sorted(const struct fun_heap *,NULLABLE void *per_call, fun_heap_each_f);
bool fun_heap_set_capacity(struct fun_heap *,size_t);
bool fun_heap_add(struct fun_heap *,uintptr_t);
uintptr_t fun_heap_remove_minimum(struct fun_heap *);
void fun_heap_remove_all(struct fun_heap *,NULLABLE fun_heap_destroy_item_f);
void fun_heap_destroy(struct fun_heap *,NULLABLE fun_heap_destroy_item_f);

--------------

utils/threaded/fun_json.h: 

struct fun_json;
typedef uint32_t fun_json_index_t;
struct fun_set;
typedef enum fun_json_ownership {fun_json_copy, fun_json_xfer, fun_json_no_copy_no_own}fun_json_ownership_t;
typedef bool(*fun_json_predicate_f)(NULLABLE void *context, const struct fun_json *);
enum fun_json_reduce_op {fun_json_reduce_count, fun_json_reduce_sum, fun_json_reduce_min, fun_json_reduce_max,};
struct fun_json_reduce_state {enum fun_json_reduce_op op; NULLABLE void *context_for_predicate; NULLABLE fun_json_predicate_f predicate; int64_t current;};
typedef int(*fun_json_array_compare_f)(void *context, const struct fun_json *left, const struct fun_json *right);
CALLER_TO_RELEASE struct fun_json *fun_json_create_from_text(const char *text);
CALLER_TO_RELEASE struct fun_json *fun_json_create_from_text_with_status(const char *text, OUT bool *parsed_all);
CALLER_TO_RELEASE struct fun_json *fun_json_create_from_text_with_options(const char *text, size_t text_length, uint32_t flags, NULLABLE INOUT uint32_t *line, NULLABLE OUT size_t *length_parsed);
CALLER_TO_RELEASE struct fun_json *fun_json_deserialize(const struct fun_ptr_and_size);
CALLER_TO_RELEASE struct fun_json *fun_json_create_from_binary(const uint8_t *,size_t);
CALLER_TO_RELEASE struct fun_json *fun_json_create_from_binary_with_options(const uint8_t *,size_t, bool allow_json_errors_in_the_tree);
CALLER_TO_RELEASE struct fun_json *fun_json_create_null(void);
CALLER_TO_RELEASE struct fun_json *fun_json_create_bool(bool);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_int64(int64_t);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_uint64(uint64_t);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_double(double);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_string(const char *utf8_string, fun_json_ownership_t own);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_string_with_length(const char *utf8_string, size_t len, fun_json_ownership_t);
CALLER_TO_RELEASE struct fun_json *fun_json_create_error(const char *message, fun_json_ownership_t);
CALLER_TO_RELEASE struct fun_json *fun_json_create_const_error(const char *message);
CALLER_TO_RELEASE struct fun_json *fun_json_create_errorf(const char *format, ...);
CALLER_TO_RELEASE struct fun_json *fun_json_create_error_for_arg_wrong_type(NULLABLE const struct fun_json *json, const char *expected_type);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_array(FUN_JSON_XFER struct fun_json **js, fun_json_index_t count);
static CALLER_TO_RELEASE NULLABLE inline struct fun_json *fun_json_create_empty_array(void)
 {return fun_json_create_array(NULL, 0);}
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_empty_array_with_capacity(fun_json_index_t);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_array_from_int64s(const int64_t *,fun_json_index_t count);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_byte_array(const uint8_t *b, fun_json_index_t count);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_array_from_uint64s(const uint64_t *,fun_json_index_t count);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_array_from_strings(const char *[],fun_json_ownership_t own, fun_json_index_t);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_array_from_pointers(void **ptrs, fun_json_index_t count, fun_json_index_t max);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_empty_dict(void);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_empty_dict_with_capacity(fun_json_index_t);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_dict(fun_json_index_t count, const char *const *keys, fun_json_ownership_t own, FUN_JSON_XFER struct fun_json **sub_values);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_dict_from_int64s(fun_json_index_t count, const char *const *keys, fun_json_ownership_t own, const int64_t *ints);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_dict_from_uint64s(fun_json_index_t count, const char *const *,fun_json_ownership_t, const uint64_t *);
CALLER_TO_RELEASE struct fun_json *fun_json_create_dict_from_non_zero_int64s(fun_json_index_t count, const char *const *keys, fun_json_ownership_t own, const int64_t *ints);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_dict_from_doubles(fun_json_index_t count, const char *const *keys, fun_json_ownership_t own, const double *doubles);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_dict_from_strings(fun_json_index_t count, const char *const *keys, fun_json_ownership_t kown, const char *const *values, fun_json_ownership_t vown);
NULLABLE CALLER_TO_FREE char *fun_json_to_text(const struct fun_json *);
NULLABLE CALLER_TO_FREE char *fun_json_to_text_oneline(const struct fun_json *,OUT size_t *allocated_size);
void fun_json_pretty_print_and_elide(NULLABLE const struct fun_json *,uint32_t flags, uint32_t max_depth, char *buf, size_t buf_size);
NULLABLE CALLER_TO_FREE char *fun_json_pretty_print(const struct fun_json *,uint32_t indent_level, const char *space_per_level, size_t max_line, uint32_t flags, OUT size_t *allocated_size);
void fun_json_printf(const char *format_with_1_percent_s, const struct fun_json *);
void fun_json_snprintf(char *,size_t, const char *format_with_1_percent_s, const struct fun_json *);
void fun_json_printf_with_flags(const char *format_with_1_percent_s, const struct fun_json *,uint32_t flags);
struct _fun_json_text_100 {char text[100];};
struct _fun_json_text_100 _fun_json_to_text_100(NULLABLE const struct fun_json *);
CALLER_TO_FREE struct fun_ptr_and_size fun_json_serialize(const struct fun_json *,OUT size_t *allocated_size);
bool fun_json_serialization_size_exceeds(const struct fun_json *,size_t);
size_t fun_json_binary_serialization_size(const uint8_t *,size_t num_bytes_that_can_be_safely_accessed);
size_t fun_json_binary_serialization_minimum_size(uint8_t first_byte);
const char *fun_json_get_type_string(NULLABLE const struct fun_json *);
bool fun_json_is_error_message(NULLABLE const struct fun_json *);
bool fun_json_fill_error_message(NULLABLE const struct fun_json *,NULLABLE OUT const char **str_ptr);
bool fun_json_is_null(NULLABLE const struct fun_json *);
bool fun_json_is_bool(NULLABLE const struct fun_json *);
bool fun_json_fill_bool(NULLABLE const struct fun_json *,NULLABLE OUT bool *bool_ptr);
bool fun_json_to_bool(NULLABLE const struct fun_json *,bool if_non_bool);
bool fun_json_is_int(NULLABLE const struct fun_json *);
bool fun_json_fill_int64(NULLABLE const struct fun_json *,NULLABLE OUT int64_t *int_ptr);
int64_t fun_json_to_int64(NULLABLE const struct fun_json *,int64_t if_non_int);
bool fun_json_fill_uint64(NULLABLE const struct fun_json *,NULLABLE OUT uint64_t *int_ptr);
uint64_t fun_json_to_uint64(NULLABLE const struct fun_json *,uint64_t if_non_int);
bool fun_json_fill_uint32(NULLABLE const struct fun_json *,NULLABLE OUT uint32_t *int_ptr);
bool fun_json_fill_uint16(NULLABLE const struct fun_json *json, NULLABLE OUT uint16_t *int_ptr);
bool fun_json_fill_uint8(NULLABLE const struct fun_json *json, NULLABLE OUT uint8_t *int_ptr);
bool fun_json_is_double(NULLABLE const struct fun_json *);
bool fun_json_fill_double(NULLABLE const struct fun_json *,NULLABLE OUT double *ptr);
double fun_json_to_double(NULLABLE const struct fun_json *,double if_non_double);
bool fun_json_fill_double_or_int(NULLABLE const struct fun_json *,NULLABLE OUT double *ptr);
bool fun_json_is_string(NULLABLE const struct fun_json *);
bool fun_json_fill_string(NULLABLE const struct fun_json *,NULLABLE OUT const char **ptr);
const char *fun_json_to_string(NULLABLE const struct fun_json *,const char *if_non_string);
bool fun_json_is_string_equal_to(NULLABLE const struct fun_json *,const char *candidate);
bool fun_json_is_array(NULLABLE const struct fun_json *);
fun_json_index_t fun_json_array_count(NULLABLE const struct fun_json *);
NULLABLE struct fun_json *fun_json_array_at(NULLABLE const struct fun_json *,fun_json_index_t i);
bool fun_json_is_byte_array(NULLABLE const struct fun_json *);
bool fun_json_is_array_of_strings(NULLABLE const struct fun_json *);
bool fun_json_fill_uint8_array(NULLABLE const struct fun_json *,OUT uint8_t *buffer, size_t size);
bool fun_json_is_dict(NULLABLE const struct fun_json *);
fun_json_index_t fun_json_dict_count(NULLABLE const struct fun_json *);
uint64_t fun_json_dict_iterator(NULLABLE const struct fun_json *);
bool fun_json_dict_iterate(NULLABLE const struct fun_json *,INOUT uint64_t *opaque_iter, OUT const char **key_ptr, OUT const struct fun_json **sub_ptr);
void fun_json_dict_fill_keys(const struct fun_json *,OUT const char *const *keys);
void fun_json_dict_fill_and_sort_keys(const struct fun_json *,OUT const char *const *keys);
typedef int(*fun_json_dict_compare_f)(NULLABLE void *,const char *,const char *);
void fun_json_dict_fill_and_sort_keys_with_comparator(const struct fun_json *,OUT const char *const *keys, NULLABLE void *,fun_json_dict_compare_f comparator);
NULLABLE struct fun_json *fun_json_dict_at(NULLABLE const struct fun_json *,const char *key);
bool fun_json_dict_add_keys_to_set(const struct fun_json *json, struct fun_set *set);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_dict_keys_matching_as_array(const struct fun_json *dict, const char *pattern);
bool fun_json_fill_time(NULLABLE struct fun_json *,NULLABLE OUT fun_time_t *ptr);
NULLABLE struct fun_json *MUST_CHECK fun_json_lookup(NULLABLE const struct fun_json *json, const char *key_path);
NULLABLE struct fun_json *MUST_CHECK fun_json_lookup_with_parsed_path(NULLABLE const struct fun_json *json, const struct fun_json_parsed_path *pp, fun_json_path_index_t start_index);
bool fun_json_lookup_int64(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT int64_t *value);
bool fun_json_lookup_double(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT double *value);
bool fun_json_lookup_double_or_int(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT double *value);
bool fun_json_lookup_duration(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT fun_time_t *);
bool fun_json_lookup_string(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT const char **value);
bool fun_json_lookup_bool(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT bool *value);
bool fun_json_lookup_uint64(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT uint64_t *value);
bool fun_json_lookup_uint32(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT uint32_t *value);
bool fun_json_lookup_int32(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT int32_t *value);
bool fun_json_lookup_uint16(NULLABLE const struct fun_json *,const char *key_path, NULLABLE OUT uint16_t *value);
bool fun_json_lookup_uint8(NULLABLE const struct fun_json *j, const char *key_path, NULLABLE OUT uint8_t *value);
bool fun_json_lookup_bool_default(NULLABLE const struct fun_json *json, const char *key_path, bool default_value);
bool fun_json_lookup_string_default(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT const char **value, const char *default_value);
bool fun_json_lookup_int64_default(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT int64_t *value, int64_t default_value);
bool fun_json_lookup_uint64_default(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT uint64_t *value, uint64_t default_value);
bool fun_json_lookup_uint32_default(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT uint32_t *value, uint32_t default_value);
bool fun_json_lookup_uint16_default(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT uint16_t *value, uint16_t default_value);
bool fun_json_lookup_uint8_default(NULLABLE const struct fun_json *json, const char *key_path, NULLABLE OUT uint8_t *value, uint8_t default_value);
bool fun_json_lookup_duration_default(NULLABLE const struct fun_json *j, const char *key_path, NULLABLE OUT fun_time_t *duration, fun_time_t default_val);
bool fun_json_find(const struct fun_json *,const char *pattern);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_find_and_narrow_and_retain(const struct fun_json *,const char *pattern, NULLABLE const char *key_path);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_find_and_narrow_and_retain_with_parsed_path(const struct fun_json *,const char *pattern, const struct fun_json_parsed_path *pp, fun_json_path_index_t start);
bool fun_json_subset_with_pattern_path(NULLABLE const struct fun_json *,const char *pattern_path, const char *key_path_prefix, struct fun_json *dict_results);
bool fun_json_subset_with_parsed_pattern_path(NULLABLE const struct fun_json *,const struct fun_json_parsed_path *,fun_json_path_index_t, const char *key_path_prefix, struct fun_json *dict_results);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_json_make_array_subset(const struct fun_json *array, fun_json_index_t from, fun_json_index_t to);
bool fun_json_is_equal(const struct fun_json *,const struct fun_json *);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_make_array_of_pairs_from_decreasing_values(const struct fun_json *);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_make_int_dictionary_by_add_mult(const struct fun_json *dict1, const struct fun_json *dict2, int64_t scale, bool remove_zeros);
bool fun_json_reduce_with_parsed_pattern_path(const struct fun_json *,const struct fun_json_parsed_path *pp, fun_json_path_index_t start_index, INOUT struct fun_json_reduce_state *state);
bool fun_json_array_append(struct fun_json *json_array, FUN_JSON_XFER struct fun_json *sub);
bool fun_json_array_append_int64(struct fun_json *json_array, int64_t i);
bool fun_json_array_append_int64s(struct fun_json *json_array, const int64_t *ints, fun_json_index_t n);
bool fun_json_array_append_string(struct fun_json *json_array, const char *str, fun_json_ownership_t own);
bool fun_json_array_add_other_array(struct fun_json *current, const struct fun_json *other);
bool fun_json_array_replace_at_index(NULLABLE struct fun_json *json_array, fun_json_index_t i, FUN_JSON_XFER struct fun_json *sub);
bool fun_json_array_replace_at_index_or_append(NULLABLE struct fun_json *json_array, fun_json_index_t i, FUN_JSON_XFER struct fun_json *sub);
void fun_json_array_trim_at(struct fun_json *json_array, fun_json_index_t);
void fun_json_array_sort_in_place(const struct fun_json *json_array, void *context, fun_json_array_compare_f);
bool fun_json_dict_add(struct fun_json *dict, const char *key, fun_json_ownership_t own, FUN_JSON_XFER struct fun_json *value, bool replace_ok);
bool fun_json_dict_add_int64(struct fun_json *dict, const char *key, fun_json_ownership_t own, int64_t value, bool replace_ok);
bool fun_json_dict_add_uint64(struct fun_json *dict, const char *key, fun_json_ownership_t own, uint64_t value, bool replace_ok);
bool fun_json_dict_add_int64s(struct fun_json *dict, const char *const *keys, fun_json_index_t num_keys, fun_json_ownership_t own, const int64_t *values, bool replace_ok);
static inline bool fun_json_dict_add_uint64s(struct fun_json *dict, const char *const *keys, fun_json_index_t num_keys, fun_json_ownership_t own, const uint64_t *values, bool replace_ok)
 {return fun_json_dict_add_int64s(dict, keys, num_keys, own,(const int64_t *)values, replace_ok);}
bool fun_json_dict_add_double(struct fun_json *dict, const char *key, fun_json_ownership_t own, double value, bool replace_ok);
bool fun_json_dict_add_bool(struct fun_json *dict, const char *key, fun_json_ownership_t own, bool value, bool replace_ok);
bool fun_json_dict_add_string(struct fun_json *dict, const char *key, fun_json_ownership_t own, const char *value, fun_json_ownership_t vown, bool replace_ok);
bool fun_json_dict_add_strings(struct fun_json *dict, const char *const *keys, fun_json_index_t num_keys, fun_json_ownership_t own, const char *const *values, fun_json_ownership_t vown, bool replace_ok);
bool fun_json_dict_add_other_dict(struct fun_json *dict, FUN_JSON_XFER struct fun_json *other, bool replace_ok);
bool fun_json_dict_remove(struct fun_json *dict, const char *key);
bool fun_json_update_in_place(struct fun_json *source, const char *key_path, NULLABLE FUN_JSON_XFER struct fun_json *new_value, bool ok_create_array, bool ok_create_dict, bool ok_to_replace, OUT const char **error);
bool fun_json_update_in_place_at_parsed_path(struct fun_json *source, const struct fun_json_parsed_path *pp, fun_json_path_index_t start_index, NULLABLE FUN_JSON_XFER struct fun_json *new_value, bool ok_create_array, bool ok_create_dict, bool ok_to_replace, OUT const char **error);
bool fun_json_delete_at_key_path(struct fun_json *,const char *key_path, bool in_place);
bool fun_json_delete_at_parsed_path(struct fun_json *,const struct fun_json_parsed_path *pp, fun_json_path_index_t start_index, bool in_place);
bool fun_json_override_in_place(struct fun_json *dict, const struct fun_json *overrides, OUT const char **error);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_json_identify_common_and_overrides(const struct fun_json *inputs, OUT CALLER_TO_RELEASE struct fun_json **overrides_array, OUT const char **error);
CALLER_TO_RELEASE struct fun_json *fun_json_retain(NULLABLE const struct fun_json *json);
bool fun_json_release(NULLABLE FUN_JSON_XFER struct fun_json *json);
static inline void fun_json_release_multiple(struct fun_json **jsons, size_t count) {for(size_t i =0; i <count; i++)fun_json_release(jsons[i]);}
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_blob(const struct fun_ptr_and_size);
fun_json_index_t fun_json_blob_byte_count(NULLABLE const struct fun_json *blob);
bool fun_json_blob_fill_memory(const struct fun_json *blob, struct fun_ptr_and_size pas);
bool fun_json_blob_is_proper(NULLABLE const struct fun_json *blob);
bool fun_json_is_proper(const struct fun_json *);
void fun_json_check_proper(const struct fun_json *);
NOINLINE NULLABLE CALLER_TO_RELEASE struct fun_json *fun_json_create_dict_with_prefixed_keys(fun_json_index_t num_keys, const char *prefix, const struct fun_json *);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_json_create_dict_int64s_with_prefixed_keys(fun_json_index_t num_keys, const char *prefix, int64_t);
size_t fun_json_read_enough_bytes_for_json_from_fd(int fd, INOUT uint8_t **,INOUT size_t *);
NULLABLE CALLER_TO_RELEASE struct fun_json *fun_json_read_from_fd(int);
bool fun_json_write_to_fd(const struct fun_json *json, int socket);
CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_read_text_file(const char *file);
bool fun_json_write_text_file(const struct fun_json *,const char *file, uint32_t flags);
NULLABLE struct fun_json *MUST_CHECK _fun_json_lookup_multi(NULLABLE const struct fun_json *, ...);
bool fun_json_blob_is_appendable(NULLABLE const struct fun_json *blob);
struct fun_json *fun_json_blob_concatenate(NULLABLE const struct fun_json *b1, NULLABLE const struct fun_json *b2);
struct fun_json *_fun_json_dict_enum_helper(size_t asize, size_t tsize, const char *tname, const char *const *keys, const uint64_t *);
FUN_DEPRECATED NULLABLE void *fun_json_memcpy(OUT void *dest, const struct fun_json *);

--------------

utils/threaded/fun_json_bjson.h: 

struct fun_json_binary_owner;
void _fun_json_binary_owner_release(struct fun_json_binary_owner *);
struct fun_json_bjson_ser_buffer {size_t capacity; size_t size; uint8_t *bytes;};
static inline void _fun_json_bjson_ser_buffer_free_bytes(struct fun_json_bjson_ser_buffer *buffer)
 {fun_free_threaded(buffer->bytes, buffer->capacity);}
bool _fun_json_bjson_serialize_recursive(struct fun_json_bjson_ser_buffer *,const struct fun_json *);
bool _fun_json_bjson_serialization_size_exceeds(const struct fun_json *,INOUT size_t *);
CALLER_TO_RELEASE struct fun_json *_fun_json_create_from_binary(const uint8_t *bytes, size_t size, bool allow_json_errors_in_the_tree);

--------------

utils/threaded/fun_json_path.h: 

typedef uint8_t fun_json_path_index_t;
struct fun_json_parsed_path {uint32_t _magic; fun_json_path_index_t num_components; uint8_t _padding[3];const char *path; uint16_t _offsets[JSON_PATH_MAX_DEPTH];};
bool fun_json_path_parse(const char *,OUT struct fun_json_parsed_path *);
size_t fun_json_parsed_path_at(const struct fun_json_parsed_path *,fun_json_path_index_t n, const char **start);
uint32_t fun_json_parsed_path_index_component(const char *);
uint32_t fun_json_parsed_path_index_at(const struct fun_json_parsed_path *,fun_json_path_index_t);
bool fun_json_parsed_path_index_at_matches_key(const struct fun_json_parsed_path *pp, fun_json_path_index_t n, const char *key);
bool fun_json_parsed_path_index_at_matches_index(const struct fun_json_parsed_path *,fun_json_path_index_t, uint32_t candidate);

--------------

utils/threaded/fun_json_private.h: 

enum fun_json_type {fun_json_error_type =0, fun_json_null_type =1, fun_json_bool_type =2, fun_json_int_type =3, fun_json_double_type =4, fun_json_string_type =5, fun_json_array_type =6, fun_json_dict_type =7, fun_json_last_type =8,};
enum fun_json_type fun_json_get_type(const struct fun_json *);
struct fun_json_binary_owner;
struct fun_json {NULLABLE struct fun_json_binary_owner *owner; ALIGNED(4)uint32_t extra_refcount; uint8_t type; uint8_t flags; uint16_t mini_checksum; union{const char *error_message; int64_t large_int_value; double double_value; const char *string_value; struct fun_json_array *array; struct fun_json_byte_array *byte_array; struct fun_map *dict;};char inline_chars[FUN_JSON_INLINE_NCHARS];
};
int64_t _fun_json_int64_value(const struct fun_json *);
const char *_fun_json_string_value(const struct fun_json *);
struct fun_json *_fun_json_create_cst_error(const char *);
struct fun_json_array {fun_json_index_t count; fun_json_index_t allocated; struct fun_json *items[];};
static inline size_t _fun_json_array_memory_size(fun_json_index_t allocated)
{return sizeof(struct fun_json_array)+allocated *sizeof(struct fun_json *);
}
NULLABLE struct fun_json_array *_fun_json_create_raw_array(fun_json_index_t);
NULLABLE struct fun_json_array *_fun_json_array_grow(struct fun_json_array *);
void _fun_json_array_remove_in_place_at(struct fun_json_array *,fun_json_index_t);
void _fun_json_array_free(struct fun_json_array *);
struct fun_json_byte_array {fun_json_index_t count; uint8_t bytes[];};
NULLABLE struct fun_json_byte_array *_fun_json_create_byte_array(struct fun_json *,fun_json_index_t count);
void _fun_json_free_byte_array(NULLABLE struct fun_json_byte_array *);
bool _fun_json_array_change_representation_in_place(struct fun_json *);
static inline NULLABLE struct fun_json *_fun_json_dict_get(const struct fun_map *dict, const char *key)
 {assert(dict);return(struct fun_json *)fun_map_get(dict,(fun_map_key_t)key);}
NULLABLE struct fun_json *_fun_json_map_get_with_length(const struct fun_map *dict, const char *key, size_t len, OUT const char **original_key);
NULLABLE struct fun_json *_fun_json_map_get_with_length_or_0(const struct fun_map *dict, const char *key, size_t len, OUT const char **original_key);
NULLABLE struct fun_map *_fun_json_create_map(fun_json_index_t wanted_capacity);
NULLABLE struct fun_map *_fun_json_create_map_with_keys_values(fun_json_index_t, const char *const *keys, struct fun_json **subs);
void _fun_json_map_destroy(struct fun_map *dict, bool own_keys);
NULLABLE CALLER_TO_RELEASE struct fun_json *_fun_json_create(enum fun_json_type);

--------------

utils/threaded/fun_json_schema.h: 

WU_THREADED bool fun_json_schema_is_valid(const struct fun_json *,OUT CALLER_TO_RELEASE NULLABLE struct fun_json **error);
WU_THREADED bool fun_json_schema_validate(const struct fun_json *schema, const struct fun_json *json, OUT CALLER_TO_RELEASE NULLABLE struct fun_json **error);

--------------

utils/threaded/fun_json_text.h: 

struct fun_json_parse_context {const char *start; const char *limit; uint32_t flags; uint32_t line; const char *line_start;};
struct fun_json *_fun_json_parse_recursive(struct fun_json_parse_context *,int max_depth);
void _fun_json_swallow_all_whitespace(struct fun_json_parse_context *);
struct fun_json_pretty_print_params {const char *space_per_level; size_t max_line; uint32_t flags; uint32_t max_depth;};
bool _fun_json_pretty_print(struct fun_json_pretty_print_params *,struct fun_string_buffer *,const struct fun_json *,uint32_t indent_level);

--------------

utils/threaded/fun_json_utils.h: 

WU_THREADED NULLABLE CALLER_TO_RELEASE struct fun_json *faddr_to_json(faddr_t);
WU_THREADED NULLABLE CALLER_TO_RELEASE struct fun_json *rindex_to_json(rindex_t);
WU_THREADED NULLABLE CALLER_TO_RELEASE struct fun_json *flow_summary_to_json(const struct flow *);
WU_THREADED NULLABLE CALLER_TO_RELEASE struct fun_json *workerpool_to_json(struct workerpool *);
WU_THREADED bool fun_json_dict_add_uuid(struct fun_json *json_dict, const char *key, fun_json_ownership_t, fun_uuid_t, bool replace_ok);
WU_THREADED bool fun_json_array_append_uuid(struct fun_json *json_array, fun_uuid_t);
bool fun_json_lookup_uuid(NULLABLE const struct fun_json *dict, const char *key, OUT NULLABLE fun_uuid_t *);
WU_THREADED CALLER_TO_RELEASE NULLABLE struct fun_json *fun_json_create_uuid_string(fun_uuid_t);
bool fun_json_arg_value_uuid(NULLABLE struct fun_json *args, const char *key, OUT fun_uuid_t *);
bool fun_json_lookup_ipv4(NULLABLE const struct fun_json *dict, const char *key, OUT NULLABLE uint32_t *);
bool fun_json_lookup_mac(NULLABLE const struct fun_json *,const char *,OUT uint8_t *);
void fun_json_printf_push(struct channel *,const char *format_with_1_percent_s, const struct fun_json *);
void fun_json_argc_argv_to_json_push(struct channel *,OUT struct fun_json **arguments);
CALLER_TO_RELEASE struct fun_json *fun_json_bootargs_to_configargs(void);

--------------

utils/threaded/fun_malloc_threaded.h: 

WU_THREADED NULLABLE void *fun_malloc_threaded(size_t size)RETURN_ALIGNED(64);
WU_THREADED NULLABLE void *fun_calloc_threaded(size_t)RETURN_ALIGNED(64);
void fun_free_threaded(NULLABLE void *ptr, size_t size);
WU_THREADED struct fun_ptr_and_size fun_malloc_ptr_and_size_threaded(size_t s);
WU_THREADED struct fun_ptr_and_size fun_calloc_ptr_and_size_threaded(size_t s);
WU_THREADED void fun_free_ptr_and_size_threaded(struct fun_ptr_and_size ps);
void fun_malloc_multiple_threaded(size_t size_to_allocate, bool clear, bool non_coh, allocation_policy_t, struct stack_frame caller, OUT void **ptrs, uint32_t num_ptrs);
WU_THREADED NULLABLE void *fun_realloc_threaded(NULLABLE void *ptr, size_t old_size, INOUT size_t *new_size);
void fun_free_threaded_multiple(bool non_coh, void **ptrs, uint32_t num_ptrs, size_t size);
WU_THREADED NULLABLE void *fun_alloc_forever_threaded(const char *purpose, size_t size, bool clear, size_t align);
NULLABLE char *fun_strdup(const char *);
NULLABLE char *fun_strndup(const char *,size_t size);
void fun_free_string(NULLABLE char *);
size_t fun_roundup_to_good_alloc_size(size_t size);
void fun_malloc_threaded_yield_on_timeslice(void);
void fun_malloc_threaded_track_stack(enum wsdepth_tag);
struct wuthread_sidecar_buf;
void _tsc_malloc_destroy(void);

--------------

utils/threaded/fun_map_threaded.h: 

NULLABLE struct fun_map *fun_map_create(NULLABLE fun_map_context_t, fun_map_count_t wanted, fun_map_callbacks_t cb);
NULLABLE struct fun_map *fun_map_with_keys_and_values(NULLABLE fun_map_context_t, fun_map_callbacks_t, fun_map_count_t count, const fun_map_key_t *keys, fun_map_value_t *values);
fun_map_value_t fun_map_get_for_substring(const struct fun_map *,const char *sub_string, size_t len, OUT const char **original_key_ptr);
bool fun_map_set_capacity(struct fun_map *,fun_map_count_t);
bool fun_map_add(struct fun_map *,fun_map_key_t, fun_map_value_t, bool replace_ok);
fun_map_count_t fun_map_add_from_to(const struct fun_map *from, struct fun_map *to, bool replace_ok);
void fun_map_transform_each_key(struct fun_map *,fun_map_key_t(*xform)(fun_map_key_t));
void fun_map_destroy(NULLABLE struct fun_map *,NULLABLE fun_map_destroy_pair_f each_pair);

--------------

utils/threaded/fun_props.h: 

typedef NULLABLE void *fun_props_bridge_context_t;
typedef NULLABLE CALLER_TO_RELEASE struct fun_json *fun_props_bridge_tree_gen_f(fun_props_bridge_context_t);
typedef bool fun_props_bridge_merger_f(fun_props_bridge_context_t, const char *key_path, const struct fun_json *new_value);
typedef CALLER_TO_RELEASE struct fun_json *fun_props_array_bridge_gen_f(fun_props_bridge_context_t, fun_json_index_t);
struct fun_props_bridge_params {const char *key_path; NULLABLE const char *schema; fun_props_bridge_context_t context; bool is_lazy_array_bridge_point; fun_props_bridge_tree_gen_f *gen; fun_time_t max_rate; NULLABLE uint64_t *generation_ptr; NULLABLE fun_props_bridge_merger_f *merger; fun_props_array_bridge_gen_f *array_at_index; fun_json_index_t array_count;};
WU_THREADED CALLER_TO_RELEASE NULLABLE struct fun_json *fun_props_peek_and_retain(const char *key_path);
WU_THREADED bool fun_props_poke(const char *key_path, FUN_JSON_XFER struct fun_json *new_value);
void fun_props_poke_push(struct channel *,const char *key_path, FUN_JSON_XFER struct fun_json *new_value);
WU_THREADED bool fun_props_delete(const char *key_path);
void fun_props_delete_push(struct channel *,const char *key_path, OUT bool *status);
WU_THREADED CALLER_TO_RELEASE NULLABLE struct fun_json *fun_props_find_and_retain(const char *pattern, NULLABLE const char *key_path);
WU_THREADED CALLER_TO_RELEASE NULLABLE struct fun_json *fun_props_subset_with_pattern_path(const char *pattern_path);
WU_THREADED bool fun_props_reduce(const char *pattern_path, INOUT struct fun_json_reduce_state *);
void fun_props_sync(void);
void fun_props_register_with_commander(void);
void fun_props_check_push(struct channel *);
WU_THREADED bool fun_props_check_schemas(void);
WU_THREADED struct fun_json *peek_command(struct fun_command_environment *,struct fun_command_transaction *,const struct fun_json *);
WU_THREADED struct fun_json *poke_command(struct fun_command_environment *,struct fun_command_transaction *,const struct fun_json *);

--------------

utils/threaded/fun_props_bridge.h: 

struct fun_props_bridge;
void fun_props_bridge_install_push(struct channel *,const struct fun_props_bridge_params *,OUT struct fun_props_bridge **);
WU_THREADED NULLABLE struct fun_props_bridge *fun_props_bridge_install(const char *key_path, fun_props_bridge_context_t, fun_props_bridge_tree_gen_f);
WU_THREADED struct fun_props_bridge *fun_props_bridge_lazy_array_install(const char *key_path, fun_props_bridge_context_t, fun_json_index_t array_count, fun_props_array_bridge_gen_f);
void fun_props_bridge_uninstall_push(struct channel *,struct fun_props_bridge *);
const struct fun_props_bridge_params *fun_props_bridge_get_params(const struct fun_props_bridge *);
const char *fun_props_bridge_get_path(const struct fun_props_bridge *);
void fun_props_bridge_set_rate_limit(NULLABLE struct fun_props_bridge *b, fun_time_t max_rate);
void fun_props_bridge_set_generation(NULLABLE struct fun_props_bridge *b, NULLABLE uint64_t *generation_ptr);
void fun_props_bridge_set_update_callback(NULLABLE struct fun_props_bridge *b, fun_props_bridge_merger_f);
WU_THREADED void fun_props_bridge_set_schema(NULLABLE struct fun_props_bridge *b, const char *json_schema);
WU_THREADED void fun_props_bridge_flush_cache(struct fun_props_bridge *);
void fun_props_bridge_suspend(struct fun_props_bridge *,bool suspend);
FUN_DEPRECATED WU_THREADED NULLABLE struct fun_props_bridge *fun_props_install_bridge_point(const char *key_path, fun_props_bridge_context_t, fun_props_bridge_tree_gen_f);
FUN_DEPRECATED WU_THREADED NULLABLE struct fun_props_bridge *fun_props_install_bridge_point_raw(const char *key_path, fun_props_bridge_context_t, fun_props_bridge_tree_gen_f);
FUN_DEPRECATED WU_THREADED struct fun_props_bridge *fun_props_install_lazy_array_bridge_point(const char *key_path, fun_props_bridge_context_t, fun_json_index_t array_count, fun_props_array_bridge_gen_f);
FUN_DEPRECATED void fun_props_uninstall_bridge_point_push(struct channel *,struct fun_props_bridge *);
FUN_DEPRECATED const struct fun_props_bridge_params *fun_props_bridge_point_params(const struct fun_props_bridge *);
FUN_DEPRECATED const char *fun_props_bridge_point_path(const struct fun_props_bridge *);
FUN_DEPRECATED void fun_props_bridge_point_set_rate_limit(NULLABLE struct fun_props_bridge *b, fun_time_t max_rate);
FUN_DEPRECATED void fun_props_bridge_point_set_generation(NULLABLE struct fun_props_bridge *b, NULLABLE uint64_t *generation_ptr);
FUN_DEPRECATED WU_THREADED void fun_props_bridge_point_set_schema(NULLABLE struct fun_props_bridge *b, const char *json_schema);
FUN_DEPRECATED WU_THREADED void fun_props_bridge_point_flush_cache(struct fun_props_bridge *);
FUN_DEPRECATED void fun_props_bridge_point_suspend(struct fun_props_bridge *,bool suspend);
FUN_DEPRECATED void fun_props_bridge_point_set_merger(NULLABLE struct fun_props_bridge *b, fun_props_bridge_merger_f);

--------------

utils/threaded/fun_range.h: 

struct fun_range {uint64_t start; size_t size;};
struct fun_sranges {size_t count; size_t capa; struct fun_range *ranges;};
struct fun_range fun_range_empty(void);
bool fun_range_is_empty(struct fun_range);
bool fun_range_is_equal(struct fun_range, struct fun_range);
int fun_range_containment(struct fun_range, uint64_t);
WU_THREADED NULLABLE struct fun_sranges *fun_sranges_create(void);
WU_THREADED bool fun_sranges_set_capacity(struct fun_sranges *,size_t desired_capa);
WU_THREADED void fun_sranges_deinit(struct fun_sranges *);
WU_THREADED void fun_sranges_destroy(NULLABLE struct fun_sranges *);
struct fun_range fun_sranges_span(const struct fun_sranges *);
int fun_sranges_range_at_or_before(const struct fun_sranges *,uint64_t position, OUT size_t *index);
struct fun_range fun_sranges_break_up_range(const struct fun_sranges *,struct fun_range, OUT struct fun_range *non_overlapping, OUT struct fun_range *common, OUT size_t *common_index);
size_t fun_sranges_index_for_gap(const struct fun_sranges *,size_t gap_size, OUT uint64_t *gap_start);
size_t fun_sranges_sum_sizes(const struct fun_sranges *);
void fun_sranges_dump(const struct fun_sranges *);
WU_THREADED bool fun_sranges_add_range(struct fun_sranges *,struct fun_range, OUT size_t *index_added);
WU_THREADED bool fun_sranges_insert_range_at(struct fun_sranges *,struct fun_range, size_t index);
void fun_sranges_remove_range_at(struct fun_sranges *,size_t index);
struct fun_ranges_to_color {struct fun_sranges sranges; uintptr_t *colors;};
WU_THREADED struct fun_ranges_to_color *fun_ranges_to_color(void);
WU_THREADED void fun_ranges_to_color_deinit(struct fun_ranges_to_color *);
WU_THREADED void fun_ranges_to_color_destroy(struct fun_ranges_to_color *);
WU_THREADED bool fun_ranges_to_color_add(struct fun_ranges_to_color *,struct fun_range, uintptr_t color);

--------------

utils/threaded/fun_set_threaded.h: 

NULLABLE struct fun_set *fun_set_create(fun_set_context_t, fun_set_count_t wanted, fun_set_callbacks_t cb);
bool fun_set_set_capacity(struct fun_set *,fun_set_count_t);
bool fun_set_add(struct fun_set *,uintptr_t);
fun_set_count_t fun_set_add_multiple(struct fun_set *,const uintptr_t *,fun_set_count_t);
fun_set_count_t fun_set_union_in_place(struct fun_set *dest, const struct fun_set *other);
void fun_set_destroy(NULLABLE struct fun_set *,NULLABLE fun_set_destroy_item_f each);

--------------

utils/threaded/fun_string_buffer.h: 

struct fun_string_buffer {uint32_t len; uint32_t capacity; char *string; bool fixed_size;};
bool fun_string_buffer_init(struct fun_string_buffer *);
void fun_string_buffer_init_fixed_size(struct fun_string_buffer *,char *buf, size_t buf_size);
void fun_string_buffer_free_string(struct fun_string_buffer *);
bool fun_string_buffer_accommodate(struct fun_string_buffer *,size_t len);
bool fun_string_buffer_append1(struct fun_string_buffer *,char);
bool fun_string_buffer_append2(struct fun_string_buffer *,char, char);
bool fun_string_buffer_append3(struct fun_string_buffer *,char, char, char);
bool fun_string_buffer_appendn(struct fun_string_buffer *,const char *,size_t);
bool fun_string_buffer_append(struct fun_string_buffer *,const char *);
bool fun_string_buffer_append_repeated(struct fun_string_buffer *,const char *,uint32_t times);
bool fun_string_buffer_append_1hex(struct fun_string_buffer *,uint8_t hex);
bool fun_string_buffer_append_2hex(struct fun_string_buffer *buffer, uint8_t hex);
bool fun_string_buffer_append_4hex(struct fun_string_buffer *,uint16_t hex);
bool fun_string_buffer_append_int64(struct fun_string_buffer *,int64_t, bool use_hex);
bool fun_string_buffer_append_double(struct fun_string_buffer *,double);
bool fun_string_buffer_append_unicode_012(struct fun_string_buffer *buffer, const char *utf8, OUT size_t *advance);
bool fun_string_buffer_append_quoted(struct fun_string_buffer *,const char *);

--------------

utils/utils.h: 


--------------

utils/wu/dma_pc_template.h: 

struct crc_params {enum crc_flags_type crc_type; bool use_seed; uint64_t seed; bool check; struct wu *cont_wu;};
struct dma_multi_crc_arg {struct fun_ptr_and_size *vectors; uint16_t *status_p; uintptr_t meta_ptr; wuid_t err_wu; struct crc_params*crc_params;};
struct hw_dmae_le *nu_pkt_free_dmae_le(struct hw_dmae_le *le, void *buf);
void dma_pc_template_copy_from_nu_pkt_no_frame(void *cmdlist_start, faddr_t dma_addr, struct fun_ptr_and_size *vectors, uint8_t num_vectors, uintptr_t source, size_t size, struct wu *continuation_wu, bool freemem, wuid_t err_wu);
void dma_memcpy_push_optimized(struct channel *channel, void *restrict dst, const void *restrict src, uint64_t size);
int dma_memcpy_sgl_push_optimized(struct channel *channel, const struct fun_ptr_and_size *dst, const struct fun_ptr_and_size *src, uint32_t num_dst, uint32_t num_src);
void dma_crc_push_with_skip(struct channel *channel, uintptr_t f1addr, size_t len, uintptr_t f1addr_meta, wuid_t err_wu, struct crc_params*crc_params);
void dma_crc64_push_with_skip(struct channel *channel, uintptr_t f1addr, size_t len, uintptr_t f1addr_meta, wuid_t err_wu, struct crc_params*crc_params);
void
dma_crc64_set_prepend_data(const char *prepend_data);
int dma_memcpy_gather_push_optimized(struct channel *channel, struct fun_ptr_and_size dst, const struct fun_ptr_and_size *src, uint32_t num_src);
enum fun_ret MUST_CHECK dma_tcp_csum_sgl_push(struct channel *channel, const struct fun_ptr_and_size *dst, const struct fun_ptr_and_size *src, uint32_t num_dst, uint32_t num_src, uint32_t csum_start, OUT uint16_t *csum_out);
void
dma_multiple_crc_push_with_skip(struct channel *channel, struct fun_ptr_and_size *vectors, uint16_t num_vec, uintptr_t f1addr_meta, struct crc_params*crc_params, uint16_t *status_p);

--------------

utils/wu/dma_utils.h: 

struct fun_subop_sgl;
struct dma_templ {struct wu cwu; uint8_t sim_info[DMA_UTILS_EXTRA_SIZE_FOR_SIM]; uint8_t cmd_list[HU_DMA_CMD_LIST_SIZE];uint8_t reserved[8];struct wu dma_wu;};
void dma_memset_push(struct channel *,void *restrict dest, uint8_t pattern, size_t size);
void dma_memset64_push(struct channel *,void *restrict dest, uint64_t pattern, size_t size);
void dma_memcpy_push(struct channel *,void *restrict dest, const void *restrict source, size_t size);
void dma_memset64_multiple_push(struct channel *,faddr_t target, void **ptrs, uint32_t num_ptrs, uint64_t pattern, size_t size);
int MUST_CHECK dma_memcpy_gather_push(struct channel *,struct fun_ptr_and_size dst, const struct fun_ptr_and_size *src, uint32_t num_src);
int MUST_CHECK dma_memcpy_scatter_push(struct channel *,const struct fun_ptr_and_size *dst, struct fun_ptr_and_size src, uint32_t num_dst);
int MUST_CHECK
dma_memcpy_to_large_buf_push(struct channel *channel, struct fun_ptr_and_size dst, const struct fun_ptr_and_size *src, uint32_t num_src);
int MUST_CHECK
dma_memcpy_from_large_buf_push(struct channel *channel, const struct fun_ptr_and_size *dst, struct fun_ptr_and_size src, uint32_t num_dst);
int MUST_CHECK dma_memcpy_sgl_push(struct channel *,const struct fun_ptr_and_size *dst, const struct fun_ptr_and_size *src, uint32_t num_dst, uint32_t num_src);
struct dma_operate_crc_info;
int MUST_CHECK dma_crc_sgl_push(struct channel *,const struct fun_ptr_and_size *dst, const struct fun_ptr_and_size *src, uint32_t num_dst, uint32_t num_src, struct dma_operate_crc_info *crc_info);
int MUST_CHECK dma_crc_push(struct channel *,struct fun_ptr_and_size dst, struct fun_ptr_and_size src, struct dma_operate_crc_info *crc_info);
int MUST_CHECK dma_crc_gather_push(struct channel *,struct fun_ptr_and_size dst, const struct fun_ptr_and_size *src, uint32_t num_src, struct dma_operate_crc_info *crc_info);
int MUST_CHECK dma_crc_scatter_push(struct channel *,const struct fun_ptr_and_size *dst, struct fun_ptr_and_size src, uint32_t num_dst, struct dma_operate_crc_info *crc_info);
int MUST_CHECK dma_crc_h2f_sgl_push(struct channel *,struct fun_subop_sgl *src_sgl, const struct fun_ptr_and_size *dst, int ndst, struct dma_operate_crc_info *crc_info, uint32_t src_offset, size_t dmalen, unsigned int zeropad);
int MUST_CHECK dma_h2f_sgl_push(struct channel *,struct fun_subop_sgl *src_sgl, const struct fun_ptr_and_size *dst, int ndst, uint32_t src_offset, size_t dmalen);
int MUST_CHECK dma_h2f_stateful_sgl_push(struct channel *,struct fun_subop_sgl *src_sgl, const struct fun_ptr_and_size *dst, int ndst, size_t dmalen);
int MUST_CHECK dma_f2h_stateful_sgl_push(struct channel *,const struct fun_ptr_and_size *src, struct fun_subop_sgl *dst_sgl, int nsrc, size_t dmalen);
int
dma_h2f_sgl_simple_push(struct channel *channel, struct fun_subop_sgl *src_sgl, void *dst, size_t buflen);
void dma_f2h_push(struct channel *,uint64_t dma_cookie, uintptr_t f1addr, uintptr_t pcieaddr, size_t len);
void
dma_multiple_f2h_push(struct channel *channel, uint64_t dma_cookie, struct fun_ptr_and_size *vectors, uint8_t num_bufs, uintptr_t pcieaddr, size_t len);
void dma_f2h_cm2pcie_push(struct channel *channel, uint64_t dma_cookie, uintptr_t f1_cm_addr, uintptr_t pcieaddr, size_t len);
int MUST_CHECK dma_f2h_sgl_push(struct channel *,const struct fun_ptr_and_size *src, struct fun_subop_sgl *sgl_dst, int nsrc, uint32_t dst_offset, uint32_t dmalen);
int dma_f2h_sgl_with_frame_push(struct frame **frame, const struct fun_ptr_and_size *src, struct fun_subop_sgl *dst_sgl, int nsrc, uint64_t dma_cookie, uint32_t dst_offset, size_t dmalen);
void dma_f2h_g1_s2_push(struct channel *,uint64_t dma_cookie, uintptr_t f1addr, size_t len, uintptr_t pcieaddr1, size_t len1, uintptr_t pcieaddr2, size_t len2);
void dma_f2h_g1_sm_push(struct channel *,uint64_t dma_cookie, uint32_t nle, uintptr_t f1addr, size_t len, uintptr_t pcieaddr1, size_t len1, const uint64_t *addr_list, size_t len2, size_t sge_max_len);
void dma_h2f_push(struct channel *,uint64_t dma_cookie, uintptr_t pcieaddr, uintptr_t f1addr, size_t len);
void dma_multiple_h2f_push(struct channel *,uint64_t dma_cookie, uintptr_t pcieaddr, struct fun_ptr_and_size *vectors, uint8_t num_bufs, size_t len);
void dma_h2f_g2_s1_push(struct channel *,uint64_t dma_cookie, uintptr_t pcieaddr1, size_t len1, uintptr_t pcieaddr2, size_t len2, uintptr_t f1addr, size_t len);
void dma_crc_f2h_push(struct channel *,uint64_t dma_cookie, uintptr_t f1addr, uintptr_t pcieaddr, size_t len, enum crc_flags_type crc_type, uintptr_t f1addr_meta, uintptr_t f1addr_meta_dest, wuid_t err_wu, struct wu *cont_wu, bool use_seed, uint64_t seed);
void dma_crc_f2h_g1_sm_push(struct channel *,uint64_t dma_cookie, size_t g_sge_max_len, struct fun_ptr_and_size *vectors, uint8_t num_bufs, size_t len, uintptr_t pcieaddr1, size_t len1, const uint64_t *addr_list, size_t len2, size_t s_sge_max_len, bool crc_verify, enum crc_flags_type crc_type, uintptr_t f1addr_meta, uintptr_t f1addr_meta_dest, wuid_t err_wu, struct wu *cont_wu, bool use_seed, uint64_t seed);
void
dma_crc_f2h_g1_sm_multiple_push(struct channel *channel, uint64_t dma_cookie, size_t g_sge_max_len, struct fun_ptr_and_size *vectors, uint8_t num_bufs, size_t len, uintptr_t pcieaddr1, size_t len1, const uint64_t *addr_list, size_t len2, size_t s_sge_max_len, bool crc_verify, enum crc_flags_type crc_type, uintptr_t f1addr_meta, uintptr_t f1addr_meta_dest, uint8_t meta_inc, uint8_t num_blks, uint32_t block_sz, struct wu *cont_wu, bool use_seed, uint64_t seed);
void dma_crc_h2f_push(struct channel *,uint64_t dma_cookie, uintptr_t pcieaddr, uintptr_t f1addr, size_t len, enum crc_flags_type type, uintptr_t f1addr_meta, wuid_t err_wu, bool use_seed, uint64_t seed);
void dma_crc_h2f_g2_s1_push(struct channel *,uint64_t dma_cookie, uintptr_t pcieaddr1, size_t len1, uintptr_t pcieaddr2, size_t len2, uintptr_t f1addr, size_t len, enum crc_flags_type crc_type, uintptr_t f1addr_meta, wuid_t err_wu);
void
dma_crc_h2f_gm_s1_push(struct channel *channel, uint64_t dma_cookie, size_t g_sge_max_len, uintptr_t pcieaddr1, size_t len1, const uint64_t *addr_list, size_t len2, struct fun_ptr_and_size *vectors, uint8_t num_bufs, size_t len, size_t s_sge_max_len, enum crc_flags_type crc_type, uintptr_t f1addr_meta, wuid_t err_wu, bool use_seed, uint64_t seed);
void
dma_crc_h2f_gm_s1_multiple_push(struct channel *channel, uint64_t dma_cookie, size_t g_sge_max_len, uintptr_t pcieaddr1, size_t len1, const uint64_t *addr_list, size_t len2, struct fun_ptr_and_size *vectors, uint8_t num_bufs, size_t len, size_t s_sge_max_len, enum crc_flags_type crc_type, uintptr_t f1addr_meta, uint8_t meta_inc, uint8_t num_blks, uint32_t block_sz, bool use_seed, uint64_t seed);
int MUST_CHECK dma_h2f_sgl_with_frame_push(struct frame **,struct fun_subop_sgl *src_sgl, struct fun_ptr_and_size *dst, int ndst, uint64_t dma_cookie, uint32_t src_offset, size_t dmalen);
size_t dma_get_sgl_len(const struct fun_subop_sgl *);
void dma_set_sgl_off8(struct fun_subop_sgl *sgl, int offset);
void dma_dump_fun_sgl(const struct fun_subop_sgl *);
bool dma_test_check_all_zeros(const void *,size_t);
bool dma_test_check_each_word(const void *,size_t size_in_bytes, uint64_t expected);
struct dma_rdwr_test_ctx {void *pcie_addr; void *pcie_addr2; void *f1_addr; size_t dma_len; bool is_test_frame; bool is_pcie_mem; bool aligned64B; uint32_t huid; uint32_t ctlid; uint32_t fnid; uint64_t pcie_cookie; unsigned int seed; unsigned int mem_type;};
void pc_dma_error_debug(void);
void pc_dma_error_debug_cluster(uint8_t cluster_id);
void
pcdma_1g1s_copy_push(struct channel *channel, faddr_t pcdma, void *restrict dest, const void *restrict source, size_t dmalen);
void
pcdma_1g1s_copy_send(struct frame *frame, faddr_t pcdma, void *restrict dest, uint8_t dest_flags, const void *restrict source, uint8_t src_flags, size_t dmalen);
void
pcdma_1gNs_copy_send(struct frame *frame, faddr_t pcdma, struct fun_ptr_and_size *vectors, uint8_t num_vectors, uint8_t dest_ins, const void *restrict source, uint8_t src_ins, size_t dmalen);
void
dma_bzero_early_unsafe_push(struct channel *channel, void *ptr, size_t size);
void
dma_bzero_push(struct channel *channel, void *ptr, size_t size);
void dma_utils_init(void);

--------------

utils/wu/fun_key_alloc.h: 

enum fun_key_size {FUN_KEY_32_BYTES, FUN_KEY_48_BYTES, FUN_KEY_64_BYTES, FUN_KEY_256_BYTES, FUN_KEY_384_BYTES, FUN_KEY_LAST,};
void fun_key_alloc_push(struct channel *channel, enum fun_key_size size, OUT void **ptr);
void fun_key_free_push(struct channel *channel, void *ptr, enum fun_key_size size);
void fun_key_alloc_push_size_t(struct channel *channel, size_t size, OUT void **ptr);
void fun_key_free_push_size_t(struct channel *channel, void *ptr, size_t size);
void fun_key_bootstrap(void);
void fun_key_print_state(void);
extern const size_t fun_key_size_map[];

--------------

utils/wu/fun_malloc.h: 

void fun_malloc_push(struct channel *,size_t size, OUT void **ptr_ptr);
void fun_calloc_push(struct channel *,size_t size, OUT void **ptr_ptr);
void fun_malloc_noncoh_push(struct channel *,size_t size, OUT void **ptr_ptr);
void fun_calloc_noncoh_push(struct channel *,size_t size, OUT void **ptr_ptr);
void fun_free(NULLABLE void *ptr, size_t size);
void fun_free_noncoh(NULLABLE void *ptr, size_t size);
void fun_realloc_push(struct channel *,size_t old_size, size_t new_size, INOUT void **ptr_ptr);
void fun_malloc_multiple_push(struct channel *,size_t size_to_be_allocated, bool clear, bool non_coh, allocation_policy_t, struct stack_frame caller, OUT void **ptrs_ptr, uint32_t num);
void fun_free_multiple(bool non_coh, void **ptrs, uint32_t num, size_t size_of_each_pointer);
NULLABLE void *fun_malloc_forever(const char *purpose, size_t)RETURN_ALIGNED(64);
NULLABLE void *fun_calloc_forever(const char *purpose, size_t)RETURN_ALIGNED(64);
NULLABLE void *fun_alloc_forever(const char *purpose, size_t, bool cleared, size_t align);
NULLABLE void *fun_malloc_dram(size_t size)RETURN_ALIGNED(FUN_MALLOC_DRAM_QUANTUM);
NULLABLE void *fun_malloc_non_coh_dram(size_t size)RETURN_ALIGNED(FUN_MALLOC_DRAM_QUANTUM);
NULLABLE void *fun_malloc_dram_with_options(bool non_coh, size_t size, struct stack_frame caller)RETURN_ALIGNED(FUN_MALLOC_DRAM_QUANTUM);
void fun_free_dram(void *ptr);
void fun_free_non_coh_dram(void *ptr);
void fun_free_dram_with_options(bool non_coh, void *);
void fun_free_dram_multiple(bool non_coh, void **ptrs, uint32_t num);
void fun_malloc_dram_stats(bool non_coh, OUT uint64_t stats[FUN_MALLOC_DRAM_STATS_NUM]);
MUST_CHECK bool fun_try_free(bool non_coh, NULLABLE void *,size_t);
extern bool fun_malloc_enable_first_replenish;
void fun_malloc_dump_stats_push(struct channel *,bool non_coh, bool verbose);
bool is_allocated_by_fun_malloc(const void *);
extern bool mtracker_enabled;
extern struct _fun_malloc_forever *_fun_malloc_all_forever;
extern uint32_t _fun_malloc_num_forever;
struct _fun_malloc_forever {const char *purpose; struct fun_ptr_and_size pas;};

--------------

utils/wu/long_timer.h: 

struct long_timer_struct;
typedef struct long_timer_struct *long_timer_t;
typedef void(*trigger_f)(struct channel *channel, NULLABLE struct flow *flow, void *userinfo);
void long_timer_allocate_push(struct channel *,OUT long_timer_t *);
void long_timer_allocate_nostack_push(struct channel *,OUT long_timer_t *);
void long_timer_start(long_timer_t, trigger_f handler, fun_time_t delay, NULLABLE struct flow *flow, void *userinfo);
void long_timer_allocate_start_push(struct channel *,trigger_f handler, fun_time_t delay, NULLABLE struct flow *flow, void *userinfo, OUT long_timer_t *);
void long_timer_allocate_start_nostack_push(struct channel *,trigger_f handler, fun_time_t delay, NULLABLE struct flow *flow, void *userinfo, OUT long_timer_t *);
void long_timer_cancel_push(struct channel *channel, long_timer_t, trigger_f cancel_pusher);
void long_timer_deallocate(long_timer_t);
void long_timer_deallocate_push(struct channel *channel, long_timer_t);

--------------

utils/wu/mutex.h: 

struct wait_entry;
struct frame;
struct flow;
struct mutex {spinlock_t spinlock; bool locked; bool recursive; uint32_t cnt; struct frame *owner; struct flow *owner_flow; struct wait_entry *head, *tail;};
static inline void mutex_init(struct mutex *mutex)
 {assert(((uintptr_t)mutex &7)==0);memset(mutex, 0, sizeof(*mutex));}
static inline void mutex_recursive_init(struct mutex *mutex)
 {mutex_init(mutex);mutex->recursive =true;}
WU_THREADED void mutex_lock_threaded(struct mutex *mutex);
WU_THREADED void mutex_unlock_threaded(struct mutex *mutex);
WU_THREADED void mutex_recursive_lock_threaded(struct mutex *mutex);
WU_THREADED void mutex_recursive_unlock_threaded(struct mutex *mutex);
bool mutex_try_lock(struct mutex *mutex);
void mutex_lock_push(struct channel *channel, struct mutex *mutex);
void mutex_unlock_push(struct channel *channel, struct mutex *mutex);
static inline bool mutex_is_locked(const struct mutex *mutex)
 {return mutex->locked;}
struct vp_mutex {struct frame *owner; struct wait_entry *head; struct wait_entry *tail; faddr_t vp; };
bool vp_mutex_lock(struct channel *channel, struct vp_mutex *vp_mutex, wuid_t requeue_wu, uintptr_t requeue_arg1, uintptr_t requeue_arg2);
void vp_mutex_unlock(struct vp_mutex *vp_mutex);
void vp_mutex_init(struct vp_mutex *vp_mutex);

--------------

utils/wu/periodic.h: 

typedef void(*periodic_trigger_f)(struct channel *channel, NULLABLE struct flow *flow, void *userinfo);
typedef void(*teardown_f)(struct channel *channel, NULLABLE struct flow *flow, void *userinfo);
enum periodic_timer_state {UNINITIALIZED =0, RUNNING =1, STOPPING =2, STOPPED =3};
struct periodic_timer_hdl {uint32_t tmr_version;};
struct periodic_timer {enum periodic_timer_state state; struct periodic_timer_hdl *user_periodic_hdl; uint32_t tmr_version; periodic_trigger_f trigger_fn; teardown_f teardown_fn; void *userinfo; fun_time_t interval; struct frame *frame; struct flow *flow; struct fun_sleep_cancel canceller;};
void periodic_timer_start_push_with_flow(struct channel *create_channel, periodic_trigger_f trigger, fun_time_t interval, NULLABLE teardown_f teardown, void *userinfo, struct flow *flow, OUT struct periodic_timer **periodic);
void periodic_timer_start_push(struct channel *create_channel, periodic_trigger_f trigger, fun_time_t interval, NULLABLE teardown_f teardown, void *userinfo, OUT struct periodic_timer **periodic);
void periodic_timer_stop(struct periodic_timer *periodic);
int periodic_timer_state(struct periodic_timer *periodic);
void periodic_timer_set_interval(struct periodic_timer *periodic, fun_time_t interval);
void periodic_timer_hdl_init(struct periodic_timer_hdl *hdl);
void periodic_timer_hdl_start_push(struct channel *create_channel, periodic_trigger_f trigger, fun_time_t interval, NULLABLE teardown_f teardown, void *userinfo, struct periodic_timer_hdl *hdl);
void periodic_timer_hdl_stop(struct periodic_timer_hdl *hdl);

--------------

utils/wu/reslock.h: 

typedef void(*reslock_cb_f)(void *arg);
struct resource_lock_stats {uint64_t lock, wait;};
typedef uint32_t resource_id_t;
struct rltable;
void resource_lock_table_free(struct rltable *);
void resource_lock_table_free_sync(struct rltable *);
void resource_lock_table_init_push(struct channel *channel, uint32_t entries, bool entry_based, struct rltable **rltab);
struct rltable *resource_lock_table_init_sync(uint32_t entries, bool entry_based);
void resource_lock_push(struct channel *,struct flow *callee_f, struct rltable *,resource_id_t id, void *cb_fn_arg);
void resource_lock_no_flow_push(struct channel *,struct rltable *table, resource_id_t id, faddr_t vp);
bool is_resource_locked(struct rltable *table, resource_id_t id);
void resource_unlock(struct rltable *,resource_id_t id);
void resource_stats(struct rltable *,struct resource_lock_stats *stats);
struct resource_entry {uint64_t id; bool locked; faddr_t lockedon; uint32_t num_waiters; STAILQ_HEAD(resource_wh, resource_waiter)waiters; TAILQ_ENTRY(resource_entry)next_entry;};
struct resource_entry_table;
void resource_entry_lock_push(struct channel *,struct flow *callee_f, struct resource_entry_table *,struct resource_entry *entry, void *cb_fn_arg);
void resource_entry_unlock(struct resource_entry_table *,struct resource_entry *entry);
void resource_entry_table_stats(struct resource_entry_table *,struct resource_lock_stats *stats);

--------------

utils/wu/sleep.h: 

struct fun_sleep_cancel {void *private; faddr_t faddr;};
void sleep_for_push(struct channel *,fun_time_t duration);
void sleep_for_interruptable_push(struct channel *,fun_time_t duration, struct fun_sleep_cancel *canceler);
void sleep_until_push(struct channel *,fun_time_t future_time);
void sleep_interrupt(struct fun_sleep_cancel *canceler);
void sleep_interrupt_init(struct fun_sleep_cancel *canceler);

--------------

utils/wu/wucommon.h: 

struct bitmap;
struct fun_json;
struct fun_command_environment;
void nop_push(struct channel *,faddr_t dest);
void do_nothing_push(struct channel *,faddr_t dest);
void async_wu_push(struct channel *,const struct wu *wu);
void busy_loop_for_push(struct channel *,faddr_t dest, fun_time_t duration);
typedef void(*new_stack_push_f)(struct channel *channel, void *context);
void push_on_new_stack_and_suspend(struct channel *,new_stack_push_f push_fn, void *context);
void push_on_new_stack_and_suspend_if_room(struct channel *channel, new_stack_push_f push_fn, void *context, size_t min_space);
void fun_free_push(struct channel *,faddr_t dest, bool non_coh, NULLABLE void *ptr, size_t size);
void fun_free_anywhere_push(struct channel *,bool non_coh, NULLABLE void *ptr, size_t size);
void fun_free_indirect_push(struct channel *,faddr_t dest, bool non_coh, void **ptr_ptr, size_t size);
void fun_json_release_anywhere_push(struct channel *,NULLABLE struct fun_json *json);
void fun_command_environment_release_anywhere_push(struct channel *,NULLABLE struct fun_command_environment *env);
void wp_alloc_push(struct channel *,OUT struct workerpool **,uint16_t, struct workerpool *wp_src);
void wp_free(struct workerpool *);
void while_push(struct channel *,void *cond_ctx, bool(*cond_fn)(void *cond_ctx),void *push_ctx, void(*while_push_fn)(struct channel*,void *push_ctx));
typedef void(*niterator_push_fn_f)(struct channel *channel, void *push_ctx, uint64_t *n);
void while_n_push(struct channel *,uint64_t init_n, NULLABLE void *next_ctx, bool(*next_n)(void *next_ctx, uint64_t *n),void *push_ctx, niterator_push_fn_f iter_push);
void for_n_push(struct channel *channel, uint64_t init, uint64_t max, uint64_t stride, void *push_ctx, niterator_push_fn_f iter_push);
void while_duration_push(struct channel *channel, fun_time_t duration, void *push_ctx, niterator_push_fn_f iter_push);
void wu_type_check(uint64_t action);
void hex_dump_push(struct channel *,const void *addr, size_t size, NULLABLE const char *name);
void print_msg_push(struct channel *,const char *msg);
void bitmap_init_push(struct channel *,struct bitmap *,unsigned int num_bits);

