#!/usr/bin/env python3

#	vpcie-toy-composer -- Virtual PCIe Toy Composer
#
#	Copyright (c) 2020 Fungible, Inc.  All rights reserved.
#

# This is a very small and simple "Toy Composer" using Fungible Cluster
# Services Virtual PCIe Fabric Manager to allow Virtual PCIe Fabrics to be
# created, manipulated, deleted, examined, etc.
#
# The set of supported commands are (alias tc=vpcie-toy-composer):
#
#   Fungible Cluster Services Commands:
#
#     tc docker start
#     tc docker stop
#       -- Start/Stop Fungible Cluster Services implemented in a Docker
#       -- Container.
#
#   DPU-related Commands:
#
#     tc ztp [ --ztp-cs-host] <DPU ccLinux> ...
#       -- Perform Zero Touch Provisioning on a new DPU ccLinux instance.
#       -- The ZTP Host parameter provides a Host/IP Address for the DPU
#       -- to communicate with Fungible Cluster Services to retrieve its
#       -- prosisioning information.  By default, it will use the same
#       -- --cs-host/$CS_HOST that we use to talk to FCS, but that's only
#       -- appropriate for Docker Container deployed FCS instances.  For
#       -- Three-Node High-Availability FCS deployments, the DPU ZTP will
#       -- need to use the "South" Virtual IP Address of the HA Cluster.
#
#   Virtual PCIe Fabric Manager Commands:
#
#     tc vfm create
#         [ --max-downport-id <n> ]
#         [ --name <name> ]
#         <vPortSpec> ...
#     tc vfm hot-plug <vPortSpec> ...
#     tc vfm hot-unplug <vPortID> ...
#     tc vfm delete <vFabricID> ...
#       -- Create/Hot Plug/Hot Unplug/Delete Virtual PCIe Fabrics.
#
#     tc vfm dpus
#       -- List all Online DPUs which have Virtual PCIe Switch Ports
#
#     tc vfm vfabrics
#       -- List existing Virtual PCIe Fabrics.
#
#     tc vfm dpu <DPU> ...
#     tc vfm vfabric <vFabricID> ...
#       -- Display detailed information on specified DPUs and Virtual PCIe
#       -- Fabrics.
#
#     tc vfm enumerate <PortSpec> ...
#       -- Display PCIe Fabric Enumerations of DPU PCIe Switch Down Port
#       -- (can only be used when not bound into a Virtual PCIe Fabric).
#
#     tc vfm debug <DPU>
#         [ --trace-link ]
#         [ --trace-tlp ]
#         [ --trace-s2s ]
#         [ --trace-routing ]
#       -- Display/Set DPU Virtual PCIe Debug Flags.
#
#   Simple Network Service Commands:
#
#     tc sns dpus
#       -- List all known DPUs and detailed information about them and
#       -- their states.
#
#     tc sns dpu <DPU> ...
#       -- List detailed information for specified DPUs.
#
# Nomenclature:
#
#     <DPU ccLinux> -- DPU ccLinux Hostname/IP Address
#     <vPortSpec>   -- <DPU>/<Portname>/<vPortID>
#     <PortSpec>    -- <DPU>/<Portname>
#     <DPU>         -- DPU Ethernet Management Port MAC Address (or name, see
#                      CS_DPUS below)
#     <Portname>    -- DPU PCIe Controller Name
#     <vPortID>     -- The Virtual Port Number that will be bound to the
#                      (<DPU>, <Portname>).  Legal values are 0..31 for
#                      PCIe Controllers configured as Switch Down Ports,
#                      32 for PCIe Controllers configured as Switch Up Ports.
#     <vFabricID>   -- The UUID for a Virtual PCIe Fabric.
#
# Useful Environment Variables:
#
#     CS_HOST       -- The Hostname/IP Address where Fungible Cluster Services
#                      is running.
#     CS_PORT       -- The TCP Port for FCS RESTful APIs (mostly for debugging).
#     CS_DPUS       -- A JSON File containing a Dictionary of DPU Names (keys)
#                      and Ethernet Management Port MAC Addresses (values).
#
# This application uses the Fungible Cluster Services Virtual PCIe Fabric
# Manager for most of its actions.  Documentation for the vPCIeFM can be
# found in the Virtual PCIe Fabric Manager APIs document.
#

import logging
import os
import sys
import subprocess
import socket
import tempfile
import argparse
import re
import json

# Set up basic Logging ...
#
logger = logging.getLogger("cs")
logging.basicConfig(level=logging.ERROR)

# Return whether the passed string argument represents a legally formated
# Ethernet MAC Address.
#
def is_ether_mac(s):
	# xx:xx:xx:xx:xx:xx
	mac = '([0-9a-f][0-9a-f]:){5}[0-9a-f][0-9a-f]'
	return re.search('^' + mac + '$', s) != None

# The user can specify DPUs either via their Name or Management Port Ethernet
# MAC Address.  If a Name is supplied, we need to translate that to the DPU
# MAC ddress because that's the "True Name" of the DPU according to Fungible
# Cluster Services.
#
# A DPU Name to Management Port Ethernet MAC Address table can be specified
# via a file containing a JSON { key: value } object where the keys are DPU
# Names and the values are the MAC Addresses.
#
def dpu_name_to_mac(args, dpu_name):
	# If it's already an Ethernet MAC Address, just return that.
	#
	if is_ether_mac(dpu_name):
		return dpu_name

	# If we don't have a DPU Name Translation Table or the DPU Name isn't
	# in the Table, then throw an error.
	#
	if not args.cs_dpus or dpu_name not in args.cs_dpus:
		logger.error(
		    'Argument DPU {} not Ethernet MAC and not in '
		    'mapping table'.format(dpu_name))
		raise

	# Return the DPU Name Translation.
	#
	return args.cs_dpus[dpu_name]

# Given an Ethernet MAC Address, see if there's a DPU Name translation for it.
# If so, return the Name, otherwise, just return the original MAC Address.
#
def mac_to_dpu_name(args, mac):
	# If it's not an Ethernet MAC Address (it's already a DPU Name) or
	# we don't have a DPU Name to Ethernet MAC Table, then just return
	# the original parameter.  We don't throw an error on this because
	# this is merely a convenience to be able to provide a DPU Name
	# corresponding to a MAC Address.
	#
	if not is_ether_mac(mac) or not args.cs_dpus:
		return mac

	# If the MAC Address is in the DPU Name to MAC Address Table, then
	# return the DPU Name.
	#
	for dpu_name in args.cs_dpus:
		if args.cs_dpus[dpu_name] == mac:
			return dpu_name

	# Otherwise, just return the original MAC Address.
	#
	return mac

# ArgumentParser UUID type "conversion".  Verify that the passed string is a
# legal UUID and return the string unmodified.
#
def argparse_type_uuid(s):
	# xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
	uuid = '[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}'
	if not re.search('^' + uuid + '$', s):
		logger.error('Illegal UUID Format "{}"'.format(s))
		raise
	return s

# ArgumentParser JSON File type conversion.  Loads the specified JSON File and
# returns the result as the Argument Conversion.
#
def argparse_type_json_file(s):
	with open(s, 'r') as d:
		return json.load(d)

# ArgumentParser int type conversion which returns the int() conversion of
# the argument or None if 0 is passed in.
#
def argparse_type_int_none(s):
	val = int(s)
	if val == 0:
		return None
	return val

# ArgumentParser boolean type conversion which accepts a number of different
# forms for true/false.
#
def argparse_type_bool_onoff(s):
	ls = s.casefold()
	if (ls == 'true' or ls == 'on' or ls == '1'):
		return True
	if (ls == 'false' or ls == 'off' or ls == '0'):
		return False
	logger.error('"{}" not true-false/on-off/1-0'.format(s))
	raise

# Convert a <DPU>/<Portname> Specification into (dpu, portname), with DPU
# Name translations.
#
def portspec_to_tuple(args, portspec):
	port = portspec.split('/')
	if len(port) != 2:
		logger.error('Argument {} not in "DPU/PortName" format'.format(vportspec))
		raise

	dpu = dpu_name_to_mac(args, port[0])
	portname = port[1]

	return (dpu, portname)

# Convert a <DPU>/<Portname>/<vPortID> Specification into (dpu, portname,
# vportid), with DPU Name translations.
#
def vportspec_to_tuple(args, vportspec):
	vport = vportspec.split('/')
	if len(vport) != 3:
		logger.error('Argument {} not in "DPU/PortName/vPortID" format'.format(vportspec))
		raise

	dpu = dpu_name_to_mac(args, vport[0])
	portname = vport[1]
	vportid = vport[2]

	if not vportid.isnumeric():
		logger.error('Argument {}, vportid "{}" not a number'.format(vportspec, vportid))
		raise

	vportid = int(vportid)
	if vportid < 0 or vportid > 32:
		logger.error('Argument {}, vportid {} out of range 0..32'.format(vportspec, vportid))
		raise

	return (dpu, portname, vportid)

# Convert a command line specification of a vFabric Port into the JSON
# specification used by the Virtual PCIe Fabric Manager:
#
#   E.g. dpu/portname/vportid gets converted into:
#       {
#           'dpu' : '<dpu>',
#           'port_name' : '<portname>',
#           'virtual_port_id' : <vportid>
#       }
#
# We also support mapping DPU Names into their Ethernet Management Port MAC
# Addresses via a DPU Name to MAC Address Dictionary
#
def vportspec_to_json(args, vportspec):
	(dpu, portname, vportid) = vportspec_to_tuple(args, vportspec)
	return { 'dpu' : dpu,
		 'port_name' : portname,
		 'virtual_port_id' : vportid }

# Construct the curl command to the API Gateway.  If --verbose or --dry-run
# were specified, then dump the command on stdout.  If --dry-run was specified
# leave it at that.  Otherwise, execute the curl command and return the
# decoded JSON result.
#
def curl_api_gateway(args, options, cmd):
	api_gateway = 'http://{}:{}/FunCC/v1/'.format(args.cs_host, args.cs_port)
	curl_cmd = 'curl --silent --user {} {} {}{}'.format(
	    args.cs_user, options, api_gateway, cmd)

	if args.verbose or args.dry_run:
		print(curl_cmd)
		if args.dry_run:
			return {}

	curl_out = subprocess.getoutput(curl_cmd)
	if curl_out == '':
		logger.error('"{}" returns nothing!'.format(curl_cmd))
		raise
	result = json.loads(curl_out)
	if args.debug:
		print('Command =', curl_cmd)
		print('Result  =', result)

	if not result['status']:
		logger.error('"{}" returns "{}"'.format(curl_cmd, result))
		raise

	return result

# Execute a command on the Fungible Cluster Services Host.
#
def ssh_cs_host(args, cmd):
	if (args.cs_host == 'localhost' or args.cs_host == '127.0.0.1'):
		cs_cmd = cmd
	else:
		cs_cmd = 'ssh localadmin@{} {}'.format(args.cs_host, cmd)

	if args.verbose or args.dry_run:
		print(cs_cmd);
		if args.dry_run:
			return

	result = os.system(cs_cmd)
	if result !=0 or args.debug:
		logger.error('"{}", result = {}'.format(cs_cmd, result))
		raise

# Execute a command on a DPU ccLinux instance.
#
def ssh_cclinux(args, cclinux, cmd):
	# We use -o StrictHostKeyChecking=off to prevent ssh/scp from throwing
	# a fit when new DPU ccLinux instances have different ssh keys.  This
	# also prevents them from asking if we "really" want to trust the
	# remote Host, etc.  This is typically only an issue in testing
	# environments where DPUs are repeatedly reinstantiated and thus
	# get new keys.
	#
	cc_cmd = 'ssh -o StrictHostKeyChecking=off root@{} {}'.format(
	    cclinux, cmd)

	if args.verbose or args.dry_run:
		print(cc_cmd)
		if args.dry_run:
			return

	result = os.system(cc_cmd)
	if result != 0 or args.debug:
		logger.error('"{}", result = {}'.format(cc_cmd, result))
		raise

# Execute an scp command copying a local file to a DPU ccLinux instance remote
# file.
#
def scp_cclinux(args, cclinux, local_file, remote_file):
	# We use -o StrictHostKeyChecking=off to prevent ssh/scp from throwing
	# a fit when new DPU ccLinux instances have different ssh keys.  This
	# also prevents them from asking if we "really" want to trust the
	# remote Host, etc.  This is typically only an issue in testing
	# environments where DPUs are repeatedly reinstantiated and thus
	# get new keys.
	#
	scp_cmd = 'scp -o StrictHostKeyChecking=off {} root@{}:{}'.format(
	    local_file, cclinux, remote_file)

	if args.verbose or args.dry_run:
		print(scp_cmd)
		if args.dry_run:
			return

	result = os.system(scp_cmd)
	if result != 0 or args.debug:
		logger.error('"{}", result = {}'.format(scp_cmd, result))
		raise

# Implement Fungible Cluster Services Docker Start command:
#
#     tc docker start
#
def subcmd_docker_start(args):
	ssh_cs_host(args, 'sudo /opt/fungible/fc/etc/fun_containers.sh start')

# Implement Fungible Cluster Services Docker Stop command:
#
#     tc docker stop
#
def subcmd_docker_stop(args):
	ssh_cs_host(args, 'sudo /opt/fungible/fc/etc/fun_containers.sh clean')

# Implement DPU Zero Touch Provisioning command:
#
#     tc ztp <DPU ccLinux> ...
#
def subcmd_ztp(args):
	# Determine the Fungible Cluster Services Host for the Zero Touch
	# Provisioning.  If an explicit ZTP CS Host has been provided, use
	# that.  Otherwise use the CS Host/IP Address we use to talk to
	# Fungible Cluster Services.
	#
	if args.ztp_cs_host != None:
		ztp_cs_host = args.ztp_cs_host
	else:
		ztp_cs_host = args.cs_host

	# "Localhost" is never appropriate ...
	#
	if ztp_cs_host == 'localhost' or ztp_cs_host == '127.0.0.1':
		logger.error('Zero Touch Provision Fungible Cluster Services '
		    'Host must not be "localhost"')
		raise

	# Note: I tried doing this without a temporary file, but trying to
	# get the quoting right wich ssh was just too messy.
	#
	ztp_file = tempfile.NamedTemporaryFile()
	ztp_file.write(json.dumps(
	    {
		 'mgmtif' : 'eth0',
		 'controllers' : socket.gethostbyname(args.cs_host)
	    }).encode('utf-8'))
	ztp_file.write(b'\n')
	ztp_file.flush()

	for dpu in args.dpus:
		print('ZTP {} ...'.format(dpu))
		ssh_cclinux(args, dpu, 'mkdir -p /persist/config/ztp')
		scp_cclinux(args, dpu,
		    ztp_file.name, '/persist/config/ztp/startup_cfg.json')

	ztp_file.close()

# Implement Virtual PCIe Fabric Manager Create vFabric command:
#
#     tc vfm create
#         [ --max-downport-id <n> ]
#         [ --name <name> ]
#         <vPortSpec> ...
#
def subcmd_vfm_create(args):
	# Construct optional parameters ...
	#
	params = {}
	if args.down_port_id_max:
		params['down_port_id_max'] = args.down_port_id_max
	if args.name:
		params['name'] = args.name

	# Construct ports ...
	#
	ports = []
	for vportspec in args.vportspecs:
		ports.append(vportspec_to_json(args, vportspec))

	# Put these together into the Create Virtual PCIe Fabric coammand.
	#
	create = {}
	if params != {}:
		create['params'] = params
	create['ports'] = ports

	# Get everything together in the POST Data and send the command off ...
	#
	options = '--header \'Content-Type: application/json\' --data \'{}\''.format(
	    json.dumps(create))
	curl_api_gateway(args, options, 'virtual-fabrics')

# Implement Virtual PCIe Fabric Manager Hot-Plug command:
#
#     tc vfm hot-plug <vPortSpec> ...
#
def subcmd_vfm_hot_plug(args):
	ports = []
	for vportspec in args.vportspecs:
		ports.append(vportspec_to_json(args, vportspec))

	hot_plug = {}
	hot_plug['virtual_fabric'] = args.vfabric
	hot_plug['ports'] = ports

	options = '-X PATCH --header \'Content-Type: application/json\' --data \'{}\''.format(
	    json.dumps(hot_plug))
	curl_api_gateway(args, options, 'virtual-fabrics/add')

# Implement Virtual PCIe Fabric Manager Hot-Unplug command:
#
#     tc vfm hot-unplug <vPortID> ...
#
def subcmd_vfm_hot_unplug(args):
	ports = []
	for vportid in args.vportids:
		ports.append({ 'virtual_port_id' : vportid })

	hot_unplug = {}
	hot_unplug['virtual_fabric'] = args.vfabric
	hot_unplug['ports'] = ports

	options = '-X PATCH --header \'Content-Type: application/json\' --data \'{}\''.format(
	    json.dumps(hot_unplug))
	curl_api_gateway(args, options, 'virtual-fabrics/remove')

# Implement Virtual PCIe Fabric Manager Delete vFabric command:
#
#     tc vfm delete <vFabricID> ...
#
def subcmd_vfm_delete(args):
	for vfabric in args.vfabrics:
		curl_api_gateway(args, '-X DELETE',
		    'virtual-fabrics/' + vfabric)

# Implement Virtual PCIe Fabric Manager List DPUs command:
#
#     tc vfm dpus
#
def subcmd_vfm_dpus(args):
	result = curl_api_gateway(args, '', 'dpu-resources')
	dpus = result['dpus']
	if dpus == None:
		print('No DPUs with Virtual PCIe Switch Ports online')
		return

	# If any of the DPUs returned are in our Name:MAC Table, add their
	# Names into the result.
	#
	for dpu in dpus:
		mac = dpu['dpu']
		name = mac_to_dpu_name(args, mac)
		if mac != name:
			dpu['dpu_name'] = name

	print(json.dumps(dpus, indent=args.indent, sort_keys=True))

# Implement Virtual PCIe Fabric Manager List vFabrics command:
#
#     tc vfm vfabrics
#
def subcmd_vfm_vfabrics(args):
	result = curl_api_gateway(args, '', 'virtual-fabrics')
	vfabrics = result['virtual_fabrics']
	if vfabrics == None:
		print('No vfabrics present')
		return

	print(json.dumps(vfabrics, indent=args.indent, sort_keys=True))

# Implement Virtual PCIe Fabric Manager List DPU PCIe Ports command:
#
#     tc vfm dpu <DPU> ...
#
def subcmd_vfm_dpu(args):
	for dpu in args.dpus:
		result = curl_api_gateway(args, '',
		    'dpu-resources/' + dpu_name_to_mac(args, dpu) + '/pcie-ports')
		print(mac_to_dpu_name(args, dpu), ':',
		    json.dumps(result['ports'], indent=args.indent,
			sort_keys=True))

# Implement Virtual PCIe Fabric Manager List vFabric Ports command:
#
#     tc vfm vfabric <vFabricID> ...
#
def subcmd_vfm_vfabric(args):
	for vfabric in args.vfabrics:
		result = curl_api_gateway(args, '',
		    'virtual-fabrics/' + vfabric + '/ports')

		# If any of the DPUs returned are in our Name:MAC Table, add
		# their Names into the result.
		#
		for port in result['ports']:
			mac = port['dpu']
			name = mac_to_dpu_name(args, mac)
			if mac != name:
				port['dpu_name'] = name

		print(vfabric, ':',
		    json.dumps(result, indent=args.indent, sort_keys=True))

# Implement Virtual PCIe Fabric Manager DU/Portname Enumeration command:
#
#     tc vfm enumerate <DPUPortSpec> ...
#
def subcmd_vfm_enumerate(args):
	for portspec in args.portspecs:
		(dpu, portname) = portspec_to_tuple(args, portspec)
		result = curl_api_gateway(args, '',
		    '/dpu-resources/' + dpu + '/pcie-ports/' + portname)
		print(portspec, ':',
		    json.dumps(result['enumeration'],
			 indent=args.indent, sort_keys=True))

# Implement Virtual PCIe Fabric Manager DPU Debug options
#
#     tc vfm debug <DPU>
#         [ --trace-link ]
#         [ --trace-tlp ]
#         [ --trace-s2s ]
#         [ --trace-routing ]
#
def subcmd_vfm_debug(args):
	# There's probably an easier wat to get ArgumentParser to leave a flag
	# if any of the Set Debug Options have been used.  But for now we'll
	# just check them manually ...
	#
	set_options = (
	    args.trace_link    != None or
	    args.trace_tlp     != None or
	    args.trace_s2s     != None or
	    args.trace_routing != None)

	dpu = dpu_name_to_mac(args, args.dpu)
	cmd = 'dpu-resources/{}/debug-flags'.format(dpu)

	result = curl_api_gateway(args, '', cmd)

	# If no Set Debug Options were present, then we can just dump out the
	# current DPU Debug Flags and return.
	#
	if not set_options:
		print(json.dumps(result, indent=args.indent))
		return

	# Annoyingly, the Virtual PCIe Fabric Manager insists that we supply
	# all of the DPU Trace Flags, even if we only want to change a subset.
	# Se wee need to merge our new selections into the old set.
	#
	new_debug = result
	if not args.dry_run:
		new_debug.pop('status')

	if args.trace_link != None:
		new_debug['trace_link'] = args.trace_link
	if args.trace_tlp != None:
		new_debug['trace_tlp'] = args.trace_tlp
	if args.trace_s2s != None:
		new_debug['trace_s2s'] = args.trace_s2s
	if args.trace_routing != None:
		new_debug['trace_routing'] = args.trace_routing

	# Note that we need to single-quote the JSON since it will use
	# double-quotes ...
	#
	options = '--header \'Content-Type: application/json\' --data \'{}\''.format(
	    json.dumps(new_debug))
	curl_api_gateway(args, options, cmd)

# Implement Simple Network Service List All Known DPUs command:
#
#     tc sns dpus
#
def subcmd_sns_dpus(args):
	result = curl_api_gateway(args, '', 'network/dpus')
	dpus = result['data']['dpu']
	if dpus == None or dpus == []:
		print('No DPUs online')
		return

	# If any of the DPUs returned are in our Name:MAC Table, add their
	# Names into the result.
	#
	for dpu in dpus:
		mac = dpu['mac']
		name = mac_to_dpu_name(args, mac)
		if mac != name:
			dpu['dpu_name'] = name

	print(json.dumps(dpus, indent=args.indent, sort_keys=True))

# Implement Simple Network Service List Detailed DPU Infomation command:
#
def subcmd_sns_dpu(args):
	# Get the list of all DPUs that Simple Network Service knows about.
	#
	result = curl_api_gateway(args, '', 'network/dpus')
	dpus = result['data']['dpu']
	if dpus == None or dpus == []:
		print('No DPUs online')
		return

	# Create a list of our desired DPUs MAC Addresses (translating any
	# DPU Names along the way).
	#
	desired_dpus_macs = []
	for dpu in args.dpus:
		desired_dpus_macs.append(dpu_name_to_mac(args, dpu))

	# For any of the known DPUs which have MAC Addresses in our list of
	# Desired DPU MAC Addresses, dump out their detailed information.
	#
	for dpu in dpus:
		mac = dpu['mac']
		if mac in desired_dpus_macs:
			print(mac_to_dpu_name(args, mac), ':',
			    json.dumps(dpu, indent=args.indent,
			    sort_keys=True))

def main():
	# The vast majority of the work for main() is done in the Argument
	# Parser ...
	#
	cmd_parser = argparse.ArgumentParser(
	    description="Fungible Cluster Services Client Application")

	# Arguments for all sub-functions:
	#
	cmd_parser.add_argument('-c', '--cs-host',
	    type=str,
	    default=os.environ.get('CS_HOST', 'localhost'),
	    help='Fungible Cluster Services Host [env: CS_HOST]')
	cmd_parser.add_argument('-p', '--cs-port',
	    type=int,
	    default=os.environ.get('CS_PORT', 50220),
	    help='TCP Port for Fungible Cluster Services '
		'[default: $CS_PORT]')
	cmd_parser.add_argument('-u', '--cs-user',
	    type=str,
	    default=os.environ.get('CS_USER', 'admin:password'),
	    help='User:Password for accessing Fungible Cluster Services '
		'[default: $CS_USER]')
	cmd_parser.add_argument('-d', '--cs-dpus',
	    type=argparse_type_json_file,
	    default=os.environ.get('CS_DPUS', None),
	    help='JSON File mapping DPU Names to MAC Addresses '
		'[default: $CS_DPUS]')

	cmd_parser.add_argument('-I', '--indent',
	    type=argparse_type_int_none, default=4,
	    help='Pretty printing indentation, default 4, 0 means none')
	cmd_parser.add_argument('-v', '--verbose',
	    action='store_true',
	    help='Display verbose output')
	cmd_parser.add_argument('-n', '--dry-run',
	    action='store_true',
	    help='Just display commands which would have been executed')
	cmd_parser.add_argument('-D', '--debug',
	    action='store_true',
	    help='Debug {} ...'.format(os.path.basename(sys.argv[0])))

	# Add sub-parsers for various sub-commands:
	#
	subcmd_parsers = cmd_parser.add_subparsers()

	# Fungible Cluster Services Docker utility commands.
	#
	#     tc docker start
	#     tc docker stop
	#
	subcmd_docker_parser = subcmd_parsers.add_parser('docker',
	    description='Fungible Cluster Services Docker utility commands')
	subcmd_docker_parsers = subcmd_docker_parser.add_subparsers()

	subcmd_docker_start_parser = subcmd_docker_parsers.add_parser(
	    'start',
	    description='Start Fungible Cluster Services Docker Container')
	subcmd_docker_start_parser.set_defaults(func=subcmd_docker_start)

	subcmd_docker_stop_parser = subcmd_docker_parsers.add_parser(
	    'stop',
	    description='Stop Fungible Cluster Services Docker Container')
	subcmd_docker_stop_parser.set_defaults(func=subcmd_docker_stop)

	# Zero Touch Provisioning commands.
	#
	#     tc ztp <DPU ccLinux> ...
	#
	subcmd_ztp_parser = subcmd_parsers.add_parser('ztp',
	    description='Zero Touch Provisioning for specified DPUs')
	subcmd_ztp_parser.add_argument(
	    '-z', '--ztp-cs-host',
	    type=str,
	    help='Private "South" Virtual IP for Fungible Cluster Services '
		'[default: --cs-host/$CS_HOST, which only works when using '
		'Docker Container deployment]')
	subcmd_ztp_parser.add_argument(
	    'dpus', nargs='+',
	    help='One or more DPU ccLinuxes to Provision')
	subcmd_ztp_parser.set_defaults(func=subcmd_ztp)

	# Virtual PCIe Fabric Manager commands.  Allow alias "vsw".
	#
	subcmd_vfm_parser = subcmd_parsers.add_parser('vfm',
	    aliases=['vsw'],
	    description='Virtual PCIe Fabric Manager commands')
	subcmd_vfm_parsers = subcmd_vfm_parser.add_subparsers()

	# tc vfm create
	#     [ --max-downport-id <n> ]
	#     [ --name <name> ]
	#     <vPortSpec> ...
	#
	subcmd_vfm_create_parser = subcmd_vfm_parsers.add_parser(
	    'create',
	    description='Create Virtual PCIe Fabric')
	subcmd_vfm_create_parser.add_argument(
	    '-M', '--down-port-id-max',
	    type=int,
	    help='Maximum Switch Down Port ID 0..31')
	subcmd_vfm_create_parser.add_argument(
	    '-N', '--name',
	    help='Opaque "name" of Virtual PCIe Fabric')
	subcmd_vfm_create_parser.add_argument(
	    'vportspecs', nargs='+',
	    help='Virtual PCIe Ports in the format "DPU/Portname/vPortID"')
	subcmd_vfm_create_parser.set_defaults(func=subcmd_vfm_create)

	# tc vfm hot-plug <vFabricID> <vPortSpec> ...
	#
	subcmd_vfm_hot_plug_parser = subcmd_vfm_parsers.add_parser(
	    'hot-plug',
	    description='Hot Plug new Ports into a Virtual PCIe Fabric')
	subcmd_vfm_hot_plug_parser.add_argument(
	    'vfabric', type=argparse_type_uuid,
	    help='Virtual PCIe Fabric ID (UUID) to operate on')
	subcmd_vfm_hot_plug_parser.add_argument(
	    'vportspecs', nargs='+',
	    help='Virtual PCIe Ports in the format "DPU/Portname/vPortID"')
	subcmd_vfm_hot_plug_parser.set_defaults(func=subcmd_vfm_hot_plug)

	# tc vfm hot-unplug <vFabricID> <vPortID> ...
	#
	subcmd_vfm_hot_unplug_parser = subcmd_vfm_parsers.add_parser(
	    'hot-unplug',
	    description='Hot Unplug Ports from Virtual PCIe Fabric')
	subcmd_vfm_hot_unplug_parser.add_argument(
	    'vfabric', type=argparse_type_uuid,
	    help='Virtual PCIe Fabric ID (UUID) to operate on')
	subcmd_vfm_hot_unplug_parser.add_argument(
	    'vportids', nargs='+', type=int,
	    help='Virtual PCIe Port IDs in the format "vPortID"')
	subcmd_vfm_hot_unplug_parser.set_defaults(func=subcmd_vfm_hot_unplug)

	# tc vfm delete <vFabricID> ...
	#
	subcmd_vfm_delete_parser = subcmd_vfm_parsers.add_parser(
	    'delete',
	    description='Delete Virtual PCIe Fabric')
	subcmd_vfm_delete_parser.add_argument(
	    'vfabrics', nargs='+', type=argparse_type_uuid,
	    help='Virtual PCIe Fabric ID (UUID) to operate on')
	subcmd_vfm_delete_parser.set_defaults(func=subcmd_vfm_delete)

	# tc vfm dpus
	#
	subcmd_vfm_dpus_parser = subcmd_vfm_parsers.add_parser(
	    'dpus',
	    description='List DPUs')
	subcmd_vfm_dpus_parser.set_defaults(func=subcmd_vfm_dpus)

	# tc vfm vfabrics
	#
	subcmd_vfm_vfabrics_parser = subcmd_vfm_parsers.add_parser(
	    'vfabrics',
	    description='List Virtual PCIe Fabrics')
	subcmd_vfm_vfabrics_parser.set_defaults(func=subcmd_vfm_vfabrics)

	# tc vfm dpu <DPU> ...
	#
	subcmd_vfm_dpu_parser = subcmd_vfm_parsers.add_parser(
	    'dpu',
	    description='List DPU PCIe Ports')
	subcmd_vfm_dpu_parser.add_argument(
	    'dpus', nargs='+',
	    help='DPUs to list Hardware PCIe Ports')
	subcmd_vfm_dpu_parser.set_defaults(func=subcmd_vfm_dpu)

	# tc vfm vfabric <vFabricID> ...
	#
	subcmd_vfm_vfabric_parser = subcmd_vfm_parsers.add_parser(
	    'vfabric',
	    description='List Virtual PCIe Fabric Ports')
	subcmd_vfm_vfabric_parser.add_argument(
	    'vfabrics', nargs='+', type=argparse_type_uuid,
	    help='Virtual PCIe Fabrics to list Virtual PCIe Ports')
	subcmd_vfm_vfabric_parser.set_defaults(func=subcmd_vfm_vfabric)

	# tc vfm enumerate <PortSpec> ...
	#
	subcmd_vfm_enumerate_parse = subcmd_vfm_parsers.add_parser(
	    'enumerate',
	    aliases=['enum'],
	    description='Display DPU PCIe Switch Down Port Enumeration')
	subcmd_vfm_enumerate_parse.add_argument(
	    'portspecs', nargs='+',
	    help='DPU Switch Down Ports in the format "DPU/Portname"')
	subcmd_vfm_enumerate_parse.set_defaults(func=subcmd_vfm_enumerate)

	# tc vfm debug <DPU>
	#     [ --trace-link ]
	#     [ --trace-tlp ]
	#     [ --trace-s2s ]
	#     [ --trace-routing ]
	#
	subcmd_vfm_debug_parser = subcmd_vfm_parsers.add_parser(
	    'debug',
	    description='Manage DPU vSwitch Debug options')
	subcmd_vfm_debug_parser.add_argument(
	    'dpu',
	    help='DPU to operate on')
	subcmd_vfm_debug_parser.add_argument(
	    '--trace-link',
	    type=argparse_type_bool_onoff,
	    help='Trace PCIe Link Events')
	subcmd_vfm_debug_parser.add_argument(
	    '--trace-tlp',
	    type=argparse_type_bool_onoff,
	    help='Trace PCIe Transaction Layer Packets')
	subcmd_vfm_debug_parser.add_argument(
	    '--trace-s2s',
	    type=argparse_type_bool_onoff,
	    help='Trace Switch-to-Switch Messages')
	subcmd_vfm_debug_parser.add_argument(
	    '--trace-routing',
	    type=argparse_type_bool_onoff,
	    help='Trace PCIe Routing Changes')
	subcmd_vfm_debug_parser.set_defaults(func=subcmd_vfm_debug)

	# Simple Network Service commands.
	#
	subcmd_sns_parser = subcmd_parsers.add_parser('sns',
	    description='Simple Network Service commands')
	subcmd_sns_parsers = subcmd_sns_parser.add_subparsers()

	# tc sns dpus
	#
	subcmd_sns_dpus_parser = subcmd_sns_parsers.add_parser(
	    'dpus',
	    description='List all DPUs that SNS knows about, '
		'not just those with Virtual PCIe Switch Ports')
	subcmd_sns_dpus_parser.set_defaults(func=subcmd_sns_dpus)

	# tc sns dpu <DPU> ...
	#
	subcmd_sns_dpu_parser = subcmd_sns_parsers.add_parser(
	    'dpu',
	    description='List information for specific DPUs')
	subcmd_sns_dpu_parser.add_argument(
	    'dpus', nargs='+',
	    help='DPUs to list')
	subcmd_sns_dpu_parser.set_defaults(func=subcmd_sns_dpu)

	# Parse the arguments and execute the indicated sub-command ...
	#
	try:
		args = cmd_parser.parse_args()
	except:
		# The Argument Parser will have already flagged the error,
		# so we can just exit.
		#
		exit(1)

	if args.debug:
		print('args =', args)

	if 'func' not in args:
		cmd_parser.print_help()
		exit(1)

	# I've tried to use try-except here, but every time an actual error
	# occurs, I lose all of the debugging information.  Unfortunately
	# if I don't use try-except, then the user gets the typical horrible
	# Python stack dump. (sigh)  I think that the answer is to use more
	# local error detection and simply exit, rather than raise an
	# error condition.  So for now, no try-except here ...
	#
	args.func(args)

if __name__ == "__main__":
	main()
