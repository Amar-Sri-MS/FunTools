<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="/static/css/index.css">
    <link rel="stylesheet" type="text/css" href="/static/css/logs.css">
    <script>
    /*
     * If you're reading this, Fungible is interested in talking to you
     * because you have skills that we might want. 
     *
     * But if you're reading this, you're already an esteemed colleague so
     * never mind.... 
     */

    /*
     * Client state.
     *
     * The state is opaque to the client. The before and after page markers
     * are hidden in a state object, and the post requests say
     * "next" or "prev" while sending the state object. This allows easier
     * changes if we decide to change our storage/search layer.
     *
     * The internal "before" and "after" variables hold the sort values of
     * the first and last document on the page. These sort values are
     * determined by elasticsearch, and are single integers at the moment
     * because we only sort by timestamp.
     */
    var state = {{state}};

    /*
     * Current message text filter.
     *
     * Value is used as a filter of message contents.
     */
    var textFilter = "";

    /*
     * Holds current message sources.
     */
    var allSources = {{sources}};
    var currentSources = Object.keys({{sources}});

    /*
     * Holds current time filters.
     */
    var startTime = "";
    var endTime = "";
    var loader, selectedFilters, prev_button, next_button;
    var showingSelectedFilters = false;

    window.onload = function() {
        loader = document.getElementById("loader");
        selectedFilters = document.getElementById("selectedFilters");
        prev_button = document.getElementById("prev_button");
        next_button = document.getElementById("next_button");
    }

    function handleSearch(search) {
        window.location.href = `/log/{{log_id}}/search?query=${search}&time_start=${startTime}&time_end=${endTime}`;
    }

    function handleMessageFilter(element) {
        textFilter = element.value;
    }

    function handleMessageTableFilterUpdates() {
        toggleElementDisplay(loader, true);
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var data = JSON.parse(xhttp.responseText);
                if (data) {
                    clearMessageTable();
                    updateMessageTable(data, true);

                    state = data["state"];
                }
                toggleElementDisplay(loader, false);
            }
        }

        var uri = "/log/{{log_id}}/content";

        var filterString = buildFilterOption();
        if (filterString != "") {
            uri += "?filter=" + filterString;
        }

        xhttp.open('POST', uri);
        xhttp.send();
    }

    function clearMessageTable() {
        var table = document.getElementById("line_table");
        table.innerHTML = ""
    }

    function updateMessageTable(filterData, isAppend) {
        var table = document.getElementById("line_table");
        if (isAppend) {
            table.innerHTML = table.innerHTML + filterData["content"];
        } else {
            table.innerHTML = filterData["content"] + table.innerHTML;
        }
        // Conditionally rendering pagination buttons
        var showPrevButton = filterData["state"].before != -1;
        var showNextButton = filterData["state"].after != -1;
        toggleElementDisplay(prev_button, showPrevButton);
        toggleElementDisplay(next_button, showNextButton);
    }

    function handleSourceFilters(element) {
        if (element.checked) {
            currentSources.push(element.value);
        }
        else {
            currentSources = currentSources.filter(source => source !== element.value);
        }
    }

    function handleTimeFilters(element, type="start") {
        if (type === "start") {
            startTime = element.value;
        }
        else {
            endTime = element.value;
        }
    }

    function loadNext() {
        toggleElementDisplay(loader, true);
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var data = JSON.parse(xhttp.responseText);
                if (data) {
                    updateMessageTable(data, true);
                    state = data["state"];
                }
                toggleElementDisplay(loader, false);
            }
        }

        var uri = buildContentRequest("next");
        xhttp.open('POST', uri);
        xhttp.send();
    }

    // Toggle viewing the selected filters
    function toggleSelectedFilters() {
        showingSelectedFilters = !showingSelectedFilters;
        if (showingSelectedFilters) {
            selectedFilters.innerHTML = buildFilterOption();
        }
        toggleElementDisplay(selectedFilters, showingSelectedFilters);
    }

    // Generic function to toggle any HTML element's display property
    function toggleElementDisplay(element, flag) {
        if (flag) {
            element.style = "display: block";
        }
        else {
            element.style = "display: none";
        }
    }

    /*
     * Constructs a POST request to fetch more content.
     *
     * direction is either "next" to fetch content after the last message
     * on the page, or "prev" to fetch content before the first message.
     */
    function buildContentRequest(direction) {
        var uri = "/log/{{log_id}}/content?" + direction + "=true&state=" + JSON.stringify(state);

        var filterString = buildFilterOption();

        if (filterString != "") {
            uri += "&filter=" + filterString;
        }

        return uri;
    }

    /*
     * Constructs a filter string, for use in a request,
     * from current filter values.
     */
    function buildFilterOption() {
        var allFilters = {};
        if (textFilter != "") {
            allFilters["text"] = textFilter;
        }

        allFilters["sources"] = currentSources;

        datetimeFilters = [];
        datetimeFilters.push(startTime);
        datetimeFilters.push(endTime);
        allFilters["time"] = datetimeFilters;

        // Returns a string of a JSON with indentation
        return JSON.stringify(allFilters, null, 4);
    }

    function loadPrev() {
        toggleElementDisplay(loader, true);
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var data = JSON.parse(xhttp.responseText);
                if (data) {
                    updateMessageTable(data, false);
                    state = data["state"];
                }
                toggleElementDisplay(loader, false);
            }
        }

        var uri = buildContentRequest("prev");
        xhttp.open('POST', uri);
        xhttp.send();
    }

    </script>
</head>
<body>
    {% include 'nav_bar.html' ignore missing %}
    <!-- Calculating total log entries -->
    {% set totalEntries = sources.values()|sum() %}
    <h2 id="top">Logs for {{log_id}} ({{totalEntries}} log entries)</h2>
    <div class="navbar">
        <div class="search_box">
            <input id="search" type="search" placeholder="Search..."/>
            <button onclick="handleSearch(document.getElementById('search').value)">Search</button>
        </div>
        <div class="search_results" id="search_results">
        </div>
    
        <div class="filters">
            <label for="text_filter">Enter text to filter logs</label>
            <input id="text_filter" type="search" placeholder="Filter..." onkeypress="handleMessageFilter(this)" />
        </div>

        <div class="filters">
            {% for source in sources %}
            <input type="checkbox" id="src_{{source}}" value="{{source}}" checked onchange="handleSourceFilters(this)"/>
            <!-- Displaying log entries (along with the name of source) in % with rounded off to 2 decimals -->
            <label class="checkbox_label" for="src_{{source}}">{{source}} ({{((sources[source]/totalEntries)*100)|round(2)}}% entries)</label>
            {% endfor %}
        </div>

        <div class="filters">
            <label for="dt_start">Enter start time</label>
            <input type="datetime-local" id="dt_start" onchange="handleTimeFilters(this, 'start')"/>
            <label for="dt_end">Enter end time</label>
            <input type="datetime-local" id="dt_end" onchange="handleTimeFilters(this, 'end')"/>
        </div>
        <div class="filters_button">
            <button onclick="handleMessageTableFilterUpdates()">Filter logs</button>
        </div>
    </div>

    <button onclick="toggleSelectedFilters()">Show/Hide selected filters</button>
    <div id="selectedFilters">No filters selected</div>

    <div class="file_contents">
        <div class="pagination" id="prev_button">
            <button onclick="loadPrev()">Load previous logs</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Source</th>
                    <th>Timestamp</th>
                    <th>Log message</th>
                </tr>
            </thead>
            <tbody id="line_table">
                {{body}}
            </tbody>
        </table>
        <div class="pagination" id="next_button">
            <button onclick="loadNext()">Load next logs</button>
        </div>
    </div>
    <div id="top_button">
        <a href="#top">Jump to top of page</a>
    </div>
    <div id="loader">
        <svg version="1.1" id="L6" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
            viewBox="0 0 100 100" enable-background="new 0 0 100 100" xml:space="preserve">
            <rect fill="none" stroke="#000" stroke-width="4" x="25" y="25" width="50" height="50">
            <animateTransform
                attributeName="transform"
                dur="0.5s"
                from="0 50 50"
                to="180 50 50"
                type="rotate"
                id="strokeBox"
                attributeType="XML"
                begin="rectBox.end"/>
            </rect>
            <rect x="27" y="27" fill="#000" width="46" height="50">
            <animate
                attributeName="height"
                dur="1.3s"
                attributeType="XML"
                from="50"
                to="0"
                id="rectBox"
                fill="freeze"
                begin="0s;strokeBox.end"/>
            </rect>
        </svg>
    </div>
</body>
</html>
