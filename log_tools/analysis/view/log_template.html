<!DOCTYPE html>
<html>
<head>
    <style>
    .navbar {
    }
    .pagination {
        margin: auto;
        text-align: center;
    }
    .file_contents {
        display: block;
        font-family: monospace;
        white-space: pre;
    }
    .search_highlight {
        background-color: yellow;
    }
    .checkbox_label {
        padding-right: 15px;
    }
    td {
        white-space: nowrap;
        border-collapse: collapse;
        padding-right: 5px
    }
    </style>

    <script>
    /*
     * If you're reading this, Fungible is interested in talking to you
     * because you have skills that we might want. 
     *
     * But if you're reading this, you're already an esteemed colleague so
     * never mind.... 
     */

    /*
     * Client state.
     *
     * The state is opaque to the client. The before and after page markers
     * are hidden in a state object, and the post requests say
     * "next" or "prev" while sending the state object. This allows easier
     * changes if we decide to change our storage/search layer.
     *
     * The internal "before" and "after" variables hold the sort values of
     * the first and last document on the page. These sort values are
     * determined by elasticsearch, and are single integers at the moment
     * because we only sort by timestamp.
     */
    var state = {{state}};

    /*
     * Current message text filter.
     *
     * Value is used as a filter of message contents.
     */
    var textFilter = "";

    /*
     * Holds current message sources
     */
    var allSources = {{sources}};
    var currentSources = {{sources}};

    function handleSearch(search) {
        window.location.href = '/log/{{log_id}}/search?query=' + search;
    }

    function handleMessageFilter(filter) {
        textFilter = filter;

        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var data = JSON.parse(xhttp.responseText);
                if (data) {
                    clearMessageTable();
                    updateMessageTable(data, true);

                    state = data["state"];
                }
            }
        }

        var uri = "/log/{{log_id}}/content";

        var filterString = buildFilterOption();
        if (filterString != "") {
            uri += "?filter=" + filterString;
        }

        xhttp.open('POST', uri);
        xhttp.send();
    }

    function clearMessageTable() {
        var table = document.getElementById("line_table");
        table.innerHTML = ""
    }

    function updateMessageTable(filterData, isAppend) {
        var table = document.getElementById("line_table");
        if (isAppend) {
            table.innerHTML = table.innerHTML + filterData["content"];
        } else {
            table.innerHTML = filterData["content"] + table.innerHTML;
        }
    }

    function handleSourceFilters() {
        currentSources = [];
        allSources.forEach(function(source, index) {
            var elementId = "src_" + source;
            var element = document.getElementById(elementId);
            if (element.checked) {
                currentSources.push(element.value);
            }
        });

        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var data = JSON.parse(xhttp.responseText);
                if (data) {
                    clearMessageTable();
                    updateMessageTable(data, true);

                    state = data["state"];
                }
            }
        }

        var filterString = buildFilterOption();

        var uri = "/log/{{log_id}}/content";
        uri += "?filter=" + filterString;
        xhttp.open('POST', uri);
        xhttp.send();
    }

    function loadNext() {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var data = JSON.parse(xhttp.responseText);
                if (data) {
                    updateMessageTable(data, true);
                    state = data["state"];
                }
            }
        }

        var uri = buildContentRequest("next");
        xhttp.open('POST', uri);
        xhttp.send();
    }

    /*
     * Constructs a POST request to fetch more content.
     *
     * direction is either "next" to fetch content after the last message
     * on the page, or "prev" to fetch content before the first message.
     */
    function buildContentRequest(direction) {
        var uri = "/log/{{log_id}}/content?" + direction + "=true&state=" + JSON.stringify(state);

        var filterString = buildFilterOption();

        if (filterString != "") {
            uri += "&filter=" + filterString;
        }

        return uri;
    }

    /*
     * Constructs a filter string, for use in a request,
     * from current filter values.
     */
    function buildFilterOption() {
        var allFilters = {};
        if (textFilter != "") {
            allFilters["text"] = textFilter;
        }

        allFilters["sources"] = currentSources;

        return JSON.stringify(allFilters);
    }

    function loadPrev() {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var data = JSON.parse(xhttp.responseText);
                if (data) {
                    updateMessageTable(data, false);
                    state = data["state"];
                }
            }
        }

        var uri = buildContentRequest("prev");
        xhttp.open('POST', uri);
        xhttp.send();
    }

    </script>
</head>
<body>
    <h2>Logs for {{log_id}}</h2>
    <div class="navbar">
        <div class="search_box">
            <input id="search" type="search" placeholder="Search..."/>
            <button onclick="handleSearch(document.getElementById('search').value)">Search</button>
        </div>
        <div class="search_results" id="search_results">
        </div>
    
        <div class="filters">
            <input id="text_filter" type="search" placeholder="Filter..."/>
            <button onclick="handleMessageFilter(document.getElementById('text_filter').value)">Filter Message</button>
        </div>

        <div class="filters">
            {% for source in sources %}
            <input type="checkbox" id="src_{{source}}" value="{{source}}" checked/>
            <label class="checkbox_label" for="src_{{source}}">{{source}}</label>
            {% endfor %}
            <button onclick="handleSourceFilters()">Filter Sources</button>
        </div>
    </div>

    <div class="file_contents">
        <div class="pagination">
            <button id="prev_button" onclick="loadPrev()">Load previous</button>
        </div>
        <table id="line_table">
{{body}}
        </table>
        <div class="pagination">
            <button id="next_button" onclick="loadNext()">Load next</button>
        </div>
    </div>

</body>
</html>
