#!/usr/bin/env python2.7

#
# Reads in a JSON file containing performance-related data generated by
# parse_funos_log.py and writes charts for use by Plot.ly (in JSON format).
#
# See parse_funos_log.py for the input JSON format.
#
# Usage: create_charts.py <input_file> [-o <output_file>]
#

import re
import json
import argparse


# These constants were cribbed from nucleus/topology.h in FunOS code
VPS_PER_CORE = 4
VP_BASE = 8


def faddr_to_ccv_id(f_addr):
    """
    Converts a fabric address to a CCV (cluster.core.vp) id.
    This is a direct translation of the code in topo_cc_from_faddr()
    in nucleus/topology.h.
    :param f_addr:
    :return: CCV id
    """
    lid = f_addr['lid']
    cluster = f_addr['gid']
    core = (lid - VP_BASE) / VPS_PER_CORE
    vp = (lid - VP_BASE) % VPS_PER_CORE
    return '%s.%s.%s' % (cluster, core, vp)


def _extract_bar_chart_data(metric_name, json_data):
    """
    Extracts the data for metric_name and converts it into
    a data structure that the plot.ly library expects for
    bar chart data.
    :param metric_name:
    :param json_data:
    :return: bar chart data suitable for plotly
    """
    x = [faddr_to_ccv_id(s['faddr']) for s in json_data]
    y = [s[metric_name] for s in json_data]
    data = [{
        'x': x,
        'y': y,
        'type': 'bar',
    }]
    return data


def _write_to_file(charts, out_file):
    res = json.dumps(charts)
    out_file.write(res)


def _build_chart(metric_name, json_data):
    """
    Builds a chart for metric_name from the data and returns it.
    :param metric_name:
    :param json_data:
    :return: chart
    """
    chart = dict()
    chart['data'] = _extract_bar_chart_data(metric_name, json_data)
    chart['layout'] = _get_precanned_layout(metric_name)
    return chart


# Kind of lame: this are the title lookups for stat_name
_PRECANNED_TITLES = {
    'util_pct': '% util by VP',
    'wus_sent': 'Count of sent WUs',
    'wus_recvd': 'Count of received WUs',
}


_PRECANNED_Y_TITLES = {
    'util_pct': '% util',
    'wus_sent': 'WU count',
    'wus_recvd': 'WU count',
}


def _get_precanned_layout(stat_name):
    title = stat_name
    if stat_name in _PRECANNED_TITLES:
        title = _PRECANNED_TITLES[stat_name]

    yaxis_title = ''
    if stat_name in _PRECANNED_Y_TITLES:
        yaxis_title = _PRECANNED_Y_TITLES[stat_name]

    return {
        'title': title,
        'xaxis': {
            'title': 'CCV (cluster.core.vp)'
        },
        'yaxis': {
            'title': yaxis_title
        },
    }


def _get_metric_names(json_data):
    """
    Extracts metric names from the first entry in the input list,
    assuming metrics are uniform across all entries.
    :param json_data:
    :return: metric names
    """
    if json_data:
        names = json_data[0].keys()
        names.remove('faddr')
        return names
    else:
        return []


def produce_summary_charts(in_file, out_file):
    charts = {}
    contents = in_file.read()
    json_data = json.loads(contents)
    for metric_name in _get_metric_names(json_data):
        chart = _build_chart(metric_name, json_data)
        charts[metric_name] = chart

    _write_to_file(charts, out_file)


def main():
    parse = argparse.ArgumentParser()
    parse.add_argument('input_file', type=str,
                       help='JSON file containing performance data')
    parse.add_argument('-o,', '--output_file', type=str,
                       help='path to the output file',
                       default='summary_charts.json')
    args = parse.parse_args()

    with open(args.input_file, 'r') as in_file, \
            open(args.output_file, 'w') as out_file:
        produce_summary_charts(in_file, out_file)


if __name__ == '__main__':
    main()
