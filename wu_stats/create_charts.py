#!/usr/bin/env python3

#
# Reads in a JSON file containing performance-related data generated by
# parse_funos_log.py and writes charts for use by Plot.ly (in JSON format).
#
# See parse_funos_log.py for the input JSON format. The output format is
# {
#     metricA:
#     {
#         layout: { <plot.ly layout> }
#         data:
#         [
#             {
#                 y: [ <y-data> ]
#                 x: [ <x-data> ]
#             }
#         ]
#     }
#     metricB: ...
# }
#
# Usage: create_charts.py <input_file> [-o <output_file>]
#
# Copyright (c) 2019 Fungible Inc.  All rights reserved.
#

import argparse
import json
import sys


# These constants were cribbed from nucleus/topology.h and
# nucleus/fabric_address.h in FunOS code.
MAX_VPS_PER_CORE = 4
LID_VP_BASE = 8


def faddr_to_ccv_id(f_addr):
    """
    Converts a fabric address to a CCV (cluster.core.vp) id.

    This is a direct translation of topo_ccv_from_faddr()
    in nucleus/topology.h.

    :param f_addr:
    :return: CCV id
    """
    lid = f_addr['lid']
    cluster = f_addr['gid']
    core = (lid - LID_VP_BASE) / MAX_VPS_PER_CORE
    vp = (lid - LID_VP_BASE) % MAX_VPS_PER_CORE
    return '%s.%s.%s' % (cluster, core, vp)


def _build_bar_chart(metric_name, json_data):
    """ Builds a bar chart for metric_name. """
    chart = dict()
    chart['data'] = _extract_bar_chart_data(metric_name, json_data)
    chart['layout'] = _get_precanned_layout(metric_name)
    return chart


def _extract_bar_chart_data(metric_name, json_data):
    """
    Formats the data for the specified metric into a bar chart
    data series for plot.ly
    """
    x = [faddr_to_ccv_id(s['faddr']) for s in json_data]
    y = [s[metric_name] for s in json_data]
    data = [{
        'x': x,
        'y': y,
        'type': 'bar',
    }]
    return data


# Kind of lame: this are the title lookups for stat_name
_PRECANNED_TITLES = {
    'util_pct': '% util by VP',
    'wus_sent': 'Count of sent WUs',
    'wus_recvd': 'Count of received WUs',
}


_PRECANNED_Y_TITLES = {
    'util_pct': '% util',
    'wus_sent': 'WU count',
    'wus_recvd': 'WU count',
}


def _get_precanned_layout(stat_name):
    title = stat_name
    if stat_name in _PRECANNED_TITLES:
        title = _PRECANNED_TITLES[stat_name]

    yaxis_title = ''
    if stat_name in _PRECANNED_Y_TITLES:
        yaxis_title = _PRECANNED_Y_TITLES[stat_name]

    return {
        'title': title,
        'xaxis': {
            'title': 'CCV (cluster.core.vp)'
        },
        'yaxis': {
            'title': yaxis_title
        },
    }


def _write_to_file(charts, out_file):
    res = json.dumps(charts)
    out_file.write(res)


def _get_metric_names(json_data):
    """
    Extracts metric names from the first entry in the input data.

    Assumes metrics are uniform across all entries.
    """
    if json_data:
        names = list(json_data[0].keys())
        names.remove('faddr')
        return names
    else:
        return []


def produce_summary_charts(in_fh, out_fh):
    """
    Reads in_fh (handle) and writes the resulting charts
    to out_fh (handle).

    If the input file contents are empty this prints a message
    to stderr and exits with error code 1.

    :param in_fh: a handle to the input file
    :param out_fh: a handle to the output file
    """
    charts = {}
    contents = in_fh.read()
    if not contents:
        sys.stderr.write('Empty input to create_charts: '
                         'probably a failed FunOS run.\n')
        sys.exit(1)

    json_data = json.loads(contents)
    for metric_name in _get_metric_names(json_data):
        chart = _build_bar_chart(metric_name, json_data)
        charts[metric_name] = chart

    _write_to_file(charts, out_fh)


def main():
    parse = argparse.ArgumentParser()
    parse.add_argument('input_file', type=str,
                       help='JSON file containing performance data')
    parse.add_argument('-o,', '--output_file', type=str,
                       help='path to the output file',
                       default='summary_charts.json')
    args = parse.parse_args()

    with open(args.input_file, 'r') as in_file, \
            open(args.output_file, 'w') as out_file:
        produce_summary_charts(in_file, out_file)


if __name__ == '__main__':
    main()
