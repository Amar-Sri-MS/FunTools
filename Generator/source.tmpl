{# 

Standard Fungible template for source code for generated structures.

#}
// Source file created by generator.py
// Do not change this file;
// change the gen file {{gen_file}} instead.

/* For FunOS and CC-Linux. */
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "{{output_base}}.h"

{% for enum in enums %}
const char *{{enum.name | as_lower}}_names[] = {
      {% for i in range(0, enum.last_value + 1) %}
      "{{enum.NameForValue(i)}}",  /* {{i|as_hex}} */
      {% endfor %}
};

{% endfor %}

{% for flagset in flagsets %}
const char *{{flagset.name | as_lower }}_names[] = {
  {% for var in flagset.VariablesWithNames() %}
    "{{var.name}}", /* {{var.value | as_hex}} */
  {% endfor %}
};

{% endfor %}

{% if generate_json %}
{% for struct in structs %}

/*
 * Initializes {{struct.name}} structure from JSON representation.
 * Returns false if initialization failed.
 * Caller responsible for determining correct init function(s).
 */
bool {{struct.name}}_json_init(struct fun_json *arg,
				{{struct.DeclarationString()}} *s)
{
	bool __attribute__ ((unused)) dict = false;
	int ai = 0;
	struct fun_json __attribute__ ((unused)) *j = arg;

	switch (arg->type) {
	case fun_json_array_type:
		{
			/* top level ? check if 1st item is dict */
			struct fun_json *first_item =
					fun_json_array_at(arg, ai);
			if (first_item->type == fun_json_dict_type) {
				dict = true;
				j = first_item;
			}
		}
		break;
	case fun_json_dict_type:
		dict = true;
		break;
	}

	memset(s, 0, sizeof({{struct.DeclarationString()}}));
{% for field in struct.fields %}
 {% if field.is_reserved == false %}
  {% if field.type.IsArray() %}
    {% if field.type.ArraySize() > 0 %}

	struct fun_json *{{field.name}}_j = (dict)
				? fun_json_lookup(j, "{{field.name}}")
				: fun_json_array_at(j, ai++);
	if ({{field.name}}_j) {
		assert({{field.name}}_j->array->count <= {{field.type.ArraySize()}});
		for (int i = 0; i < {{field.name}}_j->array->count; i++) {
			s->{{field.name}}[i] = {{field.name}}_j->array->items[i]->int_value;
		}
	}
    {% endif %}
  {% elif field.type.IsRecord() %}
    {% if field.type.base_type.node.is_union %}

	/* TBD - Union - {{field.name}} */
    {% else %}

	struct fun_json *{{field.name}}_j = (dict)
				? fun_json_lookup(j, "{{field.name}}")
				: fun_json_array_at(j, ai++);
	/* TBD - Struct - {{field.name}} */
	{{field.type.base_type.node.name}}_json_init({{field.name}}_j, &(s->{{field.name}}));
    {% endif %}
  {% else %}
    {% if field.packed_fields %}

	struct fun_json *{{field.name}}_j = (dict)
				? fun_json_lookup(j, "{{field.name}}")
				: fun_json_array_at(j, ai++);
	/* TBD - sub-field {{field.name}} */
	if ({{field.name}}_j) {
		s->{{field.name}} = {{field.name}}_j->int_value;
	}
    {% else %}

	struct fun_json *{{field.name}}_j = (dict)
				? fun_json_lookup(j, "{{field.name}}")
				: fun_json_array_at(j, ai++);
	if ({{field.name}}_j) {
		s->{{field.name}} = {{field.name}}_j->int_value;
	}
    {% endif %}
  {% endif %}
 {% endif %}
{% endfor %}

	return true;
}

{% endfor %}
{% endif %}
