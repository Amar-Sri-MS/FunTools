{#

Standard Fungible template for header file for generated structures.
Generates structures, accessor macros and functions, and enum declarations.

#}
// Header created by generator.py
// Do not change this file;
// change the gen file "{{gen_file}}" instead.

// Magic number to allow checking whether two interfaces were generated
// from the same sources.
#define {{gen_file|as_macro}}_VERSION_HASH {{gen_file_version_hash}}

{#

How to render each enum.

#}
{% macro enumDecl(enum) %}
{{enum.body_comment|as_comment}}
enum {{enum.name}} {  {{enum.key_comment|as_comment}}
{% for enum_variable in enum.variables %}
{{enum_variable.body_comment|as_comment}} {{enum_variable.name}} = {{enum_variable.value|as_hex}},  {{enum_variable.key_comment|as_comment}}
{% endfor %}{{enum.tail_comment|as_comment}}
 {{enum.name}}_max_value = {{enum.last_value|as_hex}}
};

/* Human-readable strings for enum values in {{enum.name}}. */
extern const char *{{enum.name|as_lower}}_names[];
{%- endmacro %}
{#

How to render each flagset.

#}
{% macro flagsetDecl(flagset) %}
/*
 * Declarations for flag set {{flagset.name}}.
  */
  {% if flagset.key_comment %}{{flagset.key_comment|as_comment}}{% endif %}
  {% if flagset.body_comment %}{{flagset.body_comment|as_comment}}{% endif %}
  {% for var in flagset.variables %}
    {% if var.body_comment %}{{var.body_comment|as_comment}}{% endif %}
static const unsigned int {{var.name}} = {{var.value|as_hex}};  {{var.key_comment|as_comment}}
  {% endfor %}

  /* String names for all power-of-two flags in {{flagset.name}}. */
extern const char *{{flagset.name|as_lower}}_names[];
{%- endmacro %}

{# How to render each CONST #}
{% macro constDecl(const) %}
/*
 * Declarations for constants {{const.name}}.
 *
 */
{% if const.key_comment %}{{const.key_comment|as_comment}}{% endif %}
{% if const.body_comment %}{{const.body_comment|as_comment}}{% endif %}
enum {{const.name}} {
{% for var in const.variables %}
  {% if var.body_comment %}{{var.body_comment|as_comment}}{% endif %}
 {{var.name}} = {{var.value|as_hex}}, {{var.key_comment|as_comment}}
{% endfor %}
{{const.tail_comment|as_comment}}
};
{%- endmacro %}

{#

How to render each struct

#}
{% macro structDecl(struct) %}
{# Note: The structure declarations with containing unions are too complex
   to generate in templates, so do that work in code instead.
#}
{% if not struct.inline %}
{{ struct | as_definition }}{% if generate_cpacked %} __attribute__((packed)){% endif %};
{% if struct.is_struct %}
static_assert(sizeof(struct {{struct.name}}) == {{ (struct.BitWidth() / 8) | int }}, "{{struct.name}} not well aligned");
{% endif %}
{% endif %}

{# Generate macros for packed fields. #}
{% for field in struct.fields %}
   {% if field.packed_fields %}
     {% for f in field.packed_fields %}
       {% if f.is_reserved == false %}
/* Offset of field "{{f.name}}" in packed field "{{field.name}}" */
#define {{struct.name|as_macro}}_{{f.name|as_macro}}_S {{f.shift()}}

/* Mask of field "{{f.name}}" in packed field "{{field.name}}"
   after shift. */
#define {{struct.name|as_macro}}_{{f.name|as_macro}}_M {{f.mask}}

/* Shifts a value to the location to be inserted in field {{f.name}}
 * inside packed field {{field.name}}.
*/
#define {{struct.name|as_macro}}_{{f.name|as_macro}}_P(x) (({{field.type | as_cast}} x) << {{struct.name|as_macro}}_{{f.name|as_macro}}_S)

/* Returns value for field {{field.name}} from packed field
 * {{field.name}}.
 */
#define {{struct.name|as_macro}}_{{f.name|as_macro}}_G(x) (((x) >> {{struct.name|as_macro}}_{{f.name|as_macro}}_S) & {{struct.name|as_macro}}_{{f.name|as_macro}}_M)

/* Clears out the field {{f.name}} inside packed field
 *  {{field.name}}
 *  Usage:
 *    x.{{field.name}} &= {{struct.name|as_macro}}_{{f.name|as_macro}}_Z;
 */
#define {{struct.name|as_macro}}_{{f.name|as_macro}}_Z \
	(~(({{f.type|as_cast}} {{struct.name|as_macro}}_{{f.name|as_macro}}_M)\
       << {{struct.name|as_macro}}_{{f.name|as_macro}}_S))
      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

/* Initializes the {{struct.name}} structure.
 * Arguments:
 *   s: pointer to structure to be initialized.
   {% for field in struct.arg_fields() %}
 *   {{field.name}}: {% if field.key_comment %} {{field.key_comment|as_line}} {% else %} {% endif %}

   {% endfor %}

{% if struct.non_arg_fields() | length > 0 %}
 * Caller responsible for initializing these fields:
     {% for f in struct.non_arg_fields() %}{% if not f.is_reserved %}
 *   {{f.name}}
     {% endif %}{% endfor %}
{% endif %}
 */
static inline void {{struct.name}}_init(struct {{struct.init_struct().name}} *s{%if struct.arg_fields() %},
{% for field in struct.arg_fields() %}
  {{field | as_declaration }} {{ ", " if not loop.last }} {% endfor %}{% endif %}) {

  {% for field in struct.init_fields() %}
    {% if field.packed_fields %}
      s->{{field.init_accessor()}}{{field.name}} =
      {% for f in field.fields_to_set() %}
	{{f.parent_struct.name|as_macro}}_{{f.name|as_macro}}_P({{f.name}}) {{" | " if not loop.last }}
      {% endfor %}
	;
    {% else %}
      {% if field.is_natural_width %}
        s->{{field.init_accessor()}}{{field.name}} = {{field.name}};
      {% else %}
        /* Potential bug? Field isn't as wide as type. */
        s->{{field.init_accessor()}}{{field.name}} = {{field.name}};
      {% endif %}
    {% endif %}
  {% endfor %}
}

{% if generate_json %}
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Initializes {{struct.name}} structure from JSON representation.
 * Returns false if initialization failed.
 * Caller responsible for determining correct init function(s).
 */
extern bool {{struct.name}}_json_init(struct fun_json *j, {{struct.DeclarationString()}} *s);

/*
 * Returns JSON schema for {{struct.name}} structure.
 */
extern const char *{{struct.name}}_json_schema();

#ifdef __cplusplus
}
#endif
{% endif %}

{#
/* TODO(bowdidge): This implementation of swap is disabled.  Turn it on
 * if it'll be useful for someone.
 */

/* Swaps the endianness of the structure {{struct.name}} in memory.
 * This function is a no-op if __DPU_BYTEORDER_BIG matches the current
 * endianness of the processor.
 *  Arguments:
 *    s: structure to be swapped.
 */
static inline void {{struct.name}}_swap(struct {{struct.init_struct().name}} *s) {
       {% for field in struct.fields %}
       {% if field.type.IsArray() %}
       {% if field.type.ArraySize() == 0) %}
       /* Caller responsible for fixing variable length array {{field.name}} */
       {% else %}
       for (int i=0; i < {{field.type.ArraySize()}}; i++) {
           /* TODO(bowdidge): Should be size of elements. */
           s->{{field.name}}[i] = cpu_to_dpu{{field.type.base_type.bit_width}}(s->{{field.name}}[i]);
       }
       {% endif %}
       {% elif field.type.IsRecord() %}
       {{field.type.BaseName()}}_swap(&(s->{{field.name}}));
       {% else %}
       s->{{field.name}} = cpu_to_dpu{{field.type.bit_width}}(s->{{field.name}});
       {% endif %}
       {% endfor %}
}
#}

/* End of helper macros for structure {{struct.name}} */
{%- endmacro %}
{#

The body of the header.

#}

#ifndef __{{output_base|as_macro}}_H__
#define __{{output_base|as_macro}}_H__

// TODO(bowdidge): Consider removing init functions with no arguments.
#if !defined(_WIN32)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif

{% if generate_json %}
#include <stdint.h> /* For basic integer types. */

#include <FunOS/utils/threaded/fun_json.h>
{% endif %}

{% for decl in declarations %}
{% if decl.is_enum %}
 {{ enumDecl(decl) }}
{% endif %}
{% if decl.is_flagset %}
  {{ flagsetDecl(decl) }}
{% endif %}
{% if decl.is_const %}
  {{ constDecl(decl) }}
{% endif %}
{% if decl.is_struct and not decl.is_inline %}
  {{ structDecl(decl) }}
{% endif %}

{% endfor %}

#if !defined(_WIN32)
#pragma GCC diagnostic pop
#endif

#endif // __{{output_base|as_macro}}_H__

