#!/usr/bin/env python3

"""Check SDK APIs documentation generations

   Copyright (c) 2023 Fungible. All rights reserved.

    Preconditions
    -------------
    This script uses inputs of an api summary (--sdk_api) and a function coverage summary (--cov) generated by gcovr.

    Examples
    --------

    >>> python ./check_sdk_api_doc_gen.py

    Test
    -----
    >>> pytest tests/test_check_sdk_api_doc_gen.py -o log_cli=true

    Checks
    ------
    static check:
    >>> mypy ./check_sdk_api_doc_gen.py

    format:
    >>> black ./check_sdk_api_doc_gen.py

"""

"""
TODO
----

- 

"""

import os
import argparse
import sys
import json
from typing import Iterable, Any, List, Optional, Union, Callable, TextIO, Dict, Tuple
import glob
from bs4 import BeautifulSoup

try:
    import pandas as pd
except ImportError:
    print("{}: Import failed!".format(__file__))
    print("Install missing modules")
    print(">>> pip install pandas")
    sys.exit()


def _get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()

    parser.add_argument("--output_dir", type=str, default=".", help="Output directory")

    parser.add_argument(
        "--output_json",
        type=str,
        default="sdk_api_doc_gen_report.json",
        help="Output json file",
    )

    parser.add_argument(
        "--api_doc_gen_dir",
        type=str,
        default="../../FunSDK/FunDoc/html/FunOS/headers",
        help="Generated doc (html) directory",
    )

    parser.add_argument(
        "--sdk_dir",
        type=str,
        default="../../FunSDK",
        help="SDK directory",
    )

    args = parser.parse_args()
    return args


def extract_func_name(proto_str: str) -> str:
    """extract function name from proto string

    Parameters
    ----------
    proto_str : str
        function prototype string

    Returns
    -------
    str: function name
    """
    name = proto_str.split("(")[0].split(" ")[-1]
    # remove leading '*' if exists
    name = name[1:] if name.startswith("*") else name
    return name


def extract_api_from_html(soup):
    """extract api from html file

    Parameters
    ----------
    soup : BeautifulSoup
        bs4

    Returns
    -------
    List[str]: api list

    """
    keys = []
    for dl in soup.findAll("dl", {"class": "c function"}):
        for dt in dl.findAll("dt"):
            proto_name = extract_func_name(dt.text.strip())
            keys.append(proto_name)
        # skip collection dscription
        if False:
            for dd in dl.findAll("dd"):
                values.append(dd.text.strip())
    return keys


def trim_filename(filename: str, n_path: int) -> str:
    """trim filename

    Parameters
    ----------
    filename : str
        filename

    n_path: str
        number of path to trim

    Returns
    -------
    str: trimmed filename
    """
    filename = "FunOS/" + "/".join(filename.split("/")[n_path:])[:-5]
    return filename


api_table_list = []


def extrac_api_info(header_search_path: str):
    """Extract API information by loading html files from the given path


    Parameters
    ----------
    header_search_path : str
        path to search for html files

    Returns
    -------
    List[Dict]: list of API information

    """

    html_files = glob.glob(f"{header_search_path}/**/*.html", recursive=True)
    n_path = len(header_search_path.split("/"))

    for html_file in html_files[1:]:
        if "index.html" in html_file:
            continue
        # read html file
        with open(html_file, "r") as f:
            html = f.read()
            soup = BeautifulSoup(html, features="html.parser")
            proto_names = extract_api_from_html(soup)
            filename = trim_filename(html_file, n_path)
            for proto_name in proto_names:
                d = {
                    "proto_name": proto_name,
                    "filename": filename,
                    "combined_api": f"{proto_name}:{filename}",
                }
                api_table_list.append(d)

    return api_table_list


def diff_sdk_api_doc_gen_per_api(
    in_per_file_list: str = "per_file_all.csv",
    header_search_path: str = "../../FunSDK/FunDoc/html/FunOS/headers",
) -> Tuple[float, pd.DataFrame]:
    """Find out the undocumented APIs

    Parameters
    ----------
    in_per_file_list : str, optional
        input csv file, by default "per_file_all.csv"

    header_search_path : str, optional
        path to search for html files, by default "../../FunSDK/FunDoc/html/FunOS/headers"

    Returns
    -------
    percentage: float
        percentage of documented APIs

    df_api_extracted: pd.DataFrame
        dataframe of APIs documentation
    """

    def check_api_is_documented(df_doc_gen: pd.DataFrame, combined_api: str) -> bool:
        """Check if api is documented"""
        return not df_doc_gen[(df_doc_gen["combined_api"] == combined_api)].empty

    df_api_extracted = pd.read_csv(in_per_file_list)
    df_api_extracted["combined_api"] = (
        df_api_extracted["proto_name"] + ":" + df_api_extracted["filename"]
    )

    api_table_list = extrac_api_info(header_search_path)
    df_api_doc_gen = pd.DataFrame(api_table_list)

    df_api_extracted["is_documented"] = df_api_extracted["combined_api"].apply(
        lambda x: check_api_is_documented(df_api_doc_gen, x)
    )

    percentage = df_api_extracted["is_documented"].sum() / len(df_api_extracted) * 100
    return percentage, df_api_extracted


def load_sdk_file_summary_using_csv(
    in_per_file_list: str = "per_file_all.csv",
) -> pd.DataFrame:
    """load sdk file summary by using the pre-generated csv file

    Returns
    -------
    df: pd.DataFrame
        A dataframe of SDK API per file summary
    """

    df = pd.read_csv(in_per_file_list)

    # select unique values from a column with filename
    sdk_file_df = pd.DataFrame(df["filename"].unique())

    # set the column name to be "filename"
    sdk_file_df.columns = ["filename"]

    return sdk_file_df


def load_sdk_file_summary_counting_sdk_headers(
    sdk_dir: str, sdk_header_dir: str
) -> pd.DataFrame:
    """load sdk file summary by counting the number of headder files in SDK directory

    Returns
    -------
    df: pd.DataFrame
        A dataframe of SDK API per file summary
    """

    header_search_path = f"{sdk_dir}/{sdk_header_dir}"
    # check if the path is connect
    if not os.path.exists(header_search_path):
        print(f"{header_search_path} does not exist")
        sys.exit()

    n_path = len(header_search_path.split("/"))

    header_path = f"{header_search_path}/**/*.h"

    header_files = glob.glob(header_path, recursive=True)

    file_names = []
    for file in header_files:
        # remove index.html
        if "index.html" in file:
            continue
        # rearrange file path to be relative to FunOS so that it can be eaily compared with the SDK file list
        file_name = "FunOS/" + "/".join(file.split("/")[n_path:])
        file_names.append(file_name)
    return pd.DataFrame(file_names, columns=["filename"])


def load_sdk_file_summary(
    sdk_dir: str = "../../FunSDK", sdk_header_dir: str = "FunSDK/funosrt/include/FunOS"
) -> pd.DataFrame:

    # by counting the number of headder files in SDK directory
    return load_sdk_file_summary_counting_sdk_headers(sdk_dir, sdk_header_dir)


def load_sdk_api_doc_gen_summary(
    html_search_path: str = "../../FunSDK/FunDoc/html/FunOS/headers",
) -> pd.DataFrame:
    """load sdk API doc generation summary

    Parameters
    ----------
    html_search_path: str
        A path to search for html files from the point of the current directory

    Returns
    -------
    df: pd.DataFrame
        A dataframe of SDK API doc generation summary
    """

    if not os.path.exists(html_search_path):
        print(f"{html_search_path} does not exist")
        sys.exit()

    html_path = f"{html_search_path}/**/*.html"

    n_path = len(html_search_path.split("/"))

    html_files = glob.glob(html_path, recursive=True)

    file_names = []
    for file in html_files:
        # remove index.html
        if "index.html" in file:
            continue
        # rearrange file path to be relative to FunOS so that it can be eaily compared with the SDK file list
        file_name = "FunOS/" + "/".join(file.split("/")[n_path:])
        file_names.append(file_name[:-5])  # -5 to remove '.html'
    return pd.DataFrame(file_names, columns=["filename"])


def diff_sdk_api_doc_gen_per_file(
    sdk_file_df: pd.DataFrame, sdk_gen_doc_df: pd.DataFrame
) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Compare SDK API doc generation summary with SDK API per file summary

    Parameters
    ----------
    sdk_file_df: pd.DataFrame
        A dataframe of SDK API per file summary

    sdk_gen_doc_df: pd.DataFrame
        A dataframe of SDK API doc generation summary

    Returns
    -------
    common_df: pd.DataFrame
        A dataframe of common SDK API

    df: pd.DataFrame
        A dataframe of undocumented SDK API
    """

    # find filename of sdk_gen_doc_df that is in sdk_file_df
    common_df = sdk_gen_doc_df[sdk_gen_doc_df["filename"].isin(sdk_file_df["filename"])]

    # find filename that is different than common_df filename
    undocumented_header_df = sdk_file_df[
        ~sdk_file_df["filename"].isin(common_df["filename"])
    ]

    return common_df, undocumented_header_df


def main() -> None:
    """Main function"""

    args = _get_args()

    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)

    output_json = os.path.join(args.output_dir, args.output_json)

    print("Inputs")
    print("-------")
    print("API HTML search path: {}".format(args.api_doc_gen_dir))
    print("Output json file: {}".format(output_json))
    print()

    # load SDK file list
    sdk_file_df = load_sdk_file_summary(sdk_dir=args.sdk_dir)

    # load SDK API doc generation list
    html_search_path = args.api_doc_gen_dir
    sdk_gen_doc_df = load_sdk_api_doc_gen_summary(html_search_path)

    _, undocumented_header_df = diff_sdk_api_doc_gen_per_file(
        sdk_file_df, sdk_gen_doc_df
    )

    api_percentage, undocumented_header_api_df = diff_sdk_api_doc_gen_per_api(
        header_search_path=html_search_path
    )

    # create a list from undocumented_header_api_df for "is_documented" column is false
    undocumented_header_api_df = undocumented_header_api_df[
        undocumented_header_api_df["is_documented"] == False
    ]

    # output the result
    report = {}
    report["total_sdk_files"] = len(sdk_file_df)
    report["total_sdk_files_api_doc_gen"] = len(sdk_gen_doc_df)
    report["total_sdk_files_undocumented"] = len(undocumented_header_df)

    # fill zero data as placeholder
    report["total_sdk_apis"] = len(undocumented_header_api_df)
    report["total_sdk_apis_api_doc_gen"] = int(
        undocumented_header_api_df["is_documented"].sum()
    )
    report["total_sdk_apis_undocumented"] = (
        report["total_sdk_apis"] - report["total_sdk_apis_api_doc_gen"]
    )

    report["undocumented_files"] = undocumented_header_df["filename"].tolist()
    report["sdk_file_doc_gen_percent"] = "{:.2f}".format(
        (len(sdk_gen_doc_df) / len(sdk_file_df)) * 100
    )

    report["sdk_apis_doc_gen_percent"] = "{:.2f}".format(api_percentage)

    # save report to json file
    with open(output_json, "w") as f:
        json.dump(report, f, indent=4)

    print("Summary")
    print("-------")
    print("Output json file: {}".format(output_json))

    print("Total number of SDK header files: {}".format(report["total_sdk_files"]))
    print(
        "Total number of SDK API doc generated: {}".format(
            report["total_sdk_files_api_doc_gen"]
        )
    )
    print(
        "Total number of undocumented SDK API: {}".format(
            report["total_sdk_files_undocumented"]
        )
    )
    print(
        "Percentage of files SDK API doc generated: {}".format(
            report["sdk_file_doc_gen_percent"]
        )
    )
    print(
        "Percentage of SDK API doc generated: {}".format(
            report["sdk_file_doc_gen_percent"]
        )
    )


if __name__ == "__main__":
    main()
