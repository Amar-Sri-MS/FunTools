# event.py
#
# Copyright (c) 2017 Fungible Inc.  All rights reserved.

import re
import sys

# Defines for F1.  These all are borrowed from FunOS/nucleus/faddr.h.
# First and last GID for processing and central clusters.
GID_PC_BASE = 0
GID_PC_MAX = 8

# First and last GID for Host Units.
GID_HU_BASE = 16
GID_HU_MAX = 19

# First and last GID for Network Units.
GID_NU_BASE = 9
GID_NU_MAX = 11

# First LID for VPs in the cluster.  Two LIDs exist
LID_VP_BASE = 8

# Names of blocks and accelerators inside clusters.
pc_lid_table = ['CA', 'UA', 'BAM', 'DMA', 'RGX', 'LE', 'ZIP', 'WQM']
# Other valid values for block.
major_blocks = ['VP', 'HU', 'NU']

TOPO_MAX_VPS_PER_CORE = 4


class FabricAddress(object):
    """Representation of a F1 fabric address.

    This includes both the location and the queue.
    """
    def __init__(self):
        """Creates a new fabric address from canonical string."""
        self.raw_value = 0
        # For non-NU blocks.
        # Cluster/group.  NU is 9..11, HU is 16..19, HNU is 20..21.
        # Always 5 bits.
        self.gid = 0
        # Local id - hardware block or core/VP.  VPs start at 8.
        # For HU and NU, lid is always 0.
        # For VPs, lid is 5 bits.
        self.lid = 0
        # Queue.  For VPs, 1 = high priority queue.
        # For HU, queue is 11 bits.  For NU, queue is 14 bits.
        # For VPS, queue is 8 bits.
        self.queue = 0

    def __eq__(self, other):
        """Returns true if self and other are the same fabric address."""
        return (self.gid == other.gid and self.lid == other.lid and
                self.queue == other.queue)

    def __hash__(self):
        return hash((self.gid, self.lid, self.queue))

    @classmethod
    def from_ordinal(cls, src_id):
        """Create fabric address from index of VP. """
        if src_id > ((GID_PC_MAX + 1) * 6 * 4):
            raise ValueError('Out of range src: 0%d' % src_id)

        cluster = src_id / 24
        core_vp = (src_id % 24)

        faddr = FabricAddress()
        faddr.gid = cluster
        faddr.lid = core_vp + LID_VP_BASE
        return faddr

    @classmethod
    def from_faddr(cls, faddr_int):
        """Create FabricAddress from integer value of faddr.

        Returns None if an invalid value.
        """
        if faddr_int & 0xfff00000 != 0:
            # fabric address only uses 20 bits.
            raise ValueError('FabricAddress out of range: 0x%06x' % faddr_int)

        faddr = FabricAddress()
        faddr.raw_value = faddr_int

        faddr.gid = (faddr_int >> 15) & 0x1f
        if faddr.gid >= GID_HU_BASE and faddr.gid <= GID_HU_MAX:
            faddr.lid = 0
            faddr.queue = (fadddr_int >> 2) & 0x7ff

        elif faddr.gid >= GID_NU_BASE and faddr.gid <= GID_NU_MAX:
            faddr.lid = 0
            faddr.queue = (faddr_int >> 1) & 0x3fff

        elif faddr.gid >= GID_PC_BASE and faddr.gid <= GID_PC_MAX:
            faddr.lid = (faddr_int >> 10) & 0x1f
            faddr.queue = (faddr_int >> 2) & 0xff

        else:
            # Unknown block.
            return None

        return faddr

    @classmethod
    def from_string(cls, string_value):
        """Create FabricAddress from string generated by FADDR_ARGS.

        Returns None if an invalid string.
        """
        match = re.match('FA([0-9]+):([0-9]+):([0-9]+)\[(.*)\]', string_value)
        if not match:
            return None
        gid = int(match.group(1))
        lid = int(match.group(2))
        queue = int(match.group(3))
        block = match.group(4)


        if block not in major_blocks and block not in pc_lid_table:
            raise ValueError('Unknown block ' + block)

        # TODO(bowdidge): Double-check block matches address.
        fa = FabricAddress()

        if gid > GID_PC_BASE:
            fa.raw_value = (gid << 15) + (queue << 2)
        else:
            fa.raw_value = (gid << 15) + (lid << 10) + (queue << 2)
        fa.gid = gid
        fa.lid = lid
        fa.queue = queue

        return fa

    def is_accelerator(self):
        """Returns True if fabric address is an accelerator block.

        Accelerator means any of the hardware blocks in a cluster.
        """
        return (self.gid >= GID_PC_BASE and self.gid <= GID_PC_MAX and
                self.lid < LID_VP_BASE)

    def is_hu(self):
        """Returns True if fabric address is a Host Unit (PCI) block."""
        return self.gid >= GID_HU_BASE and self.gid <= GID_HU_MAX

    def is_nu(self):
        """Returns True if fabric address is a Network Unit block."""
        return self.gid >= GID_NU_BASE and self.gid <= GID_NU_MAX

    def is_vp(self):
        return self.gid <= GID_PC_MAX and self.lid >= LID_VP_BASE

    def is_cluster(self):
        """Returns True if fabric address goes to a PC or CC."""
        return self.gid <= GID_PC_MAX

    def is_high_priority_queue(self):
        """True if fabric address is a high priority queue on a VP."""
        if not self.is_vp():
            return False

        return self.queue % 2 == 1

    def as_vp_hash(self):
        """Returns a VP-unique has value.

        Fabric addresses representing different WU queues on the same VP
        get the same value.

        Raises exception if not a VP.
        """
        if not self.is_cluster():
            raise ValueError('as_vp_hash: not a VP: {}'.format(
                    self.as_faddr_str()))
        return self.gid << 5 | self.lid

    def as_faddr_str(self):
        """Returns fabric address in same form as FADDR_ARGS on FunOS."""
        return 'FA{}:{}:{}[{}]'.format(self.gid, self.lid, self.queue,
                                       self.block_name())

    def block_name(self):
        if self.is_hu():
            return 'HU'
        if self.is_nu():
            return 'NU'
        if self.is_cluster():
            if self.lid < LID_VP_BASE:
                return pc_lid_table[self.lid]
            return 'VP'
        raise 'Unknown block for faddr %d' % self.raw_value

    def __str__(self):
        """Returns a human-readable string for fabric address.

        This should describe the fabric address in whatever makes sense
        for humans discussing code.
        """
        if self.is_hu():
            return 'HU{}'.format(self.gid - GID_HU_BASE)
        if self.is_nu():
            return 'NU{}'.format(self.gid - GID_NU_BASE)
        if self.lid < LID_VP_BASE:
            return '{}{}'.format(pc_lid_table[self.lid], self.gid)
        else:
            core = (self.lid - LID_VP_BASE) / TOPO_MAX_VPS_PER_CORE
            vp = (self.lid - LID_VP_BASE) % TOPO_MAX_VPS_PER_CORE
            return 'VP{}.{}.{}'.format(self.gid, core, vp)
        raise ValueError('Unknown block ' + self.block)


class Transaction(object):
    """Container for a sequence of related WU events."""
    def __init__(self, root_event, label=None):
        # List of work units and other events done as part of the transaction.
        self.root_event = root_event

        if label is not None:
            self.label = label
        else:
            self.label = root_event.label

    def __str__(self):
        return '<Transaction: %s, root event %s>' % (
            self.label, self.root_event)

    def __repr__(self):
        return '<Transaction: %s, root event %s>' % (
            self.label, self.root_event)

    def as_dict(self):
        """Returns transaction as a dictionary of explicit values.

        The dictionary defines an API of values that templates can view,
        or that can be outputted as JSON.
        """
        all_events = [e.as_dict() for e in self.flatten()]
        min_time = min([x['start_time'] for x in all_events
                        if not x['is_timer']])
        max_time = max([x['end_time'] for x in all_events
                        if not x['is_timer']])
        overall_duration = max_time - min_time

        # Limit bars to 98% of container so they don't trigger a new line.
        MAX_PCT = 98

        for event in all_events:
            offset_time = event['start_time'] - min_time
            # Offset from start of tration to current event.
            event['overall_duration'] = overall_duration
            if max_time - min_time == 0:
                event['offset_pct'] = 0
                event['duration_pct'] = MAX_PCT
            else:
                event['offset_pct'] = MAX_PCT * offset_time / overall_duration
                event['duration_pct'] = (MAX_PCT * event['duration']
                                         / overall_duration)

        return {
            'label': self.label,
            'start_time': self.start_time(),
            'end_time': self.end_time(),
            'duration_nsecs': self.duration(),
            'events': all_events
            }

    def start_time(self):
        """Time in nanosecondseconds since epoch when the first WU started."""
        # TODO(bowdidge): Stop recalculating this each time.
        if not self.root_event:
            return 0
        start = self.root_event.start_time
        for e in self.flatten():
            if start > e.start_time:
                start = e.start_time
        return start

    def end_time(self):
        """Time in nanoseconds since epoch when the last WU finished."""
        if not self.root_event:
            return 0
        end = self.root_event.end_time
        for e in self.flatten():
            if e.is_timer:
                continue
            if end < e.end_time:
                end = e.end_time
        return end

    def duration(self):
        """Number of nanoseconds elapsed during transaction."""
        return self.end_time() - self.start_time()

    def remove(self, event):
        """Removes a specific WU event from a transaction."""
        if event == self.root_event:
            self.root_event = None
            return

        # walk through all elements
        for e in self.flatten():
            if event in e.successors:
                e.successors.remove(event)
                return

    def flatten(self):
        """Returns all events in this transaction in a single list."""
        if self.root_event == None:
            return []
        result = []
        worklist = [self.root_event]
        while (len(worklist) > 0):
            first = worklist[0]
            worklist = worklist[1:]
            if first not in result:
                result.append(first)
                worklist += first.successors
        return sorted(result, key=lambda x: x.start_time)


class TraceEvent(object):
    """A work unit (WU) or other action that occurred during the trace,
    Trace events can also represent timer set/trigger pairs.
    """
    def __init__(self, start_time, end_time, label, vp, keywords):
        # When the event started.
        self.start_time = start_time

        # When the event ended.
        self.end_time = end_time

        # Text label to display when showing this event.
        self.label = label

        # Virtual processor where this event ran.
        # String of form FA[0-9]+.[0-9]+.[0-9]+.*
        # Ex: FA0:8:0[VP0.0], FA1:13:0[VP1.1].
        #
        self.vp = vp

        # Transactions holding this event.
        self.transaction = None

        # True if this event represents a timer set and trigger.  For
        # timers, the start_time represents the time when the timer
        # was set, and the end_time represents the time when the timer
        # was triggered.
        self.is_timer = False

        self.is_annotation = False

        # Work units or events that were instigated by this event.
        self.successors = []

        # Raw key/value pairs from trace file.
        self.keywords = keywords

    def as_dict(self):
        return {'start_time': self.start_time,
                'end_time': self.end_time,
                'duration': self.duration(),
                'label': self.label,
                'vp': self.vp,
                # No transaction because it is an object.
                'is_timer': self.is_timer,
                'is_annotation': self.is_annotation
                }

    def range(self):
        """Returns start and end time for this event alone."""
        return (self.start_time, self.end_time)

    def duration(self):
        """Returns time spent only in this event in nanoseconds."""
        return self.end_time - self.start_time

    def __cmp__(self, other):
        if other is None:
            return 1
        return cmp((self.label, self.start_time, self.end_time),
                   (other.label, other.start_time, other.end_time))

    def __str__(self):
        return '<TraceEvent: %s - %s %s>' % (self.start_time, self.end_time,
                                             self.label)

    def __repr__(self):
        return '<TraceEvent: %s - %s %s>' % (self.start_time, self.end_time,
                                             self.label)
