#!/usr/bin/python2.7

# input: .instr_dasm (generated by instr_dasm.py)
# output: .instr_count

import os
import sys
import argparse
import subprocess
import itertools

is_debug = False

def dprint(s):
  if is_debug:
    print >> sys.stderr, s

def parse_instr_count(in_file):
  # format: <count>\t<file_loc>\t<func_range>\t<code>
  data = []
  with open(in_file, 'r') as f:
    for line in f:
      if line[0] == '\t':
        continue
      v = line.strip().split('\t', 3)
      data.append(v)
  return data

def loc_cmp(a, b):
  (f1, l1) = a.split(':')
  (f2, l2) = b.split(':')
  if f1 == f2:
    try:
      l1 = int(l1)
      l2 = int(l2)
    except:
      pass
    if l1 == l2:
      return 0
    return -1 if l1 < l2 else 1
  return -1 if f1 < f2 else 1

def func_range_to_name(frange):
  return frange.split('>', 1)[0].split('+', 1)[0].split('<')[1]

def fname_cmp(a, b):
  f1 = fname = func_range_to_name(a[2])
  f2 = fname = func_range_to_name(b[2])
  if f1 == f2:
    return 0
  return -1 if f1 < f2 else 1

def group_key(a):
  fname = func_range_to_name(a[2])
  return fname

def sort_by_fname(data):
  return sorted(data, cmp=fname_cmp)

def count_fname_cmp(a, b):
  a0 = abs(a[0])
  b0 = abs(b[0])
  if a0 == b0:
    if a[1] == b[1]:
      return 0
    return -1 if a[1] < b[1] else 1
  return -1 if a0 < b0 else 1

def group_by_fname(data, is_sort_values=True):
  g_data = {}
  for fname, vlist in itertools.groupby(data, key=group_key):
    if is_sort_values:
      fl_c_map = {}
      for v in vlist:
        fl_c_map[v[1]] = v

      vlist = []
      for fl in sorted(fl_c_map, cmp=loc_cmp):
        v = fl_c_map[fl]
        vlist.append(v)

    instr_count = 0
    for v in vlist:
      try:
        instr_count += int(v[0])
      except:
        pass

    g_data[fname] = [instr_count, vlist]
  return g_data

def group_data_prepare(in_file):
  dprint('parsing %s' % in_file)
  data = parse_instr_count(in_file)

  dprint('sorting by function name')
  data = sort_by_fname(data)

  dprint('grouping by function name')
  data = group_by_fname(data)

  return data

def group_data_sort_by_count(g_data):
  dprint('sorting group data by count')
  data = []
  for fname, (count, vlist) in g_data.iteritems():
    data.append([count, fname, vlist])

  data = sorted(data, cmp=count_fname_cmp, reverse=True)
  return data

def instr_count_by_func(in_file, out_f):
  data = group_data_prepare(in_file)
  data = group_data_sort_by_count(data)

  # write output
  for count, fname, vlist in data:
    out_f.write('%s\t%s\n' % (count, fname))
    for v in vlist:
      v = v[0:2] + v[3:]
      out_f.write('\t%s\n' % '\t'.join(v))

  return data

def main():
  def usage():
    print 'usage: %s query_cmd <instr_count_file>' % sys.argv[0]

  parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
  parser.add_argument('query_cmd', choices=['group_by_func'], default='query command')
  parser.add_argument('instr_count_file', nargs='?', default='funos-f1-emu.instr_count')
  args = parser.parse_args()

  in_file = 'funos-f1-emu.instr_count'
  if os.path.isdir(args.instr_count_file):
    in_file = os.path.join(args.instr_count_file, in_file)
  else:
    in_file = args.instr_count_file

  if not os.path.isfile(in_file):
    print 'File does not exist: %s' % in_file
    usage()
    return -1
  if not in_file.endswith('.instr_count'):
    print 'WARNING: File does not end with .instr_count: %s' % in_file

  out_f = sys.stdout
  if args.query_cmd == 'group_by_func':
    instr_count_by_func(in_file, out_f)
    return 0

  usage()
  return -1

if __name__ == '__main__':
  sys.exit(main())
